<html><head><meta charset="UTF-8"><style>

  /*******************************
            Flex Layout
  *******************************/

  html /deep/ .layout.horizontal,
  html /deep/ .layout.horizontal-reverse,
  html /deep/ .layout.vertical,
  html /deep/ .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  html /deep/ .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  html /deep/ .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  html /deep/ .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  html /deep/ .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  html /deep/ .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  html /deep/ .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  html /deep/ .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  html /deep/ .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  html /deep/ .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  html /deep/ .flex,
  html /deep/ .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  html /deep/ .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  html /deep/ .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  html /deep/ .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  html /deep/ .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  html /deep/ .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  html /deep/ .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  html /deep/ .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  html /deep/ .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  html /deep/ .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  html /deep/ .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  html /deep/ .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  html /deep/ .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  html /deep/ .layout.center,
  html /deep/ .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  html /deep/ .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  html /deep/ .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  html /deep/ .layout.center-justified,
  html /deep/ .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  html /deep/ .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  html /deep/ .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  html /deep/ .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  html /deep/ .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  html /deep/ .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  html /deep/ .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  html /deep/ .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  html /deep/ .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  html /deep/ [hidden] {
    display: none !important;
  }

  html /deep/ .invisible {
    visibility: hidden !important;
  }

  html /deep/ .relative {
    position: relative;
  }

  html /deep/ .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  html /deep/ .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  html /deep/ .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  html /deep/ .fixed-right {
    top: 0;
    right: 0;
    botttom: 0;
  }

  html /deep/ .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  html /deep/ .fixed-left {
    top: 0;
    botttom: 0;
    left: 0;
  }

</style>
<style>

  /*******************************
            Flex Layout
  *******************************/

  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }

  .invisible {
    visibility: hidden !important;
  }

  .relative {
    position: relative;
  }

  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  /* fixed position */

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }

  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }

</style>
<script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
Polymer = {
Settings: function () {
var user = window.Polymer || {};
location.search.slice(1).split('&').forEach(function (o) {
o = o.split('=');
o[0] && (user[o[0]] = o[1] || true);
});
var wantShadow = user.dom === 'shadow';
var hasShadow = Boolean(Element.prototype.createShadowRoot);
var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
var useShadow = wantShadow && hasShadow;
var hasNativeImports = Boolean('import' in document.createElement('link'));
var useNativeImports = hasNativeImports;
var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
return {
wantShadow: wantShadow,
hasShadow: hasShadow,
nativeShadow: nativeShadow,
useShadow: useShadow,
useNativeShadow: useShadow && nativeShadow,
useNativeImports: useNativeImports,
useNativeCustomElements: useNativeCustomElements
};
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
var ctor = desugar(prototype);
prototype = ctor.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return ctor;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
window.Polymer = Polymer;
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._registerFeatures();
this._doBehavior('registered');
},
createdCallback: function () {
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
attachedCallback: function () {
this.isAttached = true;
this._doBehavior('attached');
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name) {
this._setAttributeToProperty(this, name);
this._doBehavior('attributeChanged', arguments);
},
extend: function (prototype, api) {
if (prototype && api) {
Object.getOwnPropertyNames(api).forEach(function (n) {
this.copyOwnProperty(n, api, prototype);
}, this);
}
return prototype || api;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
(function () {
var modules = {};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
DomModule.prototype.constructor = DomModule;
DomModule.prototype.createdCallback = function () {
var id = this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
}
};
DomModule.prototype.import = function (id, slctr) {
var m = modules[id];
if (!m) {
forceDocumentUpgrade();
m = modules[id];
}
if (m && slctr) {
m = m.querySelector(slctr);
}
return m;
};
var cePolyfill = window.CustomElements && !CustomElements.useNative;
if (cePolyfill) {
var ready = CustomElements.ready;
CustomElements.ready = true;
}
document.registerElement('dom-module', DomModule);
if (cePolyfill) {
CustomElements.ready = ready;
}
function forceDocumentUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
if (script) {
CustomElements.upgradeAll(script.ownerDocument);
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_prepBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._flattenBehaviorsList(this.behaviors);
}
this._prepAllBehaviors(this.behaviors);
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
behaviors.forEach(function (b) {
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}, this);
return flat;
},
_prepAllBehaviors: function (behaviors) {
for (var i = behaviors.length - 1; i >= 0; i--) {
this._mixinBehavior(behaviors[i]);
}
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_mixinBehavior: function (b) {
Object.getOwnPropertyNames(b).forEach(function (n) {
switch (n) {
case 'hostAttributes':
case 'registered':
case 'properties':
case 'observers':
case 'listeners':
case 'created':
case 'attached':
case 'detached':
case 'attributeChanged':
case 'configure':
case 'ready':
break;
default:
if (!this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
break;
}
}, this);
},
_doBehavior: function (name, args) {
this.behaviors.forEach(function (b) {
this._invokeBehavior(b, name, args);
}, this);
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
this.behaviors.forEach(function (b) {
this._marshalBehavior(b);
}, this);
this._marshalBehavior(this);
}
});
Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
this.behaviors.some(function (b) {
return info = this._getPropertyInfo(property, b.properties);
}, this);
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
}
});
Polymer.CaseMap = {
_caseMap: {},
dashToCamelCase: function (dash) {
var mapped = Polymer.CaseMap._caseMap[dash];
if (mapped) {
return mapped;
}
if (dash.indexOf('-') < 0) {
return Polymer.CaseMap._caseMap[dash] = dash;
}
return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
return m[1].toUpperCase();
});
},
camelToDashCase: function (camel) {
var mapped = Polymer.CaseMap._caseMap[camel];
if (mapped) {
return mapped;
}
return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
return g[0] + '-' + g[1].toLowerCase();
});
}
};
Polymer.Base._addFeature({
_prepAttributes: function () {
this._aggregatedAttributes = {};
},
_addHostAttributes: function (attributes) {
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
this._applyAttributes(this, this._aggregatedAttributes);
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
this.serializeValueToAttribute(attr$[n], n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
for (var i = 0, l = this.attributes.length; i < l; i++) {
this._setAttributeToProperty(model, this.attributes[i].name);
}
},
_setAttributeToProperty: function (model, attrName) {
if (!this._serializing) {
var propName = Polymer.CaseMap.dashToCamelCase(attrName);
var info = this.getPropertyInfo(propName);
if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
var val = this.getAttribute(attrName);
model[propName] = this.deserialize(val, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (name) {
this._serializing = true;
this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value !== null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value;
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return debouncer && debouncer.finish;
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.version = '1.0.7';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
}
});</script>

<script>Polymer.Base._addFeature({
_prepTemplate: function () {
this._template = this._template || Polymer.DomModule.import(this.is, 'template');
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_pushHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._beginHost();
},
_beginHost: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_popHost: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
this._setupRoot();
this._readyClients();
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
this._finishDistribute();
this._clientsReadied = true;
this._clients = null;
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.EventApi = function () {
var Settings = Polymer.Settings;
var EventApi = function (event) {
this.event = event;
};
if (Settings.useShadow) {
EventApi.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
return this.event.path;
}
};
} else {
EventApi.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var o = this.rootTarget;
while (o) {
path.push(o);
o = Polymer.dom(o).parentNode || o.host;
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new EventApi(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
c$ = composed ? node._composedChildren : c$;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
var nativeAppendChild = Element.prototype.appendChild;
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
var dirtyRoots = [];
var DomApi = function (node) {
this.node = node;
if (this.patch) {
this.patch();
}
};
DomApi.prototype = {
flush: function () {
for (var i = 0, host; i < dirtyRoots.length; i++) {
host = dirtyRoots[i];
host.flushDebouncer('_distribute');
}
dirtyRoots = [];
},
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
host.debounce('_distribute', host._distributeContent);
dirtyRoots.push(host);
}
},
appendChild: function (node) {
var handled;
this._removeNodeFromHost(node, true);
if (this._nodeIsInLogicalTree(this.node)) {
this._addLogicalInfo(node, this.node);
this._addNodeToHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled && !this._tryRemoveUndistributedNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node);
nativeAppendChild.call(container, node);
}
return node;
},
insertBefore: function (node, ref_node) {
if (!ref_node) {
return this.appendChild(node);
}
var handled;
this._removeNodeFromHost(node, true);
if (this._nodeIsInLogicalTree(this.node)) {
saveLightChildrenIfNeeded(this.node);
var children = this.childNodes;
var index = children.indexOf(ref_node);
if (index < 0) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
this._addLogicalInfo(node, this.node, index);
this._addNodeToHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled && !this._tryRemoveUndistributedNode(node)) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node, ref_node);
nativeInsertBefore.call(container, node, ref_node);
}
return node;
},
removeChild: function (node) {
if (factory(node).parentNode !== this.node) {
console.warn('The node to be removed is not a child of this node', node);
}
var handled;
if (this._nodeIsInLogicalTree(this.node)) {
this._removeNodeFromHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (container === node.parentNode) {
removeFromComposedParent(container, node);
nativeRemoveChild.call(container, node);
}
}
return node;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
if (node._ownerShadyRoot === undefined) {
var root;
if (node._isShadyRoot) {
root = node;
} else {
var parent = Polymer.dom(node).parentNode;
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
node._ownerShadyRoot = root;
}
return node._ownerShadyRoot;
},
_maybeDistribute: function (node, parent) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this._ownerShadyRootForNode(parent);
if (root) {
var host = root.host;
this._updateInsertionPoints(host);
this._lazyDistribute(host);
}
}
var parentNeedsDist = this._parentNeedsDistribution(parent);
if (parentNeedsDist) {
this._lazyDistribute(parent);
}
return parentNeedsDist || hasContent && !wrappedContent;
},
_tryRemoveUndistributedNode: function (node) {
if (this.node.shadyRoot) {
if (node._composedParent) {
nativeRemoveChild.call(node._composedParent, node);
}
return true;
}
},
_updateInsertionPoints: function (host) {
host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
},
_nodeIsInLogicalTree: function (node) {
return Boolean(node._lightParent !== undefined || node._isShadyRoot || this._ownerShadyRootForNode(node) || node.shadyRoot);
},
_parentNeedsDistribution: function (parent) {
return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
},
_removeNodeFromHost: function (node, ensureComposedRemoval) {
var hostNeedsDist;
var root;
var parent = node._lightParent;
if (parent) {
root = this._ownerShadyRootForNode(node);
if (root) {
root.host._elementRemove(node);
hostNeedsDist = this._removeDistributedChildren(root, node);
}
this._removeLogicalInfo(node, node._lightParent);
}
this._removeOwnerShadyRoot(node);
if (root && hostNeedsDist) {
this._updateInsertionPoints(root.host);
this._lazyDistribute(root.host);
} else if (ensureComposedRemoval) {
removeFromComposedParent(parent || node.parentNode, node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = factory(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = node.parentNode;
if (parent) {
removeFromComposedParent(parent, node);
nativeRemoveChild.call(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = factory(node).parentNode;
}
},
_addNodeToHost: function (node) {
var checkNode = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.firstChild : node;
var root = this._ownerShadyRootForNode(checkNode);
if (root) {
root.host._elementAdd(node);
}
},
_addLogicalInfo: function (node, container, index) {
saveLightChildrenIfNeeded(container);
var children = factory(container).childNodes;
index = index === undefined ? children.length : index;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
children.splice(index++, 0, n);
n._lightParent = container;
}
} else {
children.splice(index, 0, node);
node._lightParent = container;
}
},
_removeLogicalInfo: function (node, container) {
var children = factory(container).childNodes;
var index = children.indexOf(node);
if (index < 0 || container !== node._lightParent) {
throw Error('The node to be removed is not a child of this node');
}
children.splice(index, 1);
node._lightParent = null;
},
_removeOwnerShadyRoot: function (node) {
var hasCachedRoot = factory(node).getOwnerRoot() !== undefined;
if (hasCachedRoot) {
var c$ = factory(node).childNodes;
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = factory(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = factory(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
return this.querySelectorAll(selector)[0];
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return matchesSelector.call(n, selector);
}, this.node);
},
_query: function (matcher, node) {
node = node || this.node;
var list = [];
this._queryElements(factory(node).childNodes, matcher, list);
return list;
},
_queryElements: function (elements, matcher, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
this._queryElement(c, matcher, list);
}
}
},
_queryElement: function (node, matcher, list) {
if (matcher(node)) {
list.push(node);
}
this._queryElements(factory(node).childNodes, matcher, list);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
queryDistributedElements: function (selector) {
var c$ = this.childNodes;
var list = [];
this._distributedFilter(selector, c$, list);
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
this._distributedFilter(selector, factory(c).getDistributedNodes(), list);
}
}
return list;
},
_distributedFilter: function (selector, list, results) {
results = results || [];
for (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {
if (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {
results.push(d);
}
}
return results;
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._distributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._distributeParent();
},
_distributeParent: function () {
if (this._parentNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = factory(externalNode).childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
}
};
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
if (!Settings.useShadow) {
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
var c$ = getLightChildren(this.node);
return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
configurable: true
},
parentNode: {
get: function () {
return this.node._lightParent || (this.node.__patched ? this.node._composedParent : this.node.parentNode);
},
configurable: true
},
firstChild: {
get: function () {
return this.childNodes[0];
},
configurable: true
},
lastChild: {
get: function () {
var c$ = this.childNodes;
return c$[c$.length - 1];
},
configurable: true
},
nextSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
firstElementChild: {
get: function () {
return this.children[0];
},
configurable: true
},
lastElementChild: {
get: function () {
var c$ = this.children;
return c$[c$.length - 1];
},
configurable: true
},
nextElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
textContent: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return this.node.textContent;
} else {
return Array.prototype.map.call(this.childNodes, function (c) {
return c.textContent;
}).join('');
}
},
set: function (text) {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
},
configurable: true
},
innerHTML: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
if (this.node.nodeType !== Node.TEXT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = Array.prototype.slice.call(d.childNodes);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.prototype._getComposedInnerHTML = function () {
return getInnerHTML(this.node, true);
};
} else {
DomApi.prototype.querySelectorAll = function (selector) {
return Array.prototype.slice.call(this.node.querySelectorAll(selector));
};
DomApi.prototype.getOwnerRoot = function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
};
DomApi.prototype.cloneNode = function (deep) {
return this.node.cloneNode(deep);
};
DomApi.prototype.importNode = function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
};
DomApi.prototype.getDestinationInsertionPoints = function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype.getDistributedNodes = function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype._distributeParent = function () {
};
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
return Array.prototype.slice.call(this.node.childNodes);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.slice.call(this.node.children);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwards = [
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
];
forwards.forEach(function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
});
}
var CONTENT = 'content';
var factory = function (node, patch) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi(node, patch);
}
return node.__domApi;
};
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return factory(obj, patch);
}
};
Polymer.dom.flush = DomApi.prototype.flush;
function getLightChildren(node) {
var children = node._lightChildren;
return children ? children : node.childNodes;
}
function getComposedChildren(node) {
if (!node._composedChildren) {
node._composedChildren = Array.prototype.slice.call(node.childNodes);
}
return node._composedChildren;
}
function addToComposedParent(parent, node, ref_node) {
var children = getComposedChildren(parent);
var i = ref_node ? children.indexOf(ref_node) : -1;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var fragChildren = getComposedChildren(node);
for (var j = 0; j < fragChildren.length; j++) {
addNodeToComposedChildren(fragChildren[j], parent, children, i + j);
}
node._composedChildren = null;
} else {
addNodeToComposedChildren(node, parent, children, i);
}
}
function addNodeToComposedChildren(node, parent, children, i) {
node._composedParent = parent;
children.splice(i >= 0 ? i : children.length, 0, node);
}
function removeFromComposedParent(parent, node) {
node._composedParent = null;
if (parent) {
var children = getComposedChildren(parent);
var i = children.indexOf(node);
if (i >= 0) {
children.splice(i, 1);
}
}
}
function saveLightChildrenIfNeeded(node) {
if (!node._lightChildren) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
child._lightParent = child._lightParent || node;
}
node._lightChildren = c$;
}
}
function hasInsertionPoint(root) {
return Boolean(root._insertionPoints.length);
}
var p = Element.prototype;
var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return {
getLightChildren: getLightChildren,
getComposedChildren: getComposedChildren,
removeFromComposedParent: removeFromComposedParent,
saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
matchesSelector: matchesSelector,
hasInsertionPoint: hasInsertionPoint,
ctor: DomApi,
factory: factory
};
}();
(function () {
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_poolContent: function () {
if (this._useContent) {
saveLightChildrenIfNeeded(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLightChildren(this._lightChildren);
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
saveLightChildrenIfNeeded(this.shadyRoot);
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
var dom = Polymer.dom(this);
if (updateInsertionPoints) {
dom._updateInsertionPoints(this);
}
var host = getTopDistributingHost(this);
dom._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
if (hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
} else {
if (!this.shadyRoot._hasDistributed) {
this.textContent = '';
this._composedChildren = null;
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
this.shadyRoot._hasDistributed = true;
this.shadyRoot._distributionClean = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = getLightChildren(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = p._lightParent || p.parentNode;
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = getLightChildren(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = getComposedChildren(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
remove(n);
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (var j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
var getLightChildren = Polymer.DomApi.getLightChildren;
var matchesSelector = Polymer.DomApi.matchesSelector;
var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
var getComposedChildren = Polymer.DomApi.getComposedChildren;
var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = content._lightParent;
if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
function insertBefore(parentNode, newChild, refChild) {
var newChildParent = getComposedParent(newChild);
if (newChildParent !== parentNode) {
removeFromComposedParent(newChildParent, newChild);
}
remove(newChild);
saveLightChildrenIfNeeded(parentNode);
nativeInsertBefore.call(parentNode, newChild, refChild || null);
newChild._composedParent = parentNode;
}
function remove(node) {
var parentNode = getComposedParent(node);
if (parentNode) {
saveLightChildrenIfNeeded(parentNode);
node._composedParent = null;
nativeRemoveChild.call(parentNode, node);
}
}
function getComposedParent(node) {
return node.__patched ? node._composedParent : node.parentNode;
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = Polymer.dom(host).children;
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName === 'content') {
return host.domHost;
}
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLightChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>

<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list);
return list;
},
_parseNodeAnnotations: function (node, list) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
},
_testEscape: function (value) {
var escape = value.slice(0, 2);
if (escape === '{{' || escape === '[[') {
return escape;
}
},
_parseTextNodeAnnotation: function (node, list) {
var v = node.textContent;
var escape = this._testEscape(v);
if (escape) {
node.textContent = ' ';
var annote = {
bindings: [{
kind: 'text',
mode: escape[0],
value: v.slice(2, -2).trim()
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, callback) {
if (root.firstChild) {
for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = node.nextSibling;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
root.removeChild(n);
n = n.nextSibling;
}
}
var childAnnotation = this._parseNodeAnnotations(node, list, callback);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
for (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {
var n = a.name, v = a.value;
if (n === 'id' && !this._testEscape(v)) {
annotation.id = v;
} else if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else {
var b = this._parseNodeAttributeAnnotation(node, n, v);
if (b) {
annotation.bindings.push(b);
}
}
}
},
_parseNodeAttributeAnnotation: function (node, n, v) {
var escape = this._testEscape(v);
if (escape) {
var customEvent;
var name = n;
var mode = escape[0];
v = v.slice(2, -2).trim();
var not = false;
if (v[0] == '!') {
v = v.substring(1);
not = true;
}
var kind = 'property';
if (n[n.length - 1] == '$') {
name = n.slice(0, -1);
kind = 'attribute';
}
var notifyEvent, colon;
if (mode == '{' && (colon = v.indexOf('::')) > 0) {
notifyEvent = v.substring(colon + 2);
v = v.substring(0, colon);
customEvent = true;
}
if (node.localName == 'input' && n == 'value') {
node.setAttribute(n, '');
}
node.removeAttribute(n);
if (kind === 'property') {
name = Polymer.CaseMap.dashToCamelCase(name);
}
return {
kind: kind,
mode: mode,
name: name,
value: v,
negate: not,
event: notifyEvent,
customEvent: customEvent
};
}
},
_localSubTree: function (node, host) {
return node === host ? node.childNodes : node._lightChildren || node.childNodes;
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
}
};
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && url[0] === '#') {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
Polymer.Annotations.prepElement = this._prepElement.bind(this);
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
b.signature = this._parseMethod(b.value);
if (!b.signature) {
b.model = this._modelForPath(b.value);
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
mode: '{',
name: '_parent_' + prop,
model: prop,
value: prop
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
notes.forEach(function (n) {
n.bindings.forEach(function (b) {
if (b.signature) {
var args = b.signature.args;
for (var k = 0; k < args.length; k++) {
pp[args[k].model] = true;
}
} else {
pp[b.model] = true;
}
});
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
});
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
this._configureTemplateContent();
},
_configureTemplateContent: function () {
this._notes.forEach(function (note, i) {
if (note.templateContent) {
this._nodes[i]._content = note.templateContent;
}
}, this);
},
_marshalIdNodes: function () {
this.$ = {};
this._notes.forEach(function (a) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}, this);
},
_marshalAnnotatedNodes: function () {
if (this._nodes) {
this._nodes = this._nodes.map(function (a) {
return this._findAnnotatedNode(this.root, a);
}, this);
}
},
_marshalAnnotatedListeners: function () {
this._notes.forEach(function (a) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
a.events.forEach(function (e) {
this.listen(node, e.name, e.value);
}, this);
}
}, this);
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, key;
for (key in listeners) {
if (key.indexOf('.') < 0) {
node = this;
name = key;
} else {
name = key.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[key]);
}
},
listen: function (node, eventName, methodName) {
this._listen(node, eventName, this._createEventHandler(node, eventName, methodName));
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (IS_TOUCH_ONLY) {
return;
}
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = ev.currentTarget;
var gobj = node[GESTURE_KEY];
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
}
}
},
add: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
}
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var se = detail.sourceEvent;
if (se && se.preventDefault) {
se.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
emits: [
'down',
'up'
],
mousedown: function (e) {
var t = Gestures.findOriginalTarget(e);
var self = this;
var upfn = function upfn(e) {
self.fire('up', t, e);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mouseup', upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
fire: function (type, target, event) {
var self = this;
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
prevent: Gestures.prevent.bind(Gestures)
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
prevent: false
},
clearInfo: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
self.info.addMove({
x: x,
y: y
});
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
Gestures.prevent('tap');
movefn(e);
}
self.clearInfo();
document.removeEventListener('mousemove', movefn);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
Gestures.prevent('tap');
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
this.clearInfo();
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
this.save(e);
},
click: function (e) {
this.forward(e);
},
touchstart: function (e) {
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
this.reset();
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new (window.MutationObserver || JsMutationObserver)(Polymer.Async._atEndOfMicrotask.bind(Polymer.Async)).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
this.boundComplete = this.complete.bind(this);
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
var detail = detail === null || detail === undefined ? Polymer.nob : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var event = new CustomEvent(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable,
detail: detail
});
node.dispatchEvent(event);
return event;
},
async: function (callback, waitTime) {
return Polymer.Async.run(callback.bind(this), waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this.get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
if (onload) {
l.onload = onload.bind(this);
}
if (onerror) {
l.onerror = onerror.bind(this);
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
}
});
Polymer.Bind = {
prepareModel: function (model) {
model._propertyEffects = {};
model._bindListeners = [];
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (property) {
var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
Polymer.Base.fire(eventName, { value: this[property] }, {
bubbles: false,
node: this
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
effects.forEach(function (fx) {
var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
if (fn) {
fn.call(this, property, value, fx.effect, old, fromAbove);
}
}, this);
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
fx.push({
kind: kind,
effect: effect
});
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'computedAnnotation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event) {
var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, bogusTest) {
return function (e, target) {
if (!bogusTest(e, target)) {
if (e.detail && e.detail.path) {
this.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
} else {
var value = target[property];
if (!isStructured) {
this[path] = target[property];
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
inst._bindListeners.forEach(function (info) {
var node = inst._nodes[info.index];
node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
});
}
};
Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this.get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(calc, effect);
}
},
_reflectEffect: function (source) {
this.reflectPropertyToAttribute(source);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var fn = this[effect.method];
if (fn) {
this.__setProperty(effect.property, fn.apply(this, args));
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(computedvalue, effect);
}
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base.get(name, model);
} else {
v = model[name];
}
if (args.length > 1 && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
Polymer.Bind.addPropertyEffect(this, property, kind, effect);
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify');
}
if (prop.reflectToAttribute) {
this._addPropertyEffect(p, 'reflect');
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
property: name
});
}, this);
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
observers.forEach(function (observer) {
this._addComplexObserverEffect(observer);
}, this);
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg
});
}, this);
},
_addAnnotationEffects: function (notes) {
this._nodes = [];
notes.forEach(function (note) {
var index = this._nodes.push(note) - 1;
note.bindings.forEach(function (binding) {
this._addAnnotationEffect(binding, index);
}, this);
}, this);
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);
}
if (note.signature) {
this._addAnnotatedComputationEffect(note, index);
} else {
note.index = index;
this._addPropertyEffect(note.model, 'annotation', note);
}
},
_addAnnotatedComputationEffect: function (note, index) {
var sig = note.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, sig, null);
} else {
sig.args.forEach(function (arg) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);
}
}, this);
}
},
__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
kind: note.kind,
property: note.name,
negate: note.negate,
method: sig.method,
args: sig.args,
trigger: trigger
});
},
_parseMethod: function (expression) {
var m = expression.match(/(\w*)\((.*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = {
name: arg,
model: this._modelForPath(arg)
};
var fc = arg[0];
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
Polymer.Bind.setupBindListeners(this);
},
_applyEffectValue: function (value, info) {
var node = this._nodes[info.index];
var property = info.property || info.name || 'textContent';
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
return node[property] = value;
}
},
_executeStaticEffects: function () {
if (this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = initialConfig || {};
this._handlers = [];
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_configValue: function (name, value) {
this._config[name] = value;
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
this.behaviors.forEach(function (b) {
this._configureProperties(b.properties, config);
}, this);
this._configureProperties(this.properties, config);
this._mixinConfigure(config, this._aboveConfig);
this._config = config;
this._distributeConfig(this._config);
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_mixinConfigure: function (a, b) {
for (var prop in b) {
if (!this.getPropertyInfo(prop).readOnly) {
a[prop] = b[prop];
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
if (node._configValue) {
var value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);
node._configValue(x.effect.name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!this._clientsReadied) {
this._queueHandler([
fn,
e,
e.target
]);
} else {
return fn.call(this, e, e.target);
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2]);
}
}
});
(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPath(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
prop = prop[parts[i]];
if (array) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old = prop[last];
var key = coll.getKey(old);
if (key) {
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this.notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var last = parts.pop();
while (parts.length) {
prop = prop[parts.shift()];
if (!prop) {
return;
}
}
return prop[last];
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects[model];
if (fx$) {
fx$.forEach(function (fx) {
var fxFn = this['_' + fx.kind + 'PathEffect'];
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}, this);
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node.notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node.notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unbindPath(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
var from, to;
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
from = a;
to = b;
break;
}
if (path.indexOf(b + '.') == 0) {
from = b;
to = a;
break;
}
}
if (from && to) {
var p = this._fixPath(to, from, path);
this.notifyPath(p, value);
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPath: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, { bubbles: false });
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
_notifySplice: function (array, path, index, added, removed) {
var splices = [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}];
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
this.set(path + '.splices', change);
if (added != removed.length) {
this.notifyPath(path + '.length', array.length);
}
change.keySplices = null;
change.indexSplices = null;
},
push: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
this._notifySplice(array, path, len, args.length, []);
return ret;
},
pop: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var rem = array.slice(-1);
var ret = array.pop.apply(array, args);
this._notifySplice(array, path, array.length, 0, rem);
return ret;
},
splice: function (path, start, deleteCount) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
this._notifySplice(array, path, start, args.length - 2, ret);
return ret;
},
shift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
this._notifySplice(array, path, 0, 0, [ret]);
return ret;
},
unshift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
this._notifySplice(array, path, 0, args.length, []);
return ret;
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});
Polymer.CssParse = function () {
var api = {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(rx.comments, '').replace(rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, s = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(AT_START) === 0;
if (node.atRule) {
if (s.indexOf(MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
}
} else {
if (s.indexOf(VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}'
};
function hasMixinRules(rules) {
return rules[0].selector.indexOf(VAR_START) >= 0;
}
function removeCustomProps(cssText) {
return cssText.replace(rx.customProp, '').replace(rx.mixinProp, '').replace(rx.mixinApply, '').replace(rx.varApply, '');
}
var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';
var rx = {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*var[^;]*(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/
};
return api;
}();
Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css]',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachStyleRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, callback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachStyleRule(this.rulesForStyle(s), callback);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
clearStyleRules: function (style) {
style.__cssRules = null;
},
forEachStyleRule: function (node, callback) {
var s = node.selector;
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
callback(node);
} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachStyleRule(r, callback);
}
}
},
applyCss: function (cssText, moniker, target, afterNode) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
target = target || document.head;
if (!afterNode) {
var n$ = target.querySelectorAll('style[scope]');
afterNode = n$[n$.length - 1];
}
target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
return style;
},
cssFromModule: function (moduleId) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
var cssText = '';
var e$ = Array.prototype.slice.call(m.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'style') {
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
} else {
e = e.import && e.import.body;
}
if (e) {
cssText += Polymer.ResolveUrl.resolveCss(e.textContent, e.ownerDocument);
}
}
m._cssText = cssText;
}
return m && m._cssText || '';
},
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
rule.selector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!nativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'body';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?:\:host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachStyleRule(rules, function (rule) {
var map = self._mapRule(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRule: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || (target.extends = []);
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow && Boolean(this._template);
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
if (cssText && this._template) {
var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
if (!nativeShadow) {
this._scopeStyle = style;
}
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
node.className = self._scopeElementClass(node, node.className);
var n$ = node.querySelectorAll('*');
Array.prototype.forEach.call(n$, function (n) {
n.className = self._scopeElementClass(n, n.className);
});
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
mxns.forEach(function (m) {
if (m.addedNodes) {
for (var i = 0; i < m.addedNodes.length; i++) {
scopify(m.addedNodes[i]);
}
}
});
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {};
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
});
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
var customCssText = '';
var cssText = rule.parsedCssText;
cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
var parts = cssText.split(';');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
customCssText += p + ';\n';
}
}
return customCssText;
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
var def = m[2];
if (def && def.match(this.rx.IS_VAR)) {
props[def] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length && (p = parts[i]); i++) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var pp = p.split(':');
if (pp[1]) {
pp[1] = pp[1].trim();
pp[1] = this.valueForProperty(pp[1], props) || pp[1];
}
p = pp.join(':');
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.selector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (rule.cssText && !nativeShadow) {
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.className = v;
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
rx: {
VAR_ASSIGN: /(?:^|[;\n]\s*)(--[\w-]*?):\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\n])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/i,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gi,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var StyleCache = Polymer.StyleCache;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
},
_setupStyleProperties: function () {
this.customStyle = {};
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = Polymer.dom(node);
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (this.isAttached) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepConstructor();
this._prepTemplate();
this._prepStyles();
this._prepStyleProperties();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._setupConfigure();
this._setupStyleProperties();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalAnnotationReferences();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
this._listenListeners(b.listeners);
}
});
(function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
Polymer({
is: 'custom-style',
extends: 'style',
created: function () {
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement || this;
styleDefaults.addStyle(e);
if (e.textContent) {
this._apply();
} else {
var observer = new MutationObserver(function () {
observer.disconnect();
this._apply();
}.bind(this));
observer.observe(e, { childList: true });
}
}
}
},
_apply: function () {
var e = this.__appliedElement || this;
this._computeStyleProperties();
var props = this._styleProperties;
var self = this;
e.textContent = styleUtil.toCssText(styleUtil.rulesForStyle(e), function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = css.replace(propertyUtils.rx.VAR_ASSIGN, '');
rule.cssText = propertyUtils.valueForProperties(css, props);
}
styleTransformer.documentRule(rule);
});
}
});
}());
Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_templatizerStatic: {
count: 0,
callbacks: {},
debouncer: null
},
_instanceProps: Polymer.nob,
created: function () {
this._templatizerId = this._templatizerStatic.count++;
},
templatize: function (template) {
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepBindings();
this._prepParentProperties(archetype, template);
archetype._notifyPath = this._notifyPathImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (n.style) {
n.style.display = hide ? 'none' : '';
n.__hideTemplateChildren__ = hide;
}
}
},
_debounceTemplate: function (fn) {
this._templatizerStatic.callbacks[this._templatizerId] = fn.bind(this);
this._templatizerStatic.debouncer = Polymer.Debounce(this._templatizerStatic.debouncer, this._flushTemplates.bind(this, true));
},
_flushTemplates: function (debouncerExpired) {
var db = this._templatizerStatic.debouncer;
while (debouncerExpired || db && db.finish) {
db.stop();
var cbs = this._templatizerStatic.callbacks;
this._templatizerStatic.callbacks = {};
for (var id in cbs) {
cbs[id]();
}
debouncerExpired = false;
}
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (var prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
}
for (prop in parentProps) {
var parentProp = '_parent_' + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop)
},
{ kind: 'notify' }
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = this._forwardParentProp.bind(this);
}
this._extendTemplate(template, proto);
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
return function (source, value) {
this.dataHost['_parent_' + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
Object.getOwnPropertyNames(proto).forEach(function (n) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
});
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost.notifyPath('_parent_' + path, value);
}
},
_pathEffector: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf('_parent_') === 0) {
this._forwardParentPath(path.substring(8), value);
}
}
Polymer.Base._pathEffector.apply(this, arguments);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._pushHost(host);
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._popHost();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
for (var prop in this._parentProps) {
model[prop] = this['_parent_' + prop];
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};
Polymer({
is: 'dom-template',
extends: 'template',
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return key;
},
removeKey: function (key) {
this._removeFromMap(this.store[key]);
delete this.store[key];
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
if (item && typeof item == 'object') {
return this.omap.get(item);
} else {
return this.pmap[item];
}
},
getKeys: function () {
return Object.keys(this.store);
},
setItem: function (key, item) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
},
getItem: function (key) {
return this.store[key];
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keySplices = [];
for (var i = 0; i < splices.length; i++) {
var j, o, key, s = splices[i];
var removed = [];
for (j = 0; j < s.removed.length; j++) {
o = s.removed[j];
key = this.remove(o);
removed.push(key);
}
var added = [];
for (j = 0; j < s.addedCount; j++) {
o = this.userArray[s.index + j];
key = this.add(o);
added.push(key);
}
keySplices.push({
index: s.index,
removed: removed,
removedItems: s.removed,
added: added
});
}
return keySplices;
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
},
detached: function () {
for (var i = 0; i < this._instances.length; i++) {
this._detachRow(i);
}
},
attached: function () {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < this._instances.length; i++) {
Polymer.dom(parentNode).insertBefore(this._instances[i].root, this);
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function () {
var dataHost = this._getRootDataHost();
var sort = this.sort;
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function () {
var dataHost = this._getRootDataHost();
var filter = this.filter;
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._splices = [];
this._needFullRefresh = true;
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._splices = this._splices.concat(change.value.keySplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
var c = this.collection;
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else {
if (this._sortFn) {
this._applySplicesUserSort(this._splices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._splices);
}
}
}
this._splices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = 0; i < this._instances.length; i++) {
var inst = this._instances[i];
keyToIdx[inst.__key__] = i;
inst.__setProperty(this.indexAs, i, true);
}
this.fire('dom-change');
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
if (this._filterFn) {
keys = keys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
if (this._sortFn) {
keys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
}
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__setProperty('__key__', key, true);
inst.__setProperty(this.as, c.getItem(key), true);
} else {
this._instances.push(this._insertRow(i, key));
}
}
for (; i < this._instances.length; i++) {
this._detachRow(i);
}
this._instances.splice(keys.length, this._instances.length - keys.length);
},
_keySort: function (a, b) {
return this.collection.getKey(a) - this.collection.getKey(b);
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var instances = this._instances;
var keyMap = {};
var pool = [];
var sortFn = this._sortFn || this._keySort.bind(this);
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var key = s.removed[i];
keyMap[key] = keyMap[key] ? null : -1;
}
for (var i = 0; i < s.added.length; i++) {
var key = s.added[i];
keyMap[key] = keyMap[key] ? null : 1;
}
}, this);
var removedIdxs = [];
var addedKeys = [];
for (var key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort();
for (var i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
pool.push(this._detachRow(idx));
instances.splice(idx, 1);
}
}
}
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
addedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
var start = 0;
for (var i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i], pool);
}
}
},
_insertRowUserSort: function (start, key, pool) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
var sortFn = this._sortFn || this._keySort.bind(this);
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._instances.splice(idx, 0, this._insertRow(idx, key, pool));
return idx;
},
_applySplicesArrayOrder: function (splices) {
var pool = [];
var c = this.collection;
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var inst = this._detachRow(s.index + i);
if (!inst.isPlaceholder) {
pool.push(inst);
}
}
this._instances.splice(s.index, s.removed.length);
for (var i = 0; i < s.added.length; i++) {
var inst = {
isPlaceholder: true,
key: s.added[i]
};
this._instances.splice(s.index + i, 0, inst);
}
}, this);
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder) {
this._instances[i] = this._insertRow(i, inst.key, pool, true);
}
}
},
_detachRow: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
}
return inst;
},
_insertRow: function (idx, key, pool, replace) {
var inst;
if (inst = pool && pool.pop()) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._generateRow(idx, key);
}
var beforeRow = this._instances[replace ? idx + 1 : idx];
var beforeNode = beforeRow ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
return inst;
},
_generateRow: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
var inst = this.stamp(model);
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
this._instances.forEach(function (inst) {
inst.__setProperty(prop, value, true);
}, this);
},
_forwardParentPath: function (path, value) {
this._instances.forEach(function (inst) {
inst.notifyPath(path, value, true);
}, this);
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst.notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
properties: {
items: {
type: Array,
observer: '_itemsChanged'
},
selected: {
type: Object,
notify: true
},
toggle: Boolean,
multi: Boolean
},
_itemsChanged: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
}
if (this.multi) {
this.selected = [];
} else {
this.selected = null;
}
},
deselect: function (item) {
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var sidx = this.selected.indexOf(item);
if (sidx >= 0) {
var skey = scol.getKey(item);
this.splice('selected', sidx, 1);
this.unlinkPaths('selected.' + skey);
return true;
}
} else {
this.selected = null;
this.unlinkPaths('selected');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var skey = scol.getKey(item);
if (skey >= 0) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
this.async(function () {
skey = scol.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
});
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.linkPaths('selected', 'items.' + key);
this.selected = item;
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
this._teardownInstance();
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this._wrapTextNodes(this._content || this.content);
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
parent.insertBefore(root, this);
}
},
_teardownInstance: function () {
if (this._instance) {
var c = this._instance._children;
if (c) {
var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
c.forEach(function (n) {
parent.removeChild(n);
});
}
this._instance = null;
}
},
_wrapTextNodes: function (root) {
for (var n = root.firstChild; n; n = n.nextSibling) {
if (n.nodeType === Node.TEXT_NODE && n.textContent.trim()) {
var s = document.createElement('span');
root.insertBefore(s, n);
s.appendChild(n);
n = s;
}
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance.notifyPath(path, value, true);
}
}
});
Polymer.ImportStatus = {
_ready: false,
_callbacks: [],
whenLoaded: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_importsLoaded: function () {
this._ready = true;
this._callbacks.forEach(function (cb) {
cb();
});
this._callbacks = [];
}
};
window.addEventListener('load', function () {
Polymer.ImportStatus._importsLoaded();
});
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.ImportStatus._importsLoaded();
});
}
Polymer({
is: 'dom-bind',
extends: 'template',
created: function () {
Polymer.ImportStatus.whenLoaded(this._readySelf.bind(this));
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
this._setupConfigure = this._setupConfigure.bind(this, config);
},
attached: function () {
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
Polymer.Base._initFeatures.call(this);
this._children = Array.prototype.slice.call(this.root.childNodes);
}
this._insertChildren();
this.fire('dom-change');
},
detached: function () {
this._removeChildren();
}
});</script>


<script>

  (function() {

    // monostate data
    var metaDatas = {};
    var metaArrays = {};

    Polymer.IronMeta = Polymer({

      is: 'iron-meta',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * The key used to store `value` under the `type` namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          observer: '_valueChanged'
        },

        /**
         * If true, `value` is set to the iron-meta instance itself.
         */
         self: {
          type: Boolean,
          observer: '_selfChanged'
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Only runs if someone invokes the factory/constructor directly
       * e.g. `new Polymer.IronMeta()`
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
              case 'value':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key, old) {
        this._resetRegistration(old);
      },

      _valueChanged: function(value) {
        this._resetRegistration(this.key);
      },

      _selfChanged: function(self) {
        if (self) {
          this.value = this;
        }
      },

      _typeChanged: function(type) {
        this._unregisterKey(this.key);
        if (!metaDatas[type]) {
          metaDatas[type] = {};
        }
        this._metaData = metaDatas[type];
        if (!metaArrays[type]) {
          metaArrays[type] = [];
        }
        this.list = metaArrays[type];
        this._registerKeyValue(this.key, this.value);
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      },

      _resetRegistration: function(oldKey) {
        this._unregisterKey(oldKey);
        this._registerKeyValue(this.key, this.value);
      },

      _unregisterKey: function(key) {
        this._unregister(key, this._metaData, this.list);
      },

      _registerKeyValue: function(key, value) {
        this._register(key, value, this._metaData, this.list);
      },

      _register: function(key, value, data, list) {
        if (key && data && value !== undefined) {
          data[key] = value;
          list.push(value);
        }
      },

      _unregister: function(key, data, list) {
        if (key && data) {
          if (key in data) {
            var value = data[key];
            delete data[key];
            this.arrayDelete(list, value);
          }
        }
      }

    });

    /**
    `iron-meta-query` can be used to access infomation stored in `iron-meta`.

    Examples:

    If I create an instance like this:

        <iron-meta key="info" value="foo/bar"></iron-meta>

    Note that value="foo/bar" is the metadata I've defined. I could define more
    attributes or use child nodes to define additional metadata.

    Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

         var value = new Polymer.IronMetaQuery({key: 'info'}).value;

    @group Polymer Iron Elements
    @element iron-meta-query
    */
    Polymer.IronMetaQuery = Polymer({

      is: 'iron-meta-query',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * Specifies a key to use for retrieving `value` from the `type`
         * namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Actually a factory method, not a true constructor. Only runs if
       * someone invokes it directly (via `new Polymer.IronMeta()`);
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key) {
        this._setValue(this._metaData && this._metaData[key]);
      },

      _typeChanged: function(type) {
        this._metaData = metaDatas[type];
        this.list = metaArrays[type];
        if (this.key) {
          this._keyChanged(this.key);
        }
      },

      /**
       * Retrieves meta data value by key.
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      }

    });

  })();
</script>
<style is="custom-style">

  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: around;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      /* @apply(--layout-center --layout-center-justified); */
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    /* fixed position */

    --layout-fixed-bottom:,
    --layout-fixed-left:,
    --layout-fixed-right:,
    --layout-fixed-top: {
      position: fixed;
    };

    --layout-fixed-top: {
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>


<script>
  /**
   * The `iron-iconset-svg` element allows users to define their own icon sets
   * that contain svg icons. The svg icon elements should be children of the
   * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
   *
   * Using svg elements to create icons has a few advantages over traditional
   * bitmap graphics like jpg or png. Icons that use svg are vector based so they
   * are resolution independent and should look good on any device. They are
   * stylable via css. Icons can be themed, colorized, and even animated.
   *
   * Example:
   *
   *     <iron-iconset-svg name="my-svg-icons" size="24">
   *       <svg>
   *         <defs>
   *           <g id="shape">
   *             <rect x="50" y="50" width="50" height="50" />
   *             <circle cx="50" cy="50" r="50" />
   *           </g>
   *         </defs>
   *       </svg>
   *     </iron-iconset-svg>
   *
   * This will automatically register the icon set "my-svg-icons" to the iconset
   * database.  To use these icons from within another element, make a
   * `iron-iconset` element and call the `byId` method
   * to retrieve a given iconset. To apply a particular icon inside an
   * element use the `applyIcon` method. For example:
   *
   *     iconset.applyIcon(iconNode, 'car');
   *
   * @element iron-iconset-svg
   * @demo demo/index.html
   */
  Polymer({

    is: 'iron-iconset-svg',

    properties: {

      /**
       * The name of the iconset.
       *
       * @attribute name
       * @type string
       */
      name: {
        type: String,
        observer: '_nameChanged'
      },

      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * @attribute iconSize
       * @type number
       * @default 24
       */
      size: {
        type: Number,
        value: 24
      }

    },

    /**
     * Construct an array of all icon names in this iconset.
     *
     * @return {!Array} Array of icon names.
     */
    getIconNames: function() {
      this._icons = this._createIconMap();
      return Object.keys(this._icons).map(function(n) {
        return this.name + ':' + n;
      }, this);
    },

    /**
     * Applies an icon to the given element.
     *
     * An svg icon is prepended to the element's shadowRoot if it exists,
     * otherwise to the element itself.
     *
     * @method applyIcon
     * @param {Element} element Element to which the icon is applied.
     * @param {string} iconName Name of the icon to apply.
     * @return {Element} The svg element which renders the icon.
     */
    applyIcon: function(element, iconName) {
      // insert svg element into shadow root, if it exists
      element = element.root || element;
      // Remove old svg element
      this.removeIcon(element);
      // install new svg element
      var svg = this._cloneIcon(iconName);
      if (svg) {
        var pde = Polymer.dom(element);
        pde.insertBefore(svg, pde.childNodes[0]);
        return element._svgIcon = svg;
      }
      return null;
    },

    /**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */
    removeIcon: function(element) {
      // Remove old svg element
      if (element._svgIcon) {
        Polymer.dom(element).removeChild(element._svgIcon);
        element._svgIcon = null;
      }
    },

    /**
     *
     * When name is changed, register iconset metadata
     *
     */
    _nameChanged: function() {
      new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
    },

    /**
     * Create a map of child SVG elements by id.
     *
     * @return {!Object} Map of id's to SVG elements.
     */
    _createIconMap: function() {
      // Objects chained to Object.prototype (`{}`) have members. Specifically,
      // on FF there is a `watch` method that confuses the icon map, so we
      // need to use a null-based object here.
      var icons = Object.create(null);
      Polymer.dom(this).querySelectorAll('[id]')
        .forEach(function(icon) {
          icons[icon.id] = icon;
        });
      return icons;
    },

    /**
     * Produce installable clone of the SVG element matching `id` in this
     * iconset, or `undefined` if there is no matching element.
     *
     * @return {Element} Returns an installable clone of the SVG element
     * matching `id`.
     */
    _cloneIcon: function(id) {
      // create the icon map on-demand, since the iconset itself has no discrete
      // signal to know when it's children are fully parsed
      this._icons = this._icons || this._createIconMap();
      return this._prepareSvgClone(this._icons[id], this.size);
    },

    /**
     * @param {Element} sourceSvg
     * @param {number} size
     * @return {Element}
     */
    _prepareSvgClone: function(sourceSvg, size) {
      if (sourceSvg) {
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', ['0', '0', size, size].join(' '));
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
        // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
        svg.style.cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
        svg.appendChild(sourceSvg.cloneNode(true)).removeAttribute('id');
        return svg;
      }
      return null;
    }

  });
</script>
<script>
  /**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that control the
   * size or hidden state of their children) and "resizables" (elements that need to be
   * notified when they are resized or un-hidden by their parents in order to take
   * action on their new measurements).
   * Elements that perform measurement should add the `IronResizableBehavior` behavior to
   * their element definition and listen for the `iron-resize` event on themselves.
   * This event will be fired when they become showing after having been hidden,
   * when they are resized explicitly by another resizable, or when the window has been
   * resized.
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/
  Polymer.IronResizableBehavior = {
    properties: {
      /**
       * The closest ancestor element that implements `IronResizableBehavior`.
       */
      _parentResizable: {
        type: Object,
        observer: '_parentResizableChanged'
      },

      /**
       * True if this element is currently notifying its descedant elements of
       * resize.
       */
      _notifyingDescendant: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
    },

    created: function() {
      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
    },

    attached: function() {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    },

    detached: function() {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    },

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize: function() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach(function(resizable) {
        if (this.resizerShouldNotify(resizable)) {
          this._notifyDescendant(resizable);
        }
      }, this);

      this._fireResize();
    },

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable: function(parentResizable) {
      this._parentResizable = parentResizable;
    },

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor: function(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
        this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
      }
    },

    /**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `IronResizableBehavior`.
     * @return {boolean} True if the `element` should be notified of resize.
     */
    resizerShouldNotify: function(element) { return true; },

    _onDescendantIronResize: function(event) {
      if (this._notifyingDescendant) {
        event.stopPropagation();
        return;
      }

      // NOTE(cdata): In ShadowDOM, event retargetting makes echoing of the
      // otherwise non-bubbling event "just work." We do it manually here for
      // the case where Polymer is not using shadow roots for whatever reason:
      if (!Polymer.Settings.useShadow) {
        this._fireResize();
      }
    },

    _fireResize: function() {
      this.fire('iron-resize', null, {
        node: this,
        bubbles: false
      });
    },

    _onIronRequestResizeNotifications: function(event) {
      var target = event.path ? event.path[0] : event.target;

      if (target === this) {
        return;
      }

      if (this._interestedResizables.indexOf(target) === -1) {
        this._interestedResizables.push(target);
        this.listen(target, 'iron-resize', '_onDescendantIronResize');
      }

      target.assignParentResizable(this);
      this._notifyDescendant(target);

      event.stopPropagation();
    },

    _parentResizableChanged: function(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    },

    _notifyDescendant: function(descendant) {
      // NOTE(cdata): In IE10, attached is fired on children first, so it's
      // important not to notify them if the parent is not attached yet (or
      // else they will get redundantly notified when the parent attaches).
      if (!this.isAttached) {
        return;
      }

      this._notifyingDescendant = true;
      descendant.notifyResize();
      this._notifyingDescendant = false;
    }
  };
</script>

<script>

  /**
   * @param {!Function} selectCallback
   * @constructor
   */
  Polymer.IronSelection = function(selectCallback) {
    this.selection = [];
    this.selectCallback = selectCallback;
  };

  Polymer.IronSelection.prototype = {

    /**
     * Retrieves the selected item(s).
     *
     * @method get
     * @returns Returns the selected item(s). If the multi property is true,
     * `get` will return an array, otherwise it will return
     * the selected item or undefined if there is no selection.
     */
    get: function() {
      return this.multi ? this.selection : this.selection[0];
    },

    /**
     * Clears all the selection except the ones indicated.
     *
     * @method clear
     * @param {Array} excludes items to be excluded.
     */
    clear: function(excludes) {
      this.selection.slice().forEach(function(item) {
        if (!excludes || excludes.indexOf(item) < 0) {
          this.setItemSelected(item, false);
        }
      }, this);
    },

    /**
     * Indicates if a given item is selected.
     *
     * @method isSelected
     * @param {*} item The item whose selection state should be checked.
     * @returns Returns true if `item` is selected.
     */
    isSelected: function(item) {
      return this.selection.indexOf(item) >= 0;
    },

    /**
     * Sets the selection state for a given item to either selected or deselected.
     *
     * @method setItemSelected
     * @param {*} item The item to select.
     * @param {boolean} isSelected True for selected, false for deselected.
     */
    setItemSelected: function(item, isSelected) {
      if (item != null) {
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    },

    /**
     * Sets the selection state for a given item. If the `multi` property
     * is true, then the selected state of `item` will be toggled; otherwise
     * the `item` will be selected.
     *
     * @method select
     * @param {*} item The item to select.
     */
    select: function(item) {
      if (this.multi) {
        this.toggle(item);
      } else if (this.get() !== item) {
        this.setItemSelected(this.get(), false);
        this.setItemSelected(item, true);
      }
    },

    /**
     * Toggles the selection state for `item`.
     *
     * @method toggle
     * @param {*} item The item to toggle.
     */
    toggle: function(item) {
      this.setItemSelected(item, !this.isSelected(item));
    }

  };

</script>
<script>

  /** @polymerBehavior */
  Polymer.IronSelectableBehavior = {

    properties: {

      /**
       * If you want to use the attribute value of an element for `selected` instead of the index,
       * set this to the name of the attribute.
       *
       * @attribute attrForSelected
       * @type {string}
       */
      attrForSelected: {
        type: String,
        value: null
      },

      /**
       * Gets or sets the selected element. The default is to use the index of the item.
       *
       * @attribute selected
       * @type {string}
       */
      selected: {
        type: String,
        notify: true
      },

      /**
       * Returns the currently selected item.
       *
       * @attribute selectedItem
       * @type {Object}
       */
      selectedItem: {
        type: Object,
        readOnly: true,
        notify: true
      },

      /**
       * The event that fires from items when they are selected. Selectable
       * will listen for this event from items and update the selection state.
       * Set to empty string to listen to no events.
       *
       * @attribute activateEvent
       * @type {string}
       * @default 'tap'
       */
      activateEvent: {
        type: String,
        value: 'tap',
        observer: '_activateEventChanged'
      },

      /**
       * This is a CSS selector sting.  If this is set, only items that matches the CSS selector
       * are selectable.
       *
       * @attribute selectable
       * @type {string}
       */
      selectable: String,

      /**
       * The class to set on elements when selected.
       *
       * @attribute selectedClass
       * @type {string}
       */
      selectedClass: {
        type: String,
        value: 'iron-selected'
      },

      /**
       * The attribute to set on elements when selected.
       *
       * @attribute selectedAttribute
       * @type {string}
       */
      selectedAttribute: {
        type: String,
        value: null
      }

    },

    observers: [
      '_updateSelected(attrForSelected, selected)'
    ],

    excludedLocalNames: {
      'template': 1
    },

    created: function() {
      this._bindFilterItem = this._filterItem.bind(this);
      this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
    },

    attached: function() {
      this._observer = this._observeItems(this);
      this._contentObserver = this._observeContent(this);
    },

    detached: function() {
      if (this._observer) {
        this._observer.disconnect();
      }
      if (this._contentObserver) {
        this._contentObserver.disconnect();
      }
      this._removeListener(this.activateEvent);
    },

    /**
     * Returns an array of selectable items.
     *
     * @property items
     * @type Array
     */
    get items() {
      var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      return Array.prototype.filter.call(nodes, this._bindFilterItem);
    },

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @returns Returns the index of the item
     */
    indexOf: function(item) {
      return this.items.indexOf(item);
    },

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      this.selected = value;
    },

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious: function() {
      var length = this.items.length;
      var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      this.selected = this._indexToValue(index);
    },

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext: function() {
      var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      this.selected = this._indexToValue(index);
    },

    _addListener: function(eventName) {
      this.listen(this, eventName, '_activateHandler');
    },

    _removeListener: function(eventName) {
      // There is no unlisten yet...
      // https://github.com/Polymer/polymer/issues/1639
      //this.removeEventListener(eventName, this._bindActivateHandler);
    },

    _activateEventChanged: function(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    },

    _updateSelected: function() {
      this._selectSelected(this.selected);
    },

    _selectSelected: function(selected) {
      this._selection.select(this._valueToItem(this.selected));
    },

    _filterItem: function(node) {
      return !this.excludedLocalNames[node.localName];
    },

    _valueToItem: function(value) {
      return (value == null) ? null : this.items[this._valueToIndex(value)];
    },

    _valueToIndex: function(value) {
      if (this.attrForSelected) {
        for (var i = 0, item; item = this.items[i]; i++) {
          if (this._valueForItem(item) == value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    },

    _indexToValue: function(index) {
      if (this.attrForSelected) {
        var item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    },

    _valueForItem: function(item) {
      return item[this.attrForSelected] || item.getAttribute(this.attrForSelected);
    },

    _applySelection: function(item, isSelected) {
      if (this.selectedClass) {
        this.toggleClass(this.selectedClass, isSelected, item);
      }
      if (this.selectedAttribute) {
        this.toggleAttribute(this.selectedAttribute, isSelected, item);
      }
      this._selectionChange();
      this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});
    },

    _selectionChange: function() {
      this._setSelectedItem(this._selection.get());
    },

    // observe content changes under the given node.
    _observeContent: function(node) {
      var content = node.querySelector('content');
      if (content && content.parentElement === node) {
        return this._observeItems(node.domHost);
      }
    },

    // observe items change under the given node.
    _observeItems: function(node) {
      var observer = new MutationObserver(function() {
        if (this.selected != null) {
          this._updateSelected();
        }
      }.bind(this));
      observer.observe(node, {
        childList: true,
        subtree: true
      });
      return observer;
    },

    _activateHandler: function(e) {
      // TODO: remove this when https://github.com/Polymer/polymer/issues/1639 is fixed so we
      // can just remove the old event listener.
      if (e.type !== this.activateEvent) {
        return;
      }
      var t = e.target;
      var items = this.items;
      while (t && t != this) {
        var i = items.indexOf(t);
        if (i >= 0) {
          var value = this._indexToValue(i);
          this._itemActivate(value, t);
          return;
        }
        t = t.parentNode;
      }
    },

    _itemActivate: function(value, item) {
      if (!this.fire('iron-activate',
          {selected: value, item: item}, {cancelable: true}).defaultPrevented) {
        this.select(value);
      }
    }

  };

</script>


<script>
  /** @polymerBehavior Polymer.IronMultiSelectableBehavior */
  Polymer.IronMultiSelectableBehaviorImpl = {
    properties: {

      /**
       * If true, multiple selections are allowed.
       */
      multi: {
        type: Boolean,
        value: false,
        observer: 'multiChanged'
      },

      /**
       * Gets or sets the selected elements. This is used instead of `selected` when `multi`
       * is true.
       */
      selectedValues: {
        type: Array,
        notify: true
      },

      /**
       * Returns an array of currently selected items.
       */
      selectedItems: {
        type: Array,
        readOnly: true,
        notify: true
      },

    },

    observers: [
      '_updateSelected(attrForSelected, selectedValues)'
    ],

    /**
     * Selects the given value. If the `multi` property is true, then the selected state of the
     * `value` will be toggled; otherwise the `value` will be selected.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      if (this.multi) {
        if (this.selectedValues) {
          this._toggleSelected(value);
        } else {
          this.selectedValues = [value];
        }
      } else {
        this.selected = value;
      }
    },

    multiChanged: function(multi) {
      this._selection.multi = multi;
    },

    _updateSelected: function() {
      if (this.multi) {
        this._selectMulti(this.selectedValues);
      } else {
        this._selectSelected(this.selected);
      }
    },

    _selectMulti: function(values) {
      this._selection.clear();
      if (values) {
        for (var i = 0; i < values.length; i++) {
          this._selection.setItemSelected(this._valueToItem(values[i]), true);
        }
      }
    },

    _selectionChange: function() {
      var s = this._selection.get();
      if (this.multi) {
        this._setSelectedItems(s);
      } else {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      }
    },

    _toggleSelected: function(value) {
      var i = this.selectedValues.indexOf(value);
      var unselected = i < 0;
      if (unselected) {
        this.selectedValues.push(value);
      } else {
        this.selectedValues.splice(i, 1);
      }
      this._selection.setItemSelected(this._valueToItem(value), unselected);
    }
  };

  /** @polymerBehavior */
  Polymer.IronMultiSelectableBehavior = [
    Polymer.IronSelectableBehavior,
    Polymer.IronMultiSelectableBehaviorImpl
  ];

</script>
<script>
  /**
  `iron-selector` is an element which can be used to manage a list of elements
  that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
  which item is being selected.  The default is to use the index of the item.

  Example:

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  If you want to use the attribute value of an element for `selected` instead of the index,
  set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
  `name`, set `attrForSelected` to `name`.

  Example:

      <iron-selector attr-for-selected="name" selected="foo">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="zot">Zot</div>
      </iron-selector>

  `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.

  Example:

      <style>
        .iron-selected {
          background: #eee;
        }
      </style>

      ...

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  @demo demo/index.html
  */

  Polymer({

    is: 'iron-selector',

    behaviors: [
      Polymer.IronMultiSelectableBehavior
    ]

  });

</script>



<script>

  Polymer({

    is: 'iron-media-query',

    properties: {

      /**
       * The Boolean return value of the media query.
       */
      queryMatches: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * The CSS media query to evaluate.
       */
      query: {
        type: String,
        observer: 'queryChanged'
      }

    },

    created: function() {
      this._mqHandler = this.queryHandler.bind(this);
    },

    queryChanged: function(query) {
      if (this._mq) {
        this._mq.removeListener(this._mqHandler);
      }
      if (query[0] !== '(') {
        query = '(' + query + ')';
      }
      this._mq = window.matchMedia(query);
      this._mq.addListener(this._mqHandler);
      this.queryHandler(this._mq);
    },

    queryHandler: function(mq) {
      this._setQueryMatches(mq.matches);
    }

  });

</script>




<style is="custom-style">

  :root {

    --dark-primary-color: #303f9f;

    --default-primary-color: #3f51b5;

    --light-primary-color: #c5cae9;

    --text-primary-color: #ffffff;

    --accent-color: #ff4081;

    --primary-background-color: #ffffff;

    --primary-text-color: #212121;

    --secondary-text-color: #757575;

    --disabled-text-color: #bdbdbd;

    --divider-color: #e0e0e0;

  }

</style>
<script>
  (function() {
    'use strict';

    /**
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+002A': '*',
      'U+0030': '0',
      'U+0031': '1',
      'U+0032': '2',
      'U+0033': '3',
      'U+0034': '4',
      'U+0035': '5',
      'U+0036': '6',
      'U+0037': '7',
      'U+0038': '8',
      'U+0039': '9',
      'U+0041': 'a',
      'U+0042': 'b',
      'U+0043': 'c',
      'U+0044': 'd',
      'U+0045': 'e',
      'U+0046': 'f',
      'U+0047': 'g',
      'U+0048': 'h',
      'U+0049': 'i',
      'U+004A': 'j',
      'U+004B': 'k',
      'U+004C': 'l',
      'U+004D': 'm',
      'U+004E': 'n',
      'U+004F': 'o',
      'U+0050': 'p',
      'U+0051': 'q',
      'U+0052': 'r',
      'U+0053': 's',
      'U+0054': 't',
      'U+0055': 'u',
      'U+0056': 'v',
      'U+0057': 'w',
      'U+0058': 'x',
      'U+0059': 'y',
      'U+005A': 'z',
      'U+007F': 'del'
    };

    /**
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
     * than that.
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /**
     * MODIFIER_KEYS maps the short name for modifier keys used in a key
     * combo string to the property name that references those same keys
     * in a KeyboardEvent instance.
     */
    var MODIFIER_KEYS = {
      'shift': 'shiftKey',
      'ctrl': 'ctrlKey',
      'alt': 'altKey',
      'meta': 'metaKey'
    };

    /**
     * KeyboardEvent.key is mostly represented by printable character made by
     * the keyboard, with unprintable keys labeled nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an
     * Apple-specific mapping. In this case, we
     * fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    /**
     * Matches a keyIdentifier string.
     */
    var IDENT_CHAR = /U\+/;

    /**
     * Matches arrow keys in Gecko 27.0+
     */
    var ARROW_KEY = /^arrow/;

    /**
     * Matches space keys everywhere (notably including IE10's exceptional name
     * `spacebar`).
     */
    var SPACE_KEY = /^space(bar)?/;

    function transformKey(key) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey.length == 1) {
          if (KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (ARROW_KEY.test(lKey)) {
          validKey = lKey.replace('arrow', '');
        } else if (SPACE_KEY.test(lKey)) {
          validKey = 'space';
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (IDENT_CHAR.test(keyIdent)) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(48 - keyCode);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(96 - keyCode);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    function normalizedKeyForEvent(keyEvent) {
      // fall back from .key, to .keyIdentifier, to .keyCode, and then to
      // .detail.key to support artificial keyboard events
      return transformKey(keyEvent.key) ||
        transformKeyIdentifier(keyEvent.keyIdentifier) ||
        transformKeyCode(keyEvent.keyCode) ||
        transformKey(keyEvent.detail.key) || '';
    }

    function keyComboMatchesEvent(keyCombo, keyEvent) {
      return normalizedKeyForEvent(keyEvent) === keyCombo.key &&
        !!keyEvent.shiftKey === !!keyCombo.shiftKey &&
        !!keyEvent.ctrlKey === !!keyCombo.ctrlKey &&
        !!keyEvent.altKey === !!keyCombo.altKey &&
        !!keyEvent.metaKey === !!keyCombo.metaKey;
    }

    function parseKeyComboString(keyComboString) {
      return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {
        combo: keyComboString.split(':').shift()
      });
    }

    function parseEventString(eventString) {
      return eventString.split(' ').map(function(keyComboString) {
        return parseKeyComboString(keyComboString);
      });
    }


    /**
     * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
     * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
     * The element takes care of browser differences with respect to Keyboard events
     * and uses an expressive syntax to filter key presses.
     *
     * Use the `keyBindings` prototype property to express what combination of keys
     * will trigger the event to fire.
     *
     * Use the `key-event-target` attribute to set up event handlers on a specific
     * node.
     * The `keys-pressed` event will fire when one of the key combinations set with the
     * `keys` property is pressed.
     *
     * @demo demo/index.html
     * @polymerBehavior IronA11yKeysBehavior
     */
    Polymer.IronA11yKeysBehavior = {
      properties: {
        /**
         * The HTMLElement that will be firing relevant KeyboardEvents.
         */
        keyEventTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        _boundKeyHandlers: {
          type: Array,
          value: function() {
            return [];
          }
        },

        // We use this due to a limitation in IE10 where instances will have
        // own properties of everything on the "prototype".
        _imperativeKeyBindings: {
          type: Object,
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
      ],

      keyBindings: {},

      registered: function() {
        this._prepKeyBindings();
      },

      attached: function() {
        this._listenKeyEventListeners();
      },

      detached: function() {
        this._unlistenKeyEventListeners();
      },

      /**
       * Can be used to imperatively add a key binding to the implementing
       * element. This is the imperative equivalent of declaring a keybinding
       * in the `keyBindings` prototype property.
       */
      addOwnKeyBinding: function(eventString, handlerName) {
        this._imperativeKeyBindings[eventString] = handlerName;
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * When called, will remove all imperatively-added key bindings.
       */
      removeOwnKeyBindings: function() {
        this._imperativeKeyBindings = {};
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      keyboardEventMatchesKeys: function(event, eventString) {
        var keyCombos = parseEventString(eventString);
        var index;

        for (index = 0; index < keyCombos.length; ++index) {
          if (keyComboMatchesEvent(keyCombos[index], event)) {
            return true;
          }
        }

        return false;
      },

      _collectKeyBindings: function() {
        var keyBindings = this.behaviors.map(function(behavior) {
          return behavior.keyBindings;
        });

        if (keyBindings.indexOf(this.keyBindings) === -1) {
          keyBindings.push(this.keyBindings);
        }

        return keyBindings;
      },

      _prepKeyBindings: function() {
        this._keyBindings = {};

        this._collectKeyBindings().forEach(function(keyBindings) {
          for (var eventString in keyBindings) {
            this._addKeyBinding(eventString, keyBindings[eventString]);
          }
        }, this);

        for (var eventString in this._imperativeKeyBindings) {
          this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
        }
      },

      _addKeyBinding: function(eventString, handlerName) {
        parseEventString(eventString).forEach(function(keyCombo) {
          this._keyBindings[keyCombo.event] =
            this._keyBindings[keyCombo.event] || [];

          this._keyBindings[keyCombo.event].push([
            keyCombo,
            handlerName
          ]);
        }, this);
      },

      _resetKeyEventListeners: function() {
        this._unlistenKeyEventListeners();

        if (this.isAttached) {
          this._listenKeyEventListeners();
        }
      },

      _listenKeyEventListeners: function() {
        Object.keys(this._keyBindings).forEach(function(eventName) {
          var keyBindings = this._keyBindings[eventName];
          var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

          this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

          this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
        }, this);
      },

      _unlistenKeyEventListeners: function() {
        var keyHandlerTuple;
        var keyEventTarget;
        var eventName;
        var boundKeyHandler;

        while (this._boundKeyHandlers.length) {
          // My kingdom for block-scope binding and destructuring assignment..
          keyHandlerTuple = this._boundKeyHandlers.pop();
          keyEventTarget = keyHandlerTuple[0];
          eventName = keyHandlerTuple[1];
          boundKeyHandler = keyHandlerTuple[2];

          keyEventTarget.removeEventListener(eventName, boundKeyHandler);
        }
      },

      _onKeyBindingEvent: function(keyBindings, event) {
        keyBindings.forEach(function(keyBinding) {
          var keyCombo = keyBinding[0];
          var handlerName = keyBinding[1];

          if (!event.defaultPrevented && keyComboMatchesEvent(keyCombo, event)) {
            this._triggerKeyHandler(keyCombo, handlerName, event);
          }
        }, this);
      },

      _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
        var detail = Object.create(keyCombo);
        detail.keyboardEvent = keyboardEvent;

        this[handlerName].call(this, new CustomEvent(keyCombo.event, {
          detail: detail
        }));
      }
    };
  })();
</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      },

      _boundFocusBlurHandler: {
        type: Function,
        value: function() {
          return this._focusBlurHandler.bind(this);
        }
      }

    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    ready: function() {
      // TODO(sjmiles): ensure read-only property is valued so the compound
      // observer will fire
      if (this.focused === undefined) {
        this._setFocused(false);
      }
      this.addEventListener('focus', this._boundFocusBlurHandler, true);
      this.addEventListener('blur', this._boundFocusBlurHandler, true);
    },

    _focusBlurHandler: function(event) {
      var target = event.path ? event.path[0] : event.target;
      if (target === this) {
        var focused = event.type === 'focus';
        this._setFocused(focused);
      } else if (!this.shadowRoot) {
        event.stopPropagation();
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this.focused = false;
        this.tabIndex = -1;
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: '_activeChanged'
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_detectKeyboardFocus(focused)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      this.active = active;
      this.fire('change');
    },

    _downHandler: function() {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    _spaceKeyUpHandler: function() {
      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _activeChanged: function(active) {
      if (this.toggles) {
        this.setAttribute('aria-pressed', active ? 'true' : 'false');
      } else {
        this.removeAttribute('aria-pressed');
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script>
<script>

  /** @polymerBehavior */
  Polymer.PaperButtonBehaviorImpl = {

    properties: {

      _elevation: {
        type: Number
      }

    },

    observers: [
      '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)'
    ],

    hostAttributes: {
      role: 'button',
      tabindex: '0'
    },

    _calculateElevation: function() {
      var e = 1;
      if (this.disabled) {
        e = 0;
      } else if (this.active || this.pressed) {
        e = 4;
      } else if (this.receivedFocusFromKeyboard) {
        e = 3;
      }
      this._elevation = e;
    }
  };

  /** @polymerBehavior */
  Polymer.PaperButtonBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperButtonBehaviorImpl
  ];

</script>
<script>

  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {

    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (!this.$.ink) {
        return;
      }

      this.$.ink.holdDown = receivedFocusFromKeyboard;
    }

  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperInkyFocusBehaviorImpl
  ];

</script>




<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #ff5722;
    --paper-deep-orange-100: #fbe9e7;
    --paper-deep-orange-200: #ffccbc;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.26; /* or hint text */
    --dark-secondary-opacity: 0.54; /* or icon */
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text */
    --light-secondary-opacity: 0.7; /* or icon */
    --light-primary-opacity: 1.0;

  }

</style>
<style is="custom-style">

  :root {

    --shadow-transition: {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    };

    --shadow-none: {
      box-shadow: none;
    };

    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

    --shadow-elevation-2dp: {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    };

    --shadow-elevation-3dp: {
      box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                  0 1px 8px 0 rgba(0, 0, 0, 0.12),
                  0 3px 3px -2px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-4dp: {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-6dp: {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-8dp: {
      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                  0 3px 14px 2px rgba(0, 0, 0, 0.12),
                  0 5px 5px -3px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-16dp: {
      box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                  0  6px 30px 5px rgba(0, 0, 0, 0.12),
                  0  8px 10px -5px rgba(0, 0, 0, 0.4);
    };

  }

</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
<style is="custom-style">

  :root {

    /* Shared Styles */

    /*
    Unfortunately, we can't use nested rules
    See https://github.com/Polymer/polymer/issues/1399
    */
    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };

    /* Material Font Styles */

    --paper-font-display4: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style>




<script>

  /**
   * `Polymer.IronMenuBehavior` implements accessible menu behavior.
   *
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronMenuBehavior
   */
  Polymer.IronMenuBehaviorImpl = {

    properties: {

      /**
       * Returns the currently focused item.
       *
       * @attribute focusedItem
       * @type Object
       */
      focusedItem: {
        observer: '_focusedItemChanged',
        readOnly: true,
        type: Object
      },

      /**
       * The attribute to use on menu items to look up the item title. Typing the first
       * letter of an item when the menu is open focuses that item. If unset, `textContent`
       * will be used.
       *
       * @attribute attrForItemTitle
       * @type String
       */
      attrForItemTitle: {
        type: String
      }
    },

    hostAttributes: {
      'role': 'menu',
      'tabindex': '0'
    },

    observers: [
      '_updateMultiselectable(multi)'
    ],

    listeners: {
      'focus': '_onFocus',
      'keydown': '_onKeydown'
    },

    keyBindings: {
      'up': '_onUpKey',
      'down': '_onDownKey',
      'esc': '_onEscKey',
      'enter': '_onEnterKey',
      'shift+tab:keydown': '_onShiftTabDown'
    },

    _updateMultiselectable: function(multi) {
      if (multi) {
        this.setAttribute('aria-multiselectable', 'true');
      } else {
        this.removeAttribute('aria-multiselectable');
      }
    },

    _onShiftTabDown: function() {
      var oldTabIndex;

      Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;

      oldTabIndex = this.getAttribute('tabindex');

      this.setAttribute('tabindex', '-1');

      this.async(function() {
        this.setAttribute('tabindex', oldTabIndex);
        Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
      // Note: polymer/polymer#1305
      }, 1);
    },

    _applySelection: function(item, isSelected) {
      if (isSelected) {
        item.setAttribute('aria-selected', 'true');
      } else {
        item.removeAttribute('aria-selected');
      }

      Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
    },

    _focusedItemChanged: function(focusedItem, old) {
      old && old.setAttribute('tabindex', '-1');
      if (focusedItem) {
        focusedItem.setAttribute('tabindex', '0');
        focusedItem.focus();
      }
    },

    select: function(value) {
      if (this._defaultFocusAsync) {
        this.cancelAsync(this._defaultFocusAsync);
        this._defaultFocusAsync = null;
      }
      var item = this._valueToItem(value);
      this._setFocusedItem(item);
      Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
    },

    _onFocus: function(event) {
      if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
        return;
      }
      // do not focus the menu itself
      this.blur();
      // clear the cached focus item
      this._setFocusedItem(null);
      this._defaultFocusAsync = this.async(function() {
        // focus the selected item when the menu receives focus, or the first item
        // if no item is selected
        var selectedItem = this.multi ? (this.selectedItems && this.selectedItems[0]) : this.selectedItem;
        if (selectedItem) {
          this._setFocusedItem(selectedItem);
        } else {
          this._setFocusedItem(this.items[0]);
        }
      // async 100ms to wait for `select` to get called from `_itemActivate`
      }, 100);
    },

    _onUpKey: function() {
      // up and down arrows moves the focus
      this._focusPrevious();
    },

    _onDownKey: function() {
      this._focusNext();
    },

    _onEscKey: function() {
      // esc blurs the control
      this.focusedItem.blur();
    },

    _onEnterKey: function(event) {
      // enter activates the item unless it is disabled
      this._activateFocused(event.detail.keyboardEvent);
    },

    _onKeydown: function(event) {
      if (this.keyboardEventMatchesKeys(event, 'up down esc enter')) {
        return;
      }

      // all other keys focus the menu item starting with that character
      this._focusWithKeyboardEvent(event);
    },

    _focusWithKeyboardEvent: function(event) {
      for (var i = 0, item; item = this.items[i]; i++) {
        var attr = this.attrForItemTitle || 'textContent';
        var title = item[attr] || item.getAttribute(attr);
        if (title && title.trim().charAt(0).toLowerCase() === String.fromCharCode(event.keyCode).toLowerCase()) {
          this._setFocusedItem(item);
          break;
        }
      }
    },

    _activateFocused: function(event) {
      if (!this.focusedItem.hasAttribute('disabled')) {
        this._activateHandler(event);
      }
    },

    _focusPrevious: function() {
      var length = this.items.length;
      var index = (Number(this.indexOf(this.focusedItem)) - 1 + length) % length;
      this._setFocusedItem(this.items[index]);
    },

    _focusNext: function() {
      var index = (Number(this.indexOf(this.focusedItem)) + 1) % this.items.length;
      this._setFocusedItem(this.items[index]);
    }

  };

  Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;

  /** @polymerBehavior Polymer.IronMenuBehavior */
  Polymer.IronMenuBehavior = [
    Polymer.IronMultiSelectableBehavior,
    Polymer.IronA11yKeysBehavior,
    Polymer.IronMenuBehaviorImpl
  ];

</script>



<style>

.paper-font-display4,
.paper-font-display3,
.paper-font-display2,
.paper-font-display1,
.paper-font-headline,
.paper-font-title,
.paper-font-subhead,
.paper-font-body2,
.paper-font-body1,
.paper-font-caption,
.paper-font-menu,
.paper-font-button {
  font-family: 'Roboto', 'Noto', sans-serif;
  -webkit-font-smoothing: antialiased;  /* OS X subpixel AA bleed bug */
}

.paper-font-code2,
.paper-font-code1 {
  font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
  -webkit-font-smoothing: antialiased;  /* OS X subpixel AA bleed bug */
}

/* Opt for better kerning for headers & other short labels. */
.paper-font-display4,
.paper-font-display3,
.paper-font-display2,
.paper-font-display1,
.paper-font-headline,
.paper-font-title,
.paper-font-subhead,
.paper-font-menu,
.paper-font-button {
  text-rendering: optimizeLegibility;
}

/*
"Line wrapping only applies to Body, Subhead, Headline, and the smaller Display
styles. All other styles should exist as single lines."
*/
.paper-font-display4,
.paper-font-display3,
.paper-font-title,
.paper-font-caption,
.paper-font-menu,
.paper-font-button {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.paper-font-display4 {
  font-size: 112px;
  font-weight: 300;
  letter-spacing: -.044em;
  line-height: 120px;
}

.paper-font-display3 {
  font-size: 56px;
  font-weight: 400;
  letter-spacing: -.026em;
  line-height: 60px;
}

.paper-font-display2 {
  font-size: 45px;
  font-weight: 400;
  letter-spacing: -.018em;
  line-height: 48px;
}

.paper-font-display1 {
  font-size: 34px;
  font-weight: 400;
  letter-spacing: -.01em;
  line-height: 40px;
}

.paper-font-headline {
  font-size: 24px;
  font-weight: 400;
  letter-spacing: -.012em;
  line-height: 32px;
}

.paper-font-title {
  font-size: 20px;
  font-weight: 500;
  line-height: 28px;
}

.paper-font-subhead {
  font-size: 16px;
  font-weight: 400;
  line-height: 24px;
}

.paper-font-body2 {
  font-size: 14px;
  font-weight: 500;
  line-height: 24px;
}

.paper-font-body1 {
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
}

.paper-font-caption {
  font-size: 12px;
  font-weight: 400;
  letter-spacing: 0.011em;
  line-height: 20px;
}

.paper-font-menu {
  font-size: 13px;
  font-weight: 500;
  line-height: 24px;
}

.paper-font-button {
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.018em;
  line-height: 24px;
  text-transform: uppercase;
}

.paper-font-code2 {
  font-size: 14px;
  font-weight: 700;
  line-height: 20px;
}

.paper-font-code1 {
  font-size: 14px;
  font-weight: 700;
  line-height: 20px;
}

</style>
<style>
.shadow-transition {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
}

.shadow-elevation-2dp {
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
              0 1px 5px 0 rgba(0, 0, 0, 0.12),
              0 3px 1px -2px rgba(0, 0, 0, 0.2);
}

.shadow-elevation-3dp {
  box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
              0 1px 8px 0 rgba(0, 0, 0, 0.12),
              0 3px 3px -2px rgba(0, 0, 0, 0.4);
}

.shadow-elevation-4dp {
  box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
              0 1px 10px 0 rgba(0, 0, 0, 0.12),
              0 2px 4px -1px rgba(0, 0, 0, 0.4);
}

.shadow-elevation-6dp {
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
              0 1px 18px 0 rgba(0, 0, 0, 0.12),
              0 3px 5px -1px rgba(0, 0, 0, 0.4);
}

.shadow-elevation-8dp {
  box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
              0 3px 14px 2px rgba(0, 0, 0, 0.12),
              0 5px 5px -3px rgba(0, 0, 0, 0.4);
}

.shadow-elevation-16dp {
  box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
              0  6px 30px 5px rgba(0, 0, 0, 0.12),
              0  8px 10px -5px rgba(0, 0, 0, 0.4);
}

</style>





<script>

 /** 
 * `iron-range-behavior` provides the behavior for something with a minimum to maximum range.
 *
 * @demo demo/index.html
 * @polymerBehavior 
 */
 Polymer.IronRangeBehavior = {

  properties: {

    /**
     * The number that represents the current value.
     */
    value: {
      type: Number,
      value: 0,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The number that indicates the minimum value of the range.
     */
    min: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * The number that indicates the maximum value of the range.
     */
    max: {
      type: Number,
      value: 100,
      notify: true
    },

    /**
     * Specifies the value granularity of the range's value.
     */
    step: {
      type: Number,
      value: 1,
      notify: true
    },

    /**
     * Returns the ratio of the value.
     */
    ratio: {
      type: Number,
      value: 0,
      readOnly: true,
      notify: true
    },
  },

  observers: [
    '_update(value, min, max, step)'
  ],

  _calcRatio: function(value) {
    return (this._clampValue(value) - this.min) / (this.max - this.min);
  },

  _clampValue: function(value) {
    return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
  },

  _calcStep: function(value) {
   /**
    * if we calculate the step using
    * `Math.round(value / step) * step` we may hit a precision point issue 
    * eg. 0.1 * 0.2 =  0.020000000000000004
    * http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
    *
    * as a work around we can divide by the reciprocal of `step`
    */
    return this.step ? (Math.round(value / this.step) / (1 / this.step)) : value;
  },

  _validateValue: function() {
    var v = this._clampValue(this.value);
    this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
    return this.value !== v;
  },

  _update: function() {
    this._validateValue();
    this._setRatio(this._calcRatio(this.value) * 100);
  }

};
</script>



<script>(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.XP = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function cleanUpNextTick(){draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue()}function drainQueue(){if(!draining){var e=setTimeout(cleanUpNextTick);draining=!0;for(var n=queue.length;n;){for(currentQueue=queue,queue=[];++queueIndex<n;)currentQueue[queueIndex].run();queueIndex=-1,n=queue.length}currentQueue=null,draining=!1,clearTimeout(e)}}function Item(e,n){this.fun=e,this.array=n}function noop(){}var process=module.exports={},queue=[],draining=!1,currentQueue,queueIndex=-1;process.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];queue.push(new Item(e,n)),1!==queue.length||draining||setTimeout(drainQueue,0)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};
},{}],2:[function(require,module,exports){
(function (global){
!function(e){function o(e){throw RangeError(T[e])}function n(e,o){for(var n=e.length,r=[];n--;)r[n]=o(e[n]);return r}function r(e,o){var r=e.split("@"),t="";r.length>1&&(t=r[0]+"@",e=r[1]),e=e.replace(S,".");var u=e.split("."),i=n(u,o).join(".");return t+i}function t(e){for(var o,n,r=[],t=0,u=e.length;u>t;)o=e.charCodeAt(t++),o>=55296&&56319>=o&&u>t?(n=e.charCodeAt(t++),56320==(64512&n)?r.push(((1023&o)<<10)+(1023&n)+65536):(r.push(o),t--)):r.push(o);return r}function u(e){return n(e,function(e){var o="";return e>65535&&(e-=65536,o+=P(e>>>10&1023|55296),e=56320|1023&e),o+=P(e)}).join("")}function i(e){return 10>e-48?e-22:26>e-65?e-65:26>e-97?e-97:b}function f(e,o){return e+22+75*(26>e)-((0!=o)<<5)}function c(e,o,n){var r=0;for(e=n?M(e/j):e>>1,e+=M(e/o);e>L*C>>1;r+=b)e=M(e/L);return M(r+(L+1)*e/(e+m))}function l(e){var n,r,t,f,l,s,d,a,p,h,v=[],g=e.length,w=0,m=I,j=A;for(r=e.lastIndexOf(E),0>r&&(r=0),t=0;r>t;++t)e.charCodeAt(t)>=128&&o("not-basic"),v.push(e.charCodeAt(t));for(f=r>0?r+1:0;g>f;){for(l=w,s=1,d=b;f>=g&&o("invalid-input"),a=i(e.charCodeAt(f++)),(a>=b||a>M((x-w)/s))&&o("overflow"),w+=a*s,p=j>=d?y:d>=j+C?C:d-j,!(p>a);d+=b)h=b-p,s>M(x/h)&&o("overflow"),s*=h;n=v.length+1,j=c(w-l,n,0==l),M(w/n)>x-m&&o("overflow"),m+=M(w/n),w%=n,v.splice(w++,0,m)}return u(v)}function s(e){var n,r,u,i,l,s,d,a,p,h,v,g,w,m,j,F=[];for(e=t(e),g=e.length,n=I,r=0,l=A,s=0;g>s;++s)v=e[s],128>v&&F.push(P(v));for(u=i=F.length,i&&F.push(E);g>u;){for(d=x,s=0;g>s;++s)v=e[s],v>=n&&d>v&&(d=v);for(w=u+1,d-n>M((x-r)/w)&&o("overflow"),r+=(d-n)*w,n=d,s=0;g>s;++s)if(v=e[s],n>v&&++r>x&&o("overflow"),v==n){for(a=r,p=b;h=l>=p?y:p>=l+C?C:p-l,!(h>a);p+=b)j=a-h,m=b-h,F.push(P(f(h+j%m,0))),a=M(j/m);F.push(P(f(a,0))),l=c(r,w,u==i),r=0,++u}++r,++n}return F.join("")}function d(e){return r(e,function(e){return F.test(e)?l(e.slice(4).toLowerCase()):e})}function a(e){return r(e,function(e){return O.test(e)?"xn--"+s(e):e})}var p="object"==typeof exports&&exports&&!exports.nodeType&&exports,h="object"==typeof module&&module&&!module.nodeType&&module,v="object"==typeof global&&global;(v.global===v||v.window===v||v.self===v)&&(e=v);var g,w,x=2147483647,b=36,y=1,C=26,m=38,j=700,A=72,I=128,E="-",F=/^xn--/,O=/[^\x20-\x7E]/,S=/[\x2E\u3002\uFF0E\uFF61]/g,T={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},L=b-y,M=Math.floor,P=String.fromCharCode;if(g={version:"1.3.2",ucs2:{decode:t,encode:u},decode:l,encode:s,toASCII:a,toUnicode:d},"function"==typeof define&&"object"==typeof define.amd&&define.amd)define("punycode",function(){return g});else if(p&&h)if(module.exports==p)h.exports=g;else for(w in g)g.hasOwnProperty(w)&&(p[w]=g[w]);else e.punycode=g}(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
"use strict";function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}module.exports=function(r,e,t,n){e=e||"&",t=t||"=";var o={};if("string"!=typeof r||0===r.length)return o;var a=/\+/g;r=r.split(e);var s=1e3;n&&"number"==typeof n.maxKeys&&(s=n.maxKeys);var p=r.length;s>0&&p>s&&(p=s);for(var y=0;p>y;++y){var u,c,i,l,f=r[y].replace(a,"%20"),v=f.indexOf(t);v>=0?(u=f.substr(0,v),c=f.substr(v+1)):(u=f,c=""),i=decodeURIComponent(u),l=decodeURIComponent(c),hasOwnProperty(o,i)?isArray(o[i])?o[i].push(l):o[i]=[o[i],l]:o[i]=l}return o};var isArray=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)};
},{}],4:[function(require,module,exports){
"use strict";function map(r,e){if(r.map)return r.map(e);for(var t=[],n=0;n<r.length;n++)t.push(e(r[n],n));return t}var stringifyPrimitive=function(r){switch(typeof r){case"string":return r;case"boolean":return r?"true":"false";case"number":return isFinite(r)?r:"";default:return""}};module.exports=function(r,e,t,n){return e=e||"&",t=t||"=",null===r&&(r=void 0),"object"==typeof r?map(objectKeys(r),function(n){var i=encodeURIComponent(stringifyPrimitive(n))+t;return isArray(r[n])?map(r[n],function(r){return i+encodeURIComponent(stringifyPrimitive(r))}).join(e):i+encodeURIComponent(stringifyPrimitive(r[n]))}).join(e):n?encodeURIComponent(stringifyPrimitive(n))+t+encodeURIComponent(stringifyPrimitive(r)):""};var isArray=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)},objectKeys=Object.keys||function(r){var e=[];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&e.push(t);return e};
},{}],5:[function(require,module,exports){
"use strict";exports.decode=exports.parse=require("./decode"),exports.encode=exports.stringify=require("./encode");
},{"./decode":3,"./encode":4}],6:[function(require,module,exports){
function Url(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function urlParse(t,s,e){if(t&&isObject(t)&&t instanceof Url)return t;var h=new Url;return h.parse(t,s,e),h}function urlFormat(t){return isString(t)&&(t=urlParse(t)),t instanceof Url?t.format():Url.prototype.format.call(t)}function urlResolve(t,s){return urlParse(t,!1,!0).resolve(s)}function urlResolveObject(t,s){return t?urlParse(t,!1,!0).resolveObject(s):s}function isString(t){return"string"==typeof t}function isObject(t){return"object"==typeof t&&null!==t}function isNull(t){return null===t}function isNullOrUndefined(t){return null==t}var punycode=require("punycode");exports.parse=urlParse,exports.resolve=urlResolve,exports.resolveObject=urlResolveObject,exports.format=urlFormat,exports.Url=Url;var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,delims=["<",">",'"',"`"," ","\r","\n","	"],unwise=["{","}","|","\\","^","`"].concat(delims),autoEscape=["'"].concat(unwise),nonHostChars=["%","/","?",";","#"].concat(autoEscape),hostEndingChars=["/","?","#"],hostnameMaxLen=255,hostnamePartPattern=/^[a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([a-z0-9A-Z_-]{0,63})(.*)$/,unsafeProtocol={javascript:!0,"javascript:":!0},hostlessProtocol={javascript:!0,"javascript:":!0},slashedProtocol={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},querystring=require("querystring");Url.prototype.parse=function(t,s,e){if(!isString(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var h=t;h=h.trim();var r=protocolPattern.exec(h);if(r){r=r[0];var o=r.toLowerCase();this.protocol=o,h=h.substr(r.length)}if(e||r||h.match(/^\/\/[^@\/]+@[^@\/]+/)){var a="//"===h.substr(0,2);!a||r&&hostlessProtocol[r]||(h=h.substr(2),this.slashes=!0)}if(!hostlessProtocol[r]&&(a||r&&!slashedProtocol[r])){for(var n=-1,i=0;i<hostEndingChars.length;i++){var l=h.indexOf(hostEndingChars[i]);-1!==l&&(-1===n||n>l)&&(n=l)}var c,u;u=-1===n?h.lastIndexOf("@"):h.lastIndexOf("@",n),-1!==u&&(c=h.slice(0,u),h=h.slice(u+1),this.auth=decodeURIComponent(c)),n=-1;for(var i=0;i<nonHostChars.length;i++){var l=h.indexOf(nonHostChars[i]);-1!==l&&(-1===n||n>l)&&(n=l)}-1===n&&(n=h.length),this.host=h.slice(0,n),h=h.slice(n),this.parseHost(),this.hostname=this.hostname||"";var p="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!p)for(var f=this.hostname.split(/\./),i=0,m=f.length;m>i;i++){var v=f[i];if(v&&!v.match(hostnamePartPattern)){for(var g="",y=0,d=v.length;d>y;y++)g+=v.charCodeAt(y)>127?"x":v[y];if(!g.match(hostnamePartPattern)){var P=f.slice(0,i),b=f.slice(i+1),j=v.match(hostnamePartStart);j&&(P.push(j[1]),b.unshift(j[2])),b.length&&(h="/"+b.join(".")+h),this.hostname=P.join(".");break}}}if(this.hostname.length>hostnameMaxLen?this.hostname="":this.hostname=this.hostname.toLowerCase(),!p){for(var O=this.hostname.split("."),q=[],i=0;i<O.length;++i){var x=O[i];q.push(x.match(/[^A-Za-z0-9_-]/)?"xn--"+punycode.encode(x):x)}this.hostname=q.join(".")}var U=this.port?":"+this.port:"",C=this.hostname||"";this.host=C+U,this.href+=this.host,p&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==h[0]&&(h="/"+h))}if(!unsafeProtocol[o])for(var i=0,m=autoEscape.length;m>i;i++){var A=autoEscape[i],E=encodeURIComponent(A);E===A&&(E=escape(A)),h=h.split(A).join(E)}var w=h.indexOf("#");-1!==w&&(this.hash=h.substr(w),h=h.slice(0,w));var R=h.indexOf("?");if(-1!==R?(this.search=h.substr(R),this.query=h.substr(R+1),s&&(this.query=querystring.parse(this.query)),h=h.slice(0,R)):s&&(this.search="",this.query={}),h&&(this.pathname=h),slashedProtocol[o]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var U=this.pathname||"",x=this.search||"";this.path=U+x}return this.href=this.format(),this},Url.prototype.format=function(){var t=this.auth||"";t&&(t=encodeURIComponent(t),t=t.replace(/%3A/i,":"),t+="@");var s=this.protocol||"",e=this.pathname||"",h=this.hash||"",r=!1,o="";this.host?r=t+this.host:this.hostname&&(r=t+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(r+=":"+this.port)),this.query&&isObject(this.query)&&Object.keys(this.query).length&&(o=querystring.stringify(this.query));var a=this.search||o&&"?"+o||"";return s&&":"!==s.substr(-1)&&(s+=":"),this.slashes||(!s||slashedProtocol[s])&&r!==!1?(r="//"+(r||""),e&&"/"!==e.charAt(0)&&(e="/"+e)):r||(r=""),h&&"#"!==h.charAt(0)&&(h="#"+h),a&&"?"!==a.charAt(0)&&(a="?"+a),e=e.replace(/[?#]/g,function(t){return encodeURIComponent(t)}),a=a.replace("#","%23"),s+r+e+a+h},Url.prototype.resolve=function(t){return this.resolveObject(urlParse(t,!1,!0)).format()},Url.prototype.resolveObject=function(t){if(isString(t)){var s=new Url;s.parse(t,!1,!0),t=s}var e=new Url;if(Object.keys(this).forEach(function(t){e[t]=this[t]},this),e.hash=t.hash,""===t.href)return e.href=e.format(),e;if(t.slashes&&!t.protocol)return Object.keys(t).forEach(function(s){"protocol"!==s&&(e[s]=t[s])}),slashedProtocol[e.protocol]&&e.hostname&&!e.pathname&&(e.path=e.pathname="/"),e.href=e.format(),e;if(t.protocol&&t.protocol!==e.protocol){if(!slashedProtocol[t.protocol])return Object.keys(t).forEach(function(s){e[s]=t[s]}),e.href=e.format(),e;if(e.protocol=t.protocol,t.host||hostlessProtocol[t.protocol])e.pathname=t.pathname;else{for(var h=(t.pathname||"").split("/");h.length&&!(t.host=h.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==h[0]&&h.unshift(""),h.length<2&&h.unshift(""),e.pathname=h.join("/")}if(e.search=t.search,e.query=t.query,e.host=t.host||"",e.auth=t.auth,e.hostname=t.hostname||t.host,e.port=t.port,e.pathname||e.search){var r=e.pathname||"",o=e.search||"";e.path=r+o}return e.slashes=e.slashes||t.slashes,e.href=e.format(),e}var a=e.pathname&&"/"===e.pathname.charAt(0),n=t.host||t.pathname&&"/"===t.pathname.charAt(0),i=n||a||e.host&&t.pathname,l=i,c=e.pathname&&e.pathname.split("/")||[],h=t.pathname&&t.pathname.split("/")||[],u=e.protocol&&!slashedProtocol[e.protocol];if(u&&(e.hostname="",e.port=null,e.host&&(""===c[0]?c[0]=e.host:c.unshift(e.host)),e.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===h[0]?h[0]=t.host:h.unshift(t.host)),t.host=null),i=i&&(""===h[0]||""===c[0])),n)e.host=t.host||""===t.host?t.host:e.host,e.hostname=t.hostname||""===t.hostname?t.hostname:e.hostname,e.search=t.search,e.query=t.query,c=h;else if(h.length)c||(c=[]),c.pop(),c=c.concat(h),e.search=t.search,e.query=t.query;else if(!isNullOrUndefined(t.search)){if(u){e.hostname=e.host=c.shift();var p=e.host&&e.host.indexOf("@")>0?e.host.split("@"):!1;p&&(e.auth=p.shift(),e.host=e.hostname=p.shift())}return e.search=t.search,e.query=t.query,isNull(e.pathname)&&isNull(e.search)||(e.path=(e.pathname?e.pathname:"")+(e.search?e.search:"")),e.href=e.format(),e}if(!c.length)return e.pathname=null,e.search?e.path="/"+e.search:e.path=null,e.href=e.format(),e;for(var f=c.slice(-1)[0],m=(e.host||t.host)&&("."===f||".."===f)||""===f,v=0,g=c.length;g>=0;g--)f=c[g],"."==f?c.splice(g,1):".."===f?(c.splice(g,1),v++):v&&(c.splice(g,1),v--);if(!i&&!l)for(;v--;v)c.unshift("..");!i||""===c[0]||c[0]&&"/"===c[0].charAt(0)||c.unshift(""),m&&"/"!==c.join("/").substr(-1)&&c.push("");var y=""===c[0]||c[0]&&"/"===c[0].charAt(0);if(u){e.hostname=e.host=y?"":c.length?c.shift():"";var p=e.host&&e.host.indexOf("@")>0?e.host.split("@"):!1;p&&(e.auth=p.shift(),e.host=e.hostname=p.shift())}return i=i||e.host&&c.length,i&&!y&&c.unshift(""),c.length?e.pathname=c.join("/"):(e.pathname=null,e.path=null),isNull(e.pathname)&&isNull(e.search)||(e.path=(e.pathname?e.pathname:"")+(e.search?e.search:"")),e.auth=t.auth||e.auth,e.slashes=e.slashes||t.slashes,e.href=e.format(),e},Url.prototype.parseHost=function(){var t=this.host,s=portPattern.exec(t);s&&(s=s[0],":"!==s&&(this.port=s.substr(1)),t=t.substr(0,t.length-s.length)),t&&(this.hostname=t)};
},{"punycode":2,"querystring":5}],7:[function(require,module,exports){
(function (global){
!function(global,browser){"use strict";var AbstractError,AlreadyDefinedError,AlreadyUsedError,ArgumentError,Class,CustomError,Deferred,DeniedError,InvalidError,NotFoundError,Promise,RejectedError,RequiredError,UnavailableError,UndefinedError,ValidationError,addAttribute,addAttributes,addClass,after,alignElement,and,append,appendChild,apply,ary,assert,assertArgument,assertOption,assign,at,attempt,before,call,camelCase,camelCaseRegex,capitalize,capitalizeRegex,chunk,clean,clone,cloneDeep,compact,concat,countBy,createElement,createElementNS,debounce,deburr,defaults,defineProperties,defineProperty,delay,difference,drop,dropRight,dropRightWhile,dropWhile,endsWith,escape,escapeRegExp,every,fileExtension,fileName,filter,filterElements,find,findDeep,findElement,findElements,findIndex,findKey,findLast,findLastElement,findLastIndex,findLastKey,findNextElement,findNextElements,findParentElement,findPreviousElement,findPreviousElements,findSiblingElement,findSiblingElements,first,fit,fixed,flatten,flattenDeep,flush,forEach,forEachRight,forIn,forInRight,forOwn,forOwnRight,freeze,functions,getAllNext,getAllNextElements,getAllPrevious,getAllPreviousElements,getAllSiblingElements,getAllSiblings,getAttribute,getAttributes,getBoundings,getChildren,getDistributedElement,getDistributedElements,getElement,getElementById,getElements,getHTML,getHeight,getMargin,getNext,getNextElement,getNode,getNodes,getPadding,getParentElement,getPrevious,getPreviousElement,getSiblingElements,getSiblings,getStyle,getStyles,getTag,getText,getValue,getWidth,groupBy,has,hasAttribute,hasChild,hasClass,includes,includesDeep,indexBy,indexOf,initial,intersection,invert,invoke,isAny,isArguments,isArray,isArrayable,isBase62,isBindable,isBoolean,isBrowser,isCamelCase,isCapitalize,isClean,isCollection,isContent,isCustomEvent,isDate,isDefined,isElement,isEmpty,isEnumerable,isEqual,isEquivalent,isError,isEscape,isEscapeRegExp,isEven,isEvent,isExotic,isFalse,isFinite,isFloat,isFunction,isHex,isIndex,isInfinite,isInstance,isInt,isInvalid,isKebabCase,isKeyCase,isLast,isLastIndex,isLowerCase,isNaN,isNative,isNegative,isNode,isNull,isNullable,isNumber,isNumeric,isObject,isObservable,isOdd,isPlainObject,isPolyfilled,isPositive,isPredicate,isPrevented,isPrimitive,isReadable,isRegExp,isSelector,isShady,isSnakeCase,isStartCase,isString,isTemplate,isTrue,isUniq,isUpperCase,isVoid,isWithin,iterate,kebabCase,kebabCaseRegex,keyCase,keyCaseRegex,keys,keysIn,last,lastIndexOf,listen,localize,lowerCase,lowerCaseRegex,map,mapOne,mapValues,match,matches,max,memoize,merge,min,mock,moveFirst,moveLast,nand,negate,nor,not,omit,onMutation,once,or,overwrite,pad,padLeft,padRight,pairs,parallel,parseBase62,parseHex,parseJSON,parseURL,partition,pick,pluck,prefix,prependChild,preventDefault,pull,pullAt,push,random,range,readable,readableRegex,redirect,reduce,reduceRight,reject,remove,removeAttribute,removeAttributes,removeChild,removeClass,removeStyle,removeStyles,renameElement,repeat,replaceNode,requestAnimationFrame,rest,round,sample,seal,setAttribute,setAttributes,setChildren,setHTML,setStyle,setStyles,setText,shrink,shuffle,size,slice,snakeCase,snakeCaseRegex,some,sortBy,split,startCase,startCaseRegex,startsWith,stop,stopPropagation,stretch,strip,suffix,take,takeRight,takeRightWhile,takeWhile,throttle,toArray,toBase62,toBoolean,toDOMIdentity,toDOMPredicate,toElapsedTime,toHex,toIndex,toInfinite,toInput,toInt,toJSON,toNumber,toObject,toPosition,toQueryString,toRegExp,toString,toTemplate,toURL,toUseful,toValue,toggleAttribute,toggleClass,trim,trimLeft,trimRegex,trimRight,trunc,unescape,union,uniq,unlisten,unzip,updateElement,upperCase,upperCaseRegex,value,valueIn,values,valuesIn,waterfall,where,willBleedBottom,willBleedHorizontally,willBleedLeft,willBleedRight,willBleedTop,willBleedVertically,withdraw,within,without,words,wrap,xnor,xor,zip,zipObject,exp=module.exports,lodash=require("lodash"),q=require("q"),url=require("url");exp.AbstractError=AbstractError=function(e){CustomError.call(this,"AbstractError",e,"is abstract and should be implemented first")},exp.AlreadyDefinedError=AlreadyDefinedError=function(e){CustomError.call(this,"AlreadyDefinedError",e,"is already defined")},exp.AlreadyUsedError=AlreadyUsedError=function(e){CustomError.call(this,"AlreadyUsedError",e,"is already used")},exp.ArgumentError=ArgumentError=function(e,t){CustomError.call(this,"ArgumentError",(toPosition(e)||"Unknown")+" argument","must be "+t)},exp.Class=Class=function Class(name,opt){assertArgument(isString(name,!0),1,"string"),assertArgument(isVoid(opt)||isObject(opt),2,"Object"),opt=opt||{};var Constructor=null,Super=withdraw(opt,"extends")||Function,initialize=withdraw(opt,"initialize")||Super,options=withdraw(opt,"options");return eval("Constructor = function "+name+"() {    var self = this, promised = self.promise;    self.options = self.options || Constructor.options;    self.plugins = self.plugins || {};    self.promise = self.promise || (initialize.promise ? new Promise(arguments, initialize.value, self) : null);    return initialize !== Function && (promised || !initialize.promise) ? initialize.apply(self, arguments) : self;};"),Constructor.prototype=Object.create(Super.prototype,{constructor:{configurable:!0,value:Constructor,writable:!0}}),defineProperties(Constructor,{options:{"static":!0,value:assign({},Super.options,options)}}),defineProperties(Constructor,{addPlugin:function(e,t){assertArgument(isString(e,!0),1,"string"),assertArgument(isFunction(t),2,"Function");var r=this;return push(r.plugins[e]=r.plugins[e]||[],t),r},getPlugins:function(e){return assertArgument(isString(e,!0),1,"string"),this.plugins?this.plugins[e]||[]:[]},invokePlugins:function(e,t,r){assertArgument(isString(e,!0),1,"string"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),assertArgument(isVoid(r)||isFunction(r),3,"Function");var n=this,i=function(e){e.apply(void 0,concat([null],t,[n]))};return waterfall(concat([i],n.getPlugins(e)),r),n},removePlugin:function(e,t){assertArgument(isString(e,!0),1,"string"),assertArgument(isFunction(t),2,"Function");var r=this;return pull(r.getPlugins(e),t),r},removePlugins:function(e){assertArgument(isString(e,!0),1,"string");var t=this;return flush(t.getPlugins(e)),t},rejected:function(e){return assertArgument(isFunction(e),1,"Function"),assign(this,this.promise?{promise:this.promise["catch"](function(t){throw e(t),t})}:{})},resolved:function(e){return assertArgument(isFunction(e),1,"Function"),assign(this,this.promise?{promise:this.promise.then(function(t){return e(t),t})}:{})},options:{set:function(e){return assign(this.options||{},e)},then:function(e){var t=this;forOwn(e.plugins||{},function(r,n){t.addPlugin(n,r),delete e.plugins[n]})}},plugins:{set:function(e){return assign(this.plugins||{},e)}},promise:{enumerable:!1,validate:function(e){return isObject(e)||isVoid(e)}},resolver:{validate:function(e){return isFunction(e)||isVoid(e)}}}),defineProperties(Constructor,opt),Constructor},exp.CustomError=CustomError=function(e,t,r){var n=Error.call(this,t+(r?" "+r:""));n.name=e,this.message=n.message,this.stack=n.stack},exp.Deferred=Deferred=function(){return q.defer()},exp.DeniedError=DeniedError=function(e){CustomError.call(this,"DeniedError",e,"is denied")},exp.InvalidError=InvalidError=function(e){CustomError.call(this,"InvalidError",e,"is not valid")},exp.NotFoundError=NotFoundError=function(e){CustomError.call(this,"NotFoundError",e,"is not found")},exp.Promise=Promise=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isFunction(t),2,"Function"),assertArgument(isBindable(r),3,"Array, Function or Object");var n,i,s,o=new Deferred,a=o.promise;if(isArray(e=fit(e,t.length),!0)){for(s=e.length-1,i=s;i>=0;i-=1)if(isFunction(e[i])){for(n=e[i];s>i;i+=1)e[i]=void 0;break}e[s]=function(e,t){o[e?"reject":"resolve"](e||t)}}return t.apply(r,e),n&&(a=a.then(function(e){return n(null,e),e})),n&&(a=a["catch"](function(e){throw n(e,null),e})),a},exp.RejectedError=RejectedError=function(e){CustomError.call(this,"RejectedError",e,"is rejected")},exp.RequiredError=RequiredError=function(e){CustomError.call(this,"RequiredError",e,"is required")},exp.UnavailableError=UnavailableError=function(e){CustomError.call(this,"UnavailableError",e,"is not available")},exp.UndefinedError=UndefinedError=function(e){CustomError.call(this,"UndefinedError",e,"is not defined")},exp.ValidationError=ValidationError=function(e,t){CustomError.call(this,"ValidationError",e,"must be "+t)},exp.addAttribute=addAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.setAttribute(t,""),e},exp.addAttributes=addAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||!isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){addAttribute(e,t)}),e},exp.addClass=addClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.classList.add(t),e},exp.after=after=function(e,t){return assertArgument(isIndex(e),1,"number"),assertArgument(isFunction(t),2,"Function"),lodash.after(e,t)},exp.alignElement=alignElement=function(e,t,r,n){if(assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isElement(t),2,"Element"),assertArgument(isVoid(r)||isString(r),3,"string"),e){setStyles(e,{position:"fixed",bottom:null,left:0,right:null,top:0});var i,s=getHeight(),o=getWidth(),a=getMargin(e),u=getBoundings(e),l=getBoundings(t||global.document.documentElement);return u.left=l.left+("aside"===r?l.width:n||!t?l.width/2-u.width/2:0)-a.left,u.top=l.top+("baseline"===r?l.height:t?0:l.height/2-u.height/2)-a.top,willBleedRight(u,a)&&(u.left="aside"===r?u.left-(l.width+u.width):o-(a.left+u.width+a.right)),willBleedLeft(u,a)&&(u.left="aside"!==r||willBleedHorizontally(u,a)?0:o-(a.left+u.width+a.right)),willBleedBottom(u,a)&&(u.top=s-(a.top+u.height+a.bottom)),willBleedTop(u,a)&&(u.top=0),setStyles(e,{left:u.left+"px",right:willBleedRight(u,a)?"0px":null}),setStyles(e,{top:u.top+"px",bottom:willBleedBottom(u,a)?"0px":null}),i=getBoundings(e),(i.left-=a.left)!==u.left&&setStyles(e,{left:2*u.left-i.left+"px",right:willBleedRight(u,a)?u.left-i.left+"px":null}),(i.top-=a.top)!==u.top&&setStyles(e,{top:2*u.top-i.top+"px",bottom:willBleedBottom(u,a)?u.top-i.top+"px":null}),e}},exp.and=and=function(e,t){return Boolean(e&&t)},exp.append=append=function(e,t){return assertArgument(isString(e)||isArray(e),1,"Array or string"),includes(e,t)?isString(e)?e:t:push(e,t)},exp.appendChild=appendChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t?e.appendChild(t):void 0},exp.apply=apply=function(e,t,r){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t,!0),2,"string"),assertArgument(isVoid(r)||isArrayable(r),3,"Arrayable"),isFunction(e[t])?e[t].apply(e,toArray(r)||[]):void 0},exp.ary=ary=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.ary(e,t)},exp.assert=assert=function(e,t){return!e&&isFunction(t)?t():void 0},exp.assertArgument=assertArgument=function(e,t,r){assert(e,function(){throw new ArgumentError(t,r)})},exp.assertOption=assertOption=function(e,t,r){assert(e,function(){throw new ValidationError(t,r)})},exp.assign=assign=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.assign.apply(lodash,filter(arguments,ary(isObject,1)))},exp.at=at=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(t=toArray(t),2,"Arrayable"),lodash.at(e,t)},exp.attempt=attempt=function(e,t){function r(){var e=slice(arguments);delay(function(){n.apply(void 0,e)})}assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var n=t||mock();try{e(r)}catch(i){n(i,null)}},exp.before=before=function(e,t){return assertArgument(isIndex(e),1,"number"),assertArgument(isFunction(t),2,"Function"),lodash.before(e,t)},exp.call=call=function(e,t,r){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t,!0),2,"string"),isFunction(e[t])?e[t].apply(e,slice(arguments,2)):void 0},exp.camelCase=camelCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.camelCase(lodash.trim(e)):""},exp.camelCaseRegex=camelCaseRegex=/^([a-z]|[\d](?![a-z]))+([A-Z]*([a-z]|[\d](?![a-z]))*)+$|^$/,exp.capitalize=capitalize=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.capitalize(lodash.trim(e)):""},exp.capitalizeRegex=capitalizeRegex=/^[^\sa-z](\S*)$|^$/,exp.chunk=chunk=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.chunk(e,t)},exp.clean=clean=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?trim(e.replace(/[ ]+/g," ")):""},exp.clone=clone=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.clone(e,t,r)},exp.cloneDeep=cloneDeep=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.cloneDeep(e,t,r)},exp.compact=compact=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.compact(e)},exp.concat=concat=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),slice(arguments,1).forEach(function(t){isDefined(t=toArray(t))&&t.forEach(function(t){e.push(t)})}),e},exp.countBy=countBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.countBy(e,t,r)},exp.createElement=createElement=function(e,t){return assertArgument(isString(e,!0),1,"string"),assertArgument(isVoid(t)||isObject(t),2,"Object"),updateElement(global.document.createElement(e),t)},exp.createElementNS=createElementNS=function(e,t,r){return assertArgument(isString(e,!0),1,"string"),assertArgument(isString(t,!0),2,"string"),assertArgument(isVoid(r)||isObject(r),3,"Object"),updateElement(global.document.createElementNS(e,t),r)},exp.debounce=debounce=function(e,t,r){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isObject(r),3,"Object"),lodash.debounce(e,t,r)},exp.deburr=deburr=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.deburr(e):""},exp.defaults=defaults=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.defaults.apply(lodash,filter(arguments,ary(isObject,1)))},exp.defineProperties=defineProperties=function(e,t){return assertArgument(isFunction(e)||isObject(e),1,"Function or Object"),assertArgument(isObject(t),2,"Object"),forOwn(t,function(t,r){defineProperty(e,r,t)}),e},exp.defineProperty=defineProperty=function(e,t,r){assertArgument(isFunction(e)||isObject(e),1,"Function or Object"),assertArgument(isString(t,!0),2,"string"),assertArgument(isFunction(r)||isObject(r),3,"Function or Object"),r=isFunction(r)?{value:r}:r,r.enumerable=value(r,"enumerable",!0);var n=r.value,i=isFunction(r.get),s=isFunction(r.set),o=isFunction(r.validate),a=!i&&!s;return a&&r.promise&&(r.value=function(){return new Promise(arguments,n,this)}),i&&!s&&(r.set=function(e){return e}),!s||i||o||(r.validate=function(){return!0}),isFunction(e)&&!r["static"]&&(e=e.prototype),Object.defineProperty(e,t,assign({configurable:!0,enumerable:r.enumerable},a?{value:value(r,"value"),writable:value(r,"writable",!0)}:{get:i?r.get:function(){return value(this,t+"_")},set:i?r.set:function(e){var n=this,i=t+"_",s=n[i],o=r.set.call(n,e);if(!r.validate.call(n,o))throw new InvalidError(t);has(n,i)?n[i]=o:Object.defineProperty(n,i,{configurable:!0,enumerable:r.enumerable,writable:!0,value:o}),r.sealed&&seal(o),r.frozen&&freeze(o),r.then&&r.then.call(n,o,s)}})),a&&r.sealed&&seal(e[t]),a&&r.frozen&&freeze(e[t]),e},exp.delay=delay=function e(t,r,n){return assertArgument(isFunction(t),1,"Function"),assertArgument(isVoid(r)||isIndex(r),2,"number"),r>0&&!n?lodash.delay(t,r):lodash.defer(function(){r>1?e(t,r-1,n):t()})},exp.difference=difference=function(e,t){return lodash.difference.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.drop=drop=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.drop(e,t)},exp.dropRight=dropRight=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.dropRight(e,t)},exp.dropRightWhile=dropRightWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.dropRightWhile(e,t,r)},exp.dropWhile=dropWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.dropWhile(e,t,r)},exp.endsWith=endsWith=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.endsWith(e,(r||"")+(t||""))},exp.escape=escape=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.escape(e):""},exp.escapeRegExp=escapeRegExp=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.escapeRegExp(e):""},exp.every=every=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.every(e,t,r)},exp.fileExtension=fileExtension=function(e){assertArgument(isVoid(e)||isString(e),1,"string");var t=e?e.lastIndexOf("."):-1;return t>0?e.slice(t+1):""},exp.fileName=fileName=function(e){assertArgument(isVoid(e)||isString(e),1,"string");var t=e?e.lastIndexOf("."):-1;return t>0?e.slice(0,t):""},exp.filter=filter=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.filter(e,t,r)},exp.filterElements=filterElements=function(e,t){var r=toDOMPredicate(t);return assertArgument(isArrayable(e),1,"Arrayable"),assertArgument(r,2,"Function or string"),filter(e,r)},exp.find=find=function(e,t,r){var n=toIndex(t);return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t)||isIndex(n),2,"Function, number, Object or string"),isIndex(n)?e[n]:isPredicate(t)?lodash.find(e,t,r):void 0},exp.findDeep=findDeep=function t(e,r,n){return assertArgument(isCollection(e),1,"Arrayable or Object"),assertArgument(isPredicate(r),2,"Function, Object or string"),assertArgument(isVoid(n)||isString(n),3,"string"),n&&(e=value(e,n)),n&&!isCollection(e)?void 0:find(e,r)||mapOne(e,function(e){return isCollection(e)?t(e,r,n):void 0})},exp.findElement=findElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function, Object or string"),find(filterElements(e.children,r),n)},exp.findElements=findElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(e.children,r),n)},exp.findIndex=findIndex=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string");var n=lodash.findIndex(e,t,r);return isIndex(n)?n:void 0},exp.findKey=findKey=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.findKey(e,t,r)},exp.findLast=findLast=function(e,t,r){var n=toIndex(t);return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t)||isIndex(n),2,"Function, number, Object or string"),isIndex(n)?e[n]:isPredicate(t)?lodash.findLast(e,t,r):void 0},exp.findLastElement=findLastElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function, Object or string"),findLast(filterElements(e.children,r),n)},exp.findLastIndex=findLastIndex=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string");var n=lodash.findLastIndex(e,t,r);return isIndex(n)?n:void 0},exp.findLastKey=findLastKey=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.findLastKey(e,t,r)},exp.findNextElement=findNextElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),find(filterElements(getAllNextElements(e),r),n)},exp.findNextElements=findNextElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(getAllNextElements(e),r),n)},exp.findParentElement=findParentElement=function(e,t,r){if(assertArgument(isNode(e),1,"Node"),assertArgument(isVoid(t)||isSelector(t),2,"string"),assertArgument(isVoid(r)||isNode(r),3,"Node"),e!==r){do e=e.parentNode||e.host;while(e&&(1!==e.nodeType||t&&!matches(e,t))&&e!==r);return!isNode(e,1)||t&&!matches(e,t)?void 0:e}},exp.findPreviousElement=findPreviousElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),findLast(filterElements(getAllPreviousElements(e),r),n)},exp.findPreviousElements=findPreviousElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function or string"),filter(filterElements(getAllPreviousElements(e),r),n)},exp.findSiblingElement=findSiblingElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),findPreviousElement(e,t,r)||findNextElement(e,t,r)},exp.findSiblingElements=findSiblingElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(getAllSiblingElements(e),r),n)},exp.first=first=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.first(e)},exp.fit=fit=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),e.length<t?stretch(e,t,r):shrink(e,t,r)},exp.fixed=fixed=function(e,t){assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isIndex(t),2,"number");var r=round(e,t).toString();return t&&(r=append(r,".")),t&&(r+=repeat("0",t+r.indexOf(".")+1-r.length)),r},exp.flatten=flatten=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.flatten(e)},exp.flattenDeep=flattenDeep=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.flattenDeep(e)},exp.flush=flush=function(e){if(assertArgument(isCollection(e=toArray(e)||e)||isElement(e),1,"Arrayable, Element or Object"),isArray(e)){for(;e.length;)e.pop();return e}return isElement(e)?(e.innerHTML="",e):(isObject(e)&&forOwn(e,function(t,r){delete e[r]}),e)},exp.forEach=forEach=function(e,t,r){return assertArgument(isCollection(e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.forEach(e,t,r)},exp.forEachRight=forEachRight=function(e,t,r){return assertArgument(isCollection(e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.forEachRight(e,t,r)},exp.forIn=forIn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forIn(e,t,r)},exp.forInRight=forInRight=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forInRight(e,t,r)},exp.forOwn=forOwn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forOwn(e,t,r)},exp.forOwnRight=forOwnRight=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forOwn(e,t,r)},exp.freeze=freeze=function(e){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),Object.freeze(e)},exp.functions=functions=function(e){return assertArgument(isObject(e),1,"Object"),lodash.functions(e)},exp.getAllNext=getAllNext=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?slice(e,r+1):[]},exp.getAllNextElements=getAllNextElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllNext(getChildren(getParentElement(e)),e)},exp.getAllPrevious=getAllPrevious=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?slice(e,0,r):[]},exp.getAllPreviousElements=getAllPreviousElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllPrevious(getChildren(getParentElement(e)),e)},exp.getAllSiblingElements=getAllSiblingElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllSiblings(getChildren(getParentElement(e)),e)},exp.getAllSiblings=getAllSiblings=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),concat(getAllPrevious(e,t),getAllNext(e,t))},exp.getAttribute=getAttribute=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.getAttribute(t)},exp.getAttributes=getAttributes=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable");var r={};return forEach(t||[],function(t){r[t]=getAttribute(e,t)}),forEach(t?[]:e.attributes,function(e){r[e.name]=e.value}),r},exp.getBoundings=getBoundings=function(e){assertArgument(isElement(e),1,"Element");var t=e.getBoundingClientRect();return{bottom:t.bottom,height:t.height,left:t.left,right:t.right,top:t.top,width:t.width}},exp.getChildren=getChildren=function(e){return assertArgument(isElement(e),1,"Element"),toArray(e.children)},exp.getDistributedElement=getDistributedElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),find(filterElements(e.getDistributedNodes(),r),n)},exp.getDistributedElements=getDistributedElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function or string"),filter(filterElements(e.getDistributedNodes(),r),n)},exp.getElement=getElement=function(e,t){return isSelector(e)&&(t=e,e=global.document),assertArgument(isElement(e)||isNode(e,9),1,"Element or HTMLDocument"),assertArgument(isVoid(t)||isSelector(t),2,"string"),isSelector(t)?e.querySelector(t)||void 0:isElement(e)?findElement(e,t):findElement(e.body,t)},exp.getElementById=getElementById=function(e,t){return isSelector(e)&&(t=e,e=global.document),assertArgument(isNode(e,9),1,"HTMLDocument"),assertArgument(isString(t,!0),2,"string"),e.getElementById(t)||void 0},exp.getElements=getElements=function(e,t){return isSelector(e)&&(t=e,e=document),assertArgument(isElement(e)||isNode(e,9),1,"Element or HTMLDocument"),assertArgument(isVoid(t)||isSelector(t),2,"string"),isSelector(t)?toArray(e.querySelectorAll(t)):isElement(e)?findElements(e,t):findElements(e.body,t)},exp.getHTML=getHTML=function(e){return assertArgument(isElement(e),1,"Element"),(isTemplate(e)?e.instanceRef_:e).innerHTML},exp.getHeight=getHeight=function(e){return assertArgument(isVoid(e)||isElement(e),1,"Element"),Math.floor(e?getBoundings(e).height:global.innerHeight)},exp.getMargin=getMargin=function(e){assertArgument(isElement(e),1,"Element");var t=["bottom","left","right","top"],r="margin-";return zipObject(t,map(getStyles(e,map(t,function(e){return r+e})),ary(toNumber,1)))},exp.getNext=getNext=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?e[r+1]:void 0},exp.getNextElement=getNextElement=function(e){return assertArgument(isElement(e),1,"Element"),getNext(getChildren(getParentElement(e)),e)},exp.getNode=getNode=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isIndex(t),2,"number"),(isContent(e)?e.getDistributedNodes():e.childNodes)[t]},exp.getNodes=getNodes=function(e){return assertArgument(isElement(e),1,"Element"),toArray(isContent(e)?e.getDistributedNodes():e.childNodes)},exp.getPadding=getPadding=function(e){assertArgument(isElement(e),1,"Element");var t=["bottom","left","right","top"],r="padding-";return zipObject(t,map(getStyles(e,map(t,function(e){return r+e})),ary(toNumber,1)))},exp.getParentElement=getParentElement=function(e){return assertArgument(isNode(e),1,"Node"),e.parentNode},exp.getPrevious=getPrevious=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),e[indexOf(e,t)-1]},exp.getPreviousElement=getPreviousElement=function(e){return assertArgument(isElement(e),1,"Element"),getPrevious(getChildren(getParentElement(e)),e)},exp.getSiblingElements=getSiblingElements=function(e){return assertArgument(isElement(e),1,"Element"),getSiblings(getChildren(getParentElement(e)),e)},exp.getSiblings=getSiblings=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=getPrevious(e,t),n=getNext(e,t);return concat(r?[r]:[],n?[n]:[])},exp.getStyle=getStyle=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),global.getComputedStyle(e)[t]},exp.getStyles=getStyles=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable");var r=global.getComputedStyle(e);return t?pick(r,t):assign({},r)},exp.getTag=getTag=function(e){return assertArgument(isElement(e),1,"Element"),e.tagName.toLowerCase()},exp.getText=getText=function(e){return assertArgument(isNode(e),1,"Node"),isTemplate(e)?"":e.textContent},exp.getValue=getValue=function(e,t){return assertArgument(isElement(e),1,"Element"),e.disabled||!e.name?void 0:"checkbox"===e.type?t&&"on"===e.value?!!e.checked:e.checked?e.value:void 0:"radio"===e.type?e.checked?e.value:void 0:"number"===e.type||"range"===e.type?t?e.value?toNumber(e.value):null:e.value:"file"!==e.type&&isString(e.value)?e.value:void 0},exp.getWidth=getWidth=function(e){return assertArgument(isVoid(e)||isElement(e),1,"Element"),Math.floor(e?getBoundings(e).width:global.innerWidth)},exp.groupBy=groupBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.groupBy(e,t,r)},exp.has=has=function(e,t){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t),2,"string"),lodash.has(e,t)},exp.hasAttribute=hasAttribute=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.hasAttribute(t)},exp.hasChild=hasChild=function(e,t){var r=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(r,2,"Element, Function or string"),!!findElement(e,t)},exp.hasClass=hasClass=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.classList.contains(t)},exp.includes=includes=function(e,t,r){return assertArgument(isString(e)||isCollection(e=toArray(e)||e),1,"Arrayable, Object or string"),assertArgument(isVoid(r)||isFinite(r),3,"number"),lodash.includes(e,t,r)},exp.includesDeep=includesDeep=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),!!findDeep(e,function(e){return e===t})},exp.indexBy=indexBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.indexBy(e,t,r)},exp.indexOf=indexOf=function(e,t,r){
assertArgument(isString(e)||isDefined(e=toArray(e)),1,"Arrayable or string"),assertArgument(isVoid(r)||isFinite(r),3,"number");var n=isArray(e)?lodash.indexOf(e,t,r):isString(t)?e.indexOf(t):-1;return isIndex(n)?n:void 0},exp.initial=initial=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.initial(e)},exp.intersection=intersection=function(e){return lodash.intersection.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.invert=invert=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.invert(e,!!t)},exp.invoke=invoke=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isString(t,!0),2,"Function or string"),lodash.invoke.apply(lodash,concat([e,t],slice(arguments,2)))},exp.isAny=isAny=function(e){return!isNullable(e)},exp.isArguments=isArguments=function(e,t){return lodash.isArguments(e)&&(isVoid(t)||xnor(e.length,t))},exp.isArray=isArray=function(e,t){return lodash.isArray(e)&&(isVoid(t)||xnor(e.length,t))},exp.isArrayable=isArrayable=function(e,t){return!!e&&"object"==typeof e&&isIndex(e.length)&&(isVoid(t)||xnor(e.length,t))},exp.isBase62=isBase62=function(e){return isString(e)&&/^[0-9A-Za-z]+$/.test(e)},exp.isBindable=isBindable=function(e,t){return isArray(e)||isFunction(e)||isObject(e)||!t&&isVoid(e)},exp.isBoolean=isBoolean=function(e){return lodash.isBoolean(e)},exp.isBrowser=isBrowser=function(){return browser},exp.isCamelCase=isCamelCase=function(e,t){return isString(e)&&camelCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isCapitalize=isCapitalize=function(e,t){return isString(e)&&capitalizeRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isClean=isClean=function(e,t){return isString(e)&&e===clean(e)&&(isVoid(t)||xnor(e.length,t))},exp.isCollection=isCollection=function(e,t){return isArrayable(e,t)||isObject(e,t)},exp.isContent=isContent=function(e,t){return isElement(e)&&"content"===(e.node||e).tagName.toLowerCase()?!isVoid(t)&&xor(t,find(e.getDistributedNodes(),function(e){return 1===e.nodeType&&"template"!==e.tagName.toLowerCase()||3!==e.nodeType||trim(e.textContent,"\r\n ")}))?!1:!0:!1},exp.isCustomEvent=isCustomEvent=function(e,t){return isEvent(e,t)&&!!e.detail},exp.isDate=isDate=function(e){return lodash.isDate(e)},exp.isDefined=isDefined=function(e){return void 0!==e},exp.isElement=isElement=function(e,t){return lodash.isElement(e)||isPolyfilled(e)||isShady(e)&&1===e.node.nodeType?!isVoid(t)&&xor(t,find(e.childNodes,function(e){return 1!==e.nodeType||"template"!==e.tagName.toLowerCase()}))?!1:!0:!1},exp.isEmpty=isEmpty=function(e){return isNullable(e)||isArrayable(e,!1)||isElement(e,!1)||isObject(e,!1)},exp.isEnumerable=isEnumerable=function(e,t){return assertArgument(isBindable(t),2,"Array, Function or Object"),isString(e,!0)&&has(t,e)&&t.propertyIsEnumerable(e)},exp.isEqual=isEqual=function(e,t,r,n){return assertArgument(isVoid(r)||isFunction(r),3,"Function"),lodash.isEqual(e,t,r,n)},exp.isEquivalent=isEquivalent=function(e,t){return toJSON(e,!0)===toJSON(t,!0)},exp.isError=isError=function(e){return lodash.isError(e)},exp.isEscape=isEscape=function(e,t){return isString(e)&&e===escape(e)&&(isVoid(t)||xnor(e.length,t))},exp.isEscapeRegExp=isEscapeRegExp=function(e,t){return isString(e)&&e===escapeRegExp(e)&&(isVoid(t)||xnor(e.length,t))},exp.isEven=isEven=function(e,t){return isFinite(e)&&e%2===0&&(isVoid(t)||xnor(e>=0,t))},exp.isEvent=isEvent=function(e,t){return e&&e.type&&e.preventDefault&&e.stopPropagation&&(isVoid(t)||e.type===t)?!0:!1},exp.isExotic=isExotic=function(e){return!isDefined(e)||isNaN(e)||isInfinite(e)},exp.isFalse=isFalse=function(e){return e===!1},exp.isFinite=isFinite=function(e,t){return lodash.isFinite(e)&&(isVoid(t)||xnor(e>=0,t))},exp.isFloat=isFloat=function(e,t){return isFinite(e)&&e%1!==0&&(isVoid(t)||xnor(e>=0,t))},exp.isFunction=isFunction=function(e){return lodash.isFunction(e)},exp.isHex=isHex=function(e){return isString(e)&&/^[0-9A-Fa-f]+$/.test(e)},exp.isIndex=isIndex=function(e){return isInt(e,!0)},exp.isInfinite=isInfinite=function(e){return e===1/0||e===-(1/0)},exp.isInstance=isInstance=function(e,t){return assertArgument(isFunction(t),2,"Function"),e instanceof t},exp.isInt=isInt=function(e,t){return isFinite(e)&&e%1===0&&(isVoid(t)||xnor(e>=0,t))},exp.isInvalid=isInvalid=function(e){return!(!isElement(e)||!e.name||!e.willValidate||!e.checkValidity||e.disabled||e.checkValidity())},exp.isKebabCase=isKebabCase=function(e,t){return isString(e)&&kebabCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isKeyCase=isKeyCase=function(e,t){return isString(e)&&keyCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isLast=isLast=function(e,t){return assertArgument(isArrayable(t),2,"Arrayable"),!!t.length&&e===t[t.length-1]},exp.isLastIndex=isLastIndex=function(e,t){return assertArgument(isArrayable(t),2,"Arrayable"),!!t.length&&e===t.length-1},exp.isLowerCase=isLowerCase=function(e,t){return isString(e)&&lowerCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isNaN=isNaN=function(e){return lodash.isNaN(e)},exp.isNative=isNative=function(e){return lodash.isNative(e)},exp.isNegative=isNegative=function(e){return isNumber(e)&&0>e},exp.isNode=isNode=function(e,t){return e=isShady(e)?e.node:e,e&&(isDefined(e.nodeType)&&isDefined(e.ownerDocument)||isPolyfilled(e))&&(isVoid(t)||e.nodeType===t)?!0:!1},exp.isNull=isNull=function(e){return lodash.isNull(e)},exp.isNullable=isNullable=function(e){return isVoid(e)||isString(e,!1)},exp.isNumber=isNumber=function(e,t){return lodash.isNumber(e)&&!isNaN(e)&&(isVoid(t)||xnor(e>=0,t))},exp.isNumeric=isNumeric=function(e,t){var r=toNumber(e);return isDefined(r)&&(isNumber(e)||e===r.toString())&&(isVoid(t)||xnor(r>=0,t))},exp.isObject=isObject=function(e,t){return lodash.isObject(e)&&!isArray(e)&&!isFunction(e)&&(isVoid(t)||xnor(lodash.values(e).length,t))},exp.isObservable=isObservable=function(e){return isBindable(e,!0)},exp.isOdd=isOdd=function(e,t){return isFinite(e)&&e%2!==0&&(isVoid(t)||xnor(e>=0,t))},exp.isPlainObject=isPlainObject=function(e,t){return lodash.isPlainObject(e)&&(isVoid(t)||xnor(lodash.values(e).length,t))},exp.isPolyfilled=isPolyfilled=function(e){return!(!e||!e.__impl4cf1e782hg__&&!e.__wrapper8e3dd93a60__)},exp.isPositive=isPositive=function(e,t){return isFinite(e)&&e>=0&&(!t||e)},exp.isPredicate=isPredicate=function(e){return isFunction(e)||isObject(e)||isString(e)},exp.isPrevented=isPrevented=function(e){return isEvent(e)&&e.defaultPrevented},exp.isPrimitive=isPrimitive=function(e){return isBoolean(e)||isFinite(e)||isString(e)},exp.isReadable=isReadable=function(e,t){return isString(e)&&readableRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isRegExp=isRegExp=function(e){return lodash.isRegExp(e)},exp.isSelector=isSelector=function(e){return isString(e,!0)},exp.isShady=isShady=function(e){return!!e&&lodash.has(e,"node")&&lodash.has(Object.getPrototypeOf(e),"_queryElement")},exp.isSnakeCase=isSnakeCase=function(e,t){return isString(e)&&snakeCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isStartCase=isStartCase=function(e,t){return isString(e)&&startCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isString=isString=function(e,t){return lodash.isString(e)&&(isVoid(t)||xnor(e.length,t))},exp.isTemplate=isTemplate=function(e){return isElement(e)&&"template"===(e.node||e).tagName.toLowerCase()},exp.isTrue=isTrue=function(e){return e===!0},exp.isUniq=isUniq=function(e,t){return isArrayable(e)&&e.length===uniq(e).length&&(isVoid(t)||xnor(e.length,t))},exp.isUpperCase=isUpperCase=function(e,t){return isString(e)&&upperCaseRegex.test(e)&&(isVoid(t)||xnor(e.length,t))},exp.isVoid=isVoid=function(e){return isNull(e)||!isDefined(e)},exp.isWithin=isWithin=function(e,t,r){return assertArgument(isNumber(t),2,"number"),assertArgument(isVoid(r)||isNumber(r),3,"number"),isNumber(e)&&e>=(isVoid(r)?0:t)&&e<=(isVoid(r)?t:r)},exp.iterate=iterate=function(e,t,r){function n(r){return!r&&(s+=1)<size(o||e)?t(n,e[o?o[s]:s],o?o[s]:s,e):i(r,r?null:e)}assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),assertArgument(isVoid(r)||isFunction(r),3,"Function");var i=r||mock(),s=-1,o=isArrayable(e)?null:keys(e);n(null)},exp.kebabCase=kebabCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.kebabCase(lodash.trim(e)):""},exp.kebabCaseRegex=kebabCaseRegex=/^([a-z](?![\d])|[\d](?![a-z]))+(-?([a-z](?![\d])|[\d](?![a-z])))*$|^$/,exp.keyCase=keyCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.camelCase(lodash.trim(e)).replace(/^(\d+)/,""):""},exp.keyCaseRegex=keyCaseRegex=/^([a-z])+([A-Z]*([a-z]|[\d](?![a-z]))*)+$|^$/,exp.keys=keys=function(e){return assertArgument(isObject(e),1,"Object"),lodash.keys(e)},exp.keysIn=keysIn=function(e){return assertArgument(isObject(e),1,"Object"),lodash.keysIn(e)},exp.last=last=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.last(e)},exp.lastIndexOf=lastIndexOf=function(e,t,r){assertArgument(isString(e)||isDefined(e=toArray(e)),1,"Arrayable or string"),assertArgument(isVoid(r)||isFinite(r),3,"number");var n=isArray(e)?lodash.lastIndexOf(e,t,r):isString(t)?e.lastIndexOf(t):-1;return isIndex(n)?n:void 0},exp.listen=listen=function(e,t,r){return isNode(e)||!isObject(e)&&!isString(e)||(r=t,t=e,e=global),assertArgument(isVoid(e)||isNode(e)||e===global,1,"Element or Window"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string"),assertArgument(isVoid(r)||isFunction(r),3,"Function"),isVoid(e)?e:(isObject(t)&&forOwn(t,function(t,r){e.addEventListener(r,t)}),isString(t,!0)&&isFunction(r)&&e.addEventListener(t,r),e)},exp.localize=localize=function r(e,t){return assertArgument(isVoid(e)||isString(e)||isCollection(e),1,"Array, Object or string"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e&&t?isString(e)?value(t,e,e):isArrayable(e)?map(e,function(e){return r(t,e)}):isObject(e)?mapValues(e,function(e,n){return r(t,n)}):void 0:e||""},exp.lowerCase=lowerCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.trim(e).toLowerCase():""},exp.lowerCaseRegex=lowerCaseRegex=/^[^\sA-Z]+[^\sA-Z]*$|^$/,exp.map=map=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.map(e,t,r)},exp.mapOne=mapOne=function(e,t){assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string");var r;return forEach(e,function(e,n,i){return!isDefined(r=t(e,n,i))}),r},exp.mapValues=mapValues=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t)||isString(t),2,"Function or string"),lodash.mapValues(e,t,r)},exp.match=match=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t),2,"RegExp"),e&&t?e.match(t)||[]:[]},exp.matches=matches=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=e.node||e,n=r.matches||r.webkitMatchesSelector||r.mozMatchesSelector||r.msMatchesSelector||r.oMatchesSelector;return!t||n.call(r,t)},exp.max=max=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.max(e,t,r)},exp.memoize=memoize=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.memoize(e,t)},exp.merge=merge=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.merge.apply(lodash,filter(arguments,ary(isObject,1)))},exp.min=min=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.min(e,t,r)},exp.mock=mock=function(){return function(){}},exp.moveFirst=moveFirst=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"void or a positive number"),e.unshift.apply(e,e.splice(t,r)),e},exp.moveLast=moveLast=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"void or a positive number"),e.push.apply(e,e.splice(t,r)),e},exp.nand=nand=function(e,t){return!and(e,t)},exp.negate=negate=function(e){return assertArgument(isFunction(e),1,"Function"),lodash.negate(e)},exp.nor=nor=function(e,t){return!or(e,t)},exp.not=not=function(e){return!e},exp.omit=omit=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isArrayable(t)||isFunction(t),2,"Arrayable or Function"),lodash.omit(e,t,r)},exp.onMutation=onMutation=function(e,t,r){assertArgument(isNode(e),1,"Node"),assertArgument(isFunction(t),2,"Function"),assertArgument(isVoid(r)||isObject(r),3,"Object");var n=new global.MutationObserver(function(e){delay(function(){t(e)}),n.disconnect()});return n.observe(e,r||{attributes:!1,characterData:!1,childList:!0,subtree:!0}),n},exp.once=once=function(e){return assertArgument(isFunction(e),1,"Function"),lodash.once(e)},exp.or=or=function(e,t){return Boolean(e||t)},exp.overwrite=overwrite=function(e,t,r){assertArgument(isArray(e),1,"Array"),assertArgument(isArrayable(t),2,"Arrayable");var n=e.length!==t.length||mapOne(e,function(e,r){return e!==t[r]?!0:void 0});return n&&Array.prototype.splice.apply(e,concat([0,e.length],t)),e},exp.pad=pad=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.pad(e,t,r)},exp.padLeft=padLeft=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.padLeft(e,t,r)},exp.padRight=padRight=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.padRight(e,t,r)},exp.pairs=pairs=function(e){return assertArgument(isObject(e),1,"Object"),lodash.pairs(e)},exp.parallel=parallel=function(e,t){assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var r=t||mock(),n=size(e),i=isArray(e)?[]:{},s=!1;forEach(e,function(e,t){isFunction(e)&&!s?e(function(e,o){return n-=1,i[t]=o,s?void 0:e?r(s=e,null):n?void 0:r(null,i)}):(n-=1,i[t]=void 0)})},exp.parseBase62=parseBase62=function(e){if(assertArgument(isVoid(e)||isString(e),1,"string"),isBase62(e)){var t=0,r="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",n=e.split("").reverse();return n.forEach(function(e,n){t+=r.indexOf(e)*Math.pow(62,n)}),t}},exp.parseHex=parseHex=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),isHex(e)?parseInt(e,16):void 0},exp.parseJSON=parseJSON=function(e){assertArgument(isVoid(e)||isString(e),1,"string");try{return JSON.parse(e||"")}catch(t){}},exp.parseURL=parseURL=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),e?url.parse(e,!!t,!!r):void 0},exp.partition=partition=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.partition(e,t,r)},exp.pick=pick=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isArrayable(t)||isFunction(t),2,"Arrayable or Function"),lodash.pick(e,t,r)},exp.pluck=pluck=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isString(t),2,"string"),lodash.pluck(e,t)},exp.prefix=prefix=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string");var n=startsWith(e?e.toLowerCase():"",t?t.toLowerCase():"",r?r.toLowerCase():"");return(t||"")+(r||"")+(e||"").slice(n?(t||"").length+(r||"").length:0)},exp.prependChild=prependChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t&&e.insertBefore(t,e.firstChild),t},exp.preventDefault=preventDefault=function(e){return assertArgument(isVoid(e)||isEvent(e),1,"Event"),e.preventDefault(),e},exp.pull=pull=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.pull(e,t)},exp.pullAt=pullAt=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),lodash.pullAt(e,t)[0]},exp.push=push=function(e,t){return assertArgument(isString(e)||isArray(e),1,"Array or string"),isArray(e)?e[e.push(t)-1]:isString(t)||isFinite(t)?e+t:e},exp.random=random=function(e,t,r){return assertArgument(isVoid(e)||isFinite(e),1,"number"),assertArgument(isVoid(t)||isFinite(t),2,"number"),lodash.random(e,t,!!r)},exp.range=range=function(e,t,r){return assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isFinite(t),2,"number"),assertArgument(isVoid(r)||isFinite(r),3,"number"),lodash.range(e,t,r)},exp.readable=readable=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.capitalize(lodash.snakeCase(lodash.trim(e)).replace(/_/g," ")):""},exp.readableRegex=readableRegex=/^[A-Z]\s{0,1}(([a-z])+\s{1}|([0-9])+\s{1})*[a-z0-9]$|^$/,exp.redirect=redirect=function(e,t){assertArgument(isString(e),1,"string"),isBrowser()&&(global.location[t?"hash":"href"]=e)},exp.reduce=reduce=function(e,t,r,n){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.reduce(e,t,r,n)},exp.reduceRight=reduceRight=function(e,t,r,n){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.reduceRight(e,t,r,n)},exp.reject=reject=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.reject(e,t,r)},exp.remove=remove=function(e,t,r){return assertArgument(isArray(e),1,"Array"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.remove(e,t,r)},exp.removeAttribute=removeAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.removeAttribute(t),e},exp.removeAttributes=removeAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){removeAttribute(e,t)}),e},exp.removeChild=removeChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t&&e.removeChild(t),t},exp.removeClass=removeClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.classList.remove(t),e},exp.removeStyle=removeStyle=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t,!0),2,"string"),e&&t&&(e.style[t]=""),e},exp.removeStyles=removeStyles=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){removeStyle(e,t)}),e},exp.renameElement=renameElement=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=e&&t?createElement(t,{attributes:getAttributes(e),children:getChildren(e)}):void 0;return r&&replaceNode(e,r),r||e},exp.repeat=repeat=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string");var n,i="";if(e)for(n=0;t>n;n+=1)i+=(n?r||"":"")+e;return i},exp.replaceNode=replaceNode=function(e,t){return assertArgument(isVoid(e)||isNode(e),1,"Node"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t?e.parentNode.replaceChild(t,e):void 0},exp.requestAnimationFrame=requestAnimationFrame=function(e){assertArgument(isFunction(e),1,"Function"),global.requestAnimationFrame(e)},exp.rest=rest=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.rest(e)},exp.round=round=function(e,t){return assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isIndex(t),2,"number"),Math.round(e*(t=Math.pow(10,t||0)))/t},exp.sample=sample=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.sample(e,t)},exp.seal=seal=function(e){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),Object.seal(e)},exp.setAttribute=setAttribute=function(e,t,r){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),isVoid(r)||isFalse(r)?removeAttribute(e,t):(e&&t&&e.setAttribute(t,toString(r)),e)},exp.setAttributes=setAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e&&t&&forOwn(t,function(t,r){setAttribute(e,r,t)}),e},exp.setChildren=setChildren=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&(flush(e),forEach(t,function(t){appendChild(e,t)})),e},exp.setHTML=setHTML=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=isTemplate(e)?e.instanceRef_:e;return r&&(r.innerHTML=t||""),e},exp.setStyle=setStyle=function(e,t,r){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),isVoid(r)||isBoolean(r)?removeStyle(e,t):(e&&t&&(e.style[t]=toString(r)),e)},exp.setStyles=setStyles=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string");var r=e?createElement("div"):null;return e&&isObject(t)&&forOwn(t,function(t,r){setStyle(e,r,t)}),e&&isString(t)&&forEach(setAttribute(r,"style",t).style,function(t){e.style[t]=r.style[t]}),e},exp.setText=setText=function(e,t){return assertArgument(isVoid(e)||isNode(e),1,"Node"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&!isTemplate(e)&&(e.textContent=t||""),e},exp.shrink=shrink=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),e.length>t&&e.splice(t,e.length-t),e},exp.shuffle=shuffle=function(e){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),lodash.shuffle(e)},exp.size=size=function(e){return assertArgument(isString(e)||isCollection(e=toArray(e)||e),1,"Arrayable, Object or string"),lodash.size(e)},exp.slice=slice=function(e,t,r){return assertArgument(isVoid(t)||isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"a positive number"),lodash.slice(e,t,r)},exp.snakeCase=snakeCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.snakeCase(lodash.trim(e)):""},exp.snakeCaseRegex=snakeCaseRegex=/^([a-z](?![\d])|[\d](?![a-z]))+(_?([a-z](?![\d])|[\d](?![a-z])))*$|^$/,exp.some=some=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.some(e,t,r)},exp.sortBy=sortBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.sortBy(e,t,r)},exp.split=split=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string");var n=e&&t?e.indexOf(t):-1;return 0>n?[e||""]:r?[e.slice(0,n),e.slice(n+1)]:e.split(t)},exp.startCase=startCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.startCase(lodash.trim(e)):""},exp.startCaseRegex=startCaseRegex=/^(([A-Z][a-z]*|[0-9]+)[\s])*([A-Z][a-z]*|[0-9]+)$|^$/,exp.startsWith=startsWith=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.startsWith(e,(r||"")+(t||""))},exp.stop=stop=function(e){return stopPropagation(preventDefault(e))},exp.stopPropagation=stopPropagation=function(e){return assertArgument(isVoid(e)||isEvent(e),1,"Event"),e.stopPropagation(),e},exp.stretch=stretch=function(e,t,r){for(assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number");e.length<t;)e.push(r);return e},exp.strip=strip=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t)||isString(t),2,"RegExp or string"),e&&t?e.replace(t,""):e||""},exp.suffix=suffix=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string");var n=endsWith(e?e.toLowerCase():"",t?t.toLowerCase():"",r?r.toLowerCase():"");return e.slice(0,n?e.length-(r||"").length-(t||"").length:void 0)+(r||"")+t},exp.take=take=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.take(e,t)},exp.takeRight=takeRight=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.takeRight(e,t)},exp.takeRightWhile=takeRightWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.takeRightWhile(e,t,r)},exp.takeWhile=takeWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.takeWhile(e,t,r)},exp.throttle=throttle=function(e,t,r){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isObject(r),3,"Object"),lodash.throttle(e,t,r)},exp.toArray=toArray=function(e,t){return isArray(e)?e:isArrayable(e)?slice(e):t?isNullable(e)?[]:[e]:void 0},exp.toBase62=toBase62=function(e){if(isInt(e)){for(var t="",r="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";e>0;)t=r[e%62]+t,e=Math.floor(e/62);return t||"0"}},exp.toBoolean=toBoolean=function(e,t){return isDefined(e)?!!e&&"false"!==e:t?!1:void 0},exp.toDOMIdentity=toDOMIdentity=function(e){if(isElement(e))return function(t){return t===e};if(isFunction(e)||isString(e,!0))return toDOMPredicate(e);if(isNullable(e))return mock();throw new ArgumentError(1,"Element, Function or string")},exp.toDOMPredicate=toDOMPredicate=function(e){if(isFunction(e))return function(t){return isElement(t)&&e.apply(null,arguments)};if(isString(e))return function(t){return isElement(t)&&matches(t,e)};if(isVoid(e))return function(e){return isElement(e)};throw new ArgumentError(1,"Function or string")},exp.toElapsedTime=toElapsedTime=function(e){if(isFinite(e)){var t=Math.floor((Date.now()-e)/1e3),r=[{label:"year",value:31536e3},{label:"month",value:2592e3},{label:"day",value:86400},{label:"hour",value:3600},{label:"minute",value:60},{label:"second",value:1}];return 0>t?"":t?mapOne(r,function(e){var r=Math.floor(t/e.value);return r?r+" "+e.label+(r>1?"s":"")+" ago":void 0}):"now"}},exp.toHex=toHex=function(e){return isInt(e)?e.toString(16).toUpperCase():void 0},exp.toIndex=toIndex=function(e,t){return isIndex(e=toInt(e))?e:t?0:void 0},exp.toInfinite=toInfinite=function(e,t){return isInfinite(e)?e:"-Infinity"===e?-(1/0):"Infinity"===e||t?1/0:void 0},exp.toInput=toInput=function(e,t){return isNumber(e)?e.toString():isString(e)?e:t?"":void 0},exp.toInt=toInt=function(e,t){return isFinite(e=parseInt(e,10))?e:t?0:void 0},exp.toJSON=toJSON=function(e,t,r){return isNullable(e)?"null":JSON.stringify(e,function(e,r){var n=r&&r.toJSON?r.toJSON():r;return isFunction(n)?n.toString():isAny(n)?r:t?void 0:null},r?"  ":void 0)},exp.toNumber=toNumber=function(e,t){return isFinite(e=parseFloat(e))?e:t?0:void 0},exp.toObject=toObject=function(e,t){return isObject(e)?e:t?{}:void 0},exp.toPosition=toPosition=function(e){if(isIndex(e)){var t=e.toString(),r=t[t.length-1];return"1"===r&&11!==e?t+"st":"2"===r&&12!==e?t+"nd":"3"===r&&13!==e?t+"rd":t+"th"}},exp.toQueryString=toQueryString=function(e,t){if(isDefined(e=toObject(e,t))){var r=map(e,function(e,t){return isBoolean(e)||isFinite(e)||isString(e)?t+"="+encodeURIComponent(e.toString()):void 0});return filter(r,ary(isDefined,1)).join("&")}},exp.toRegExp=toRegExp=function(e){var t,r,n,i;if(!isString(e))return isRegExp(e)?e:void 0;if("/"!==e[0])return e?new RegExp(e):null;for(t=r=!1,n=1,i="";n<e.length&&(t=!r&&"/"===e[n],r=!r&&"\\"===e[n],!t);n+=1)i+=e[n];try{return t&&i?new RegExp(i,e.slice(n+1)):null}catch(s){return null}},exp.toString=toString=function(e){return isVoid(e)||isBoolean(e)?"":isNumber(e)?e.toString():isString(e)?e:JSON.stringify(e,function(e,t){var r=t&&t.toJSON?t.toJSON():t;return isNullable(t)?null:isError(r)||isFunction(r)||isRegExp(r)?r.toString():t})},exp.toTemplate=toTemplate=function(e,t){if(!isVoid(e=isElement(e)?e:t?createElement("div"):null)){for(var r=e.firstChild,n=createElement("template");r;)n.content.appendChild(r.cloneNode(!0)),r=r.nextSibling;return n}},exp.toURL=toURL=function(e,t){if(isString(e,!0)){var r=toQueryString(t);return e+(r?"?"+r:"")}},exp.toUseful=toUseful=function(e){return isAny(e)?e:void 0},exp.toValue=toValue=function(e,t){return"false"===e||"true"===e?toBoolean(e):isNumeric(e)?toNumber(e):isString(e)?e:t?null:void 0},exp.toggleAttribute=toggleAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e[e.hasAttribute(t)?"removeAttribute":"setAttribute"](t,""),e},exp.toggleClass=toggleClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t,!0),2,"string"),e&&t&&e.classList.toggle(t),e},exp.trim=trim=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trim(e,t):""},exp.trimLeft=trimLeft=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trimLeft(e,t):""},exp.trimRegex=trimRegex=/^(?!\s).*[\S]+$|^$/,exp.trimRight=trimRight=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trimRight(e,t):""},exp.trunc=trunc=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e?lodash.trunc(e,t):""},exp.unescape=unescape=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.unescape(e):""},exp.union=union=function(e){return lodash.union.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.uniq=uniq=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.uniq(e,t,r)},exp.unlisten=unlisten=function(e,t,r){return isNode(e)||!isObject(e)&&!isString(e)||(r=t,t=e,e=global),assertArgument(isVoid(e)||isNode(e)||e===global,1,"Element or Window"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string"),assertArgument(isVoid(r)||isFunction(r),3,"Function"),isVoid(e)?e:(isObject(t)&&forOwn(t,function(t,r){e.removeEventListener(r,t)}),isString(t,!0)&&isFunction(r)&&e.removeEventListener(t,r),e)},exp.unzip=unzip=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.unzip(e)},exp.updateElement=updateElement=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),
assertArgument(isVoid(t)||isObject(t),2,"Object"),e&&t&&t.attributes&&setAttributes(e,t.attributes),e&&t&&t.properties&&assign(e,t.properties),e&&t&&t.children&&setChildren(e,t.children),e},exp.upperCase=upperCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.trim(e).toUpperCase():""},exp.upperCaseRegex=upperCaseRegex=/^[^\sa-z]+[^\sa-z]*$|^$/,exp.value=value=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),has(e,t)?e[t]:r},exp.valueIn=valueIn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),isDefined(e[t])?e[t]:r},exp.values=values=function(e){return assertArgument(isObject(e),1,"Object"),lodash.values(e)},exp.valuesIn=valuesIn=function(e){return assertArgument(isObject(e),1,"Object"),lodash.valuesIn(e)},exp.waterfall=waterfall=function(e,t){function r(){var e,t,o=slice(arguments);for(s+=1;s<i.length&&!isFunction(i[s]);s+=1);for(t=s+1;t<i.length&&!isFunction(i[t]);t+=1);e=o.splice(0,1,i[t]?r:n)[0],(!e&&i[s]?i[s]:n).apply(void 0,e?[e]:o)}assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var n=t||mock(),i=isArray(e)?e:values(e),s=-1;r()},exp.where=where=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isObject(t),2,"Object"),lodash.where(e,t)},exp.willBleedBottom=willBleedBottom=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.top+t.top+e.height+t.bottom>getHeight()},exp.willBleedHorizontally=willBleedHorizontally=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),t.left+e.width+t.right>getWidth()},exp.willBleedLeft=willBleedLeft=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.left<0},exp.willBleedRight=willBleedRight=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.left+t.left+e.width+t.right>getWidth()},exp.willBleedTop=willBleedTop=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.top<0},exp.willBleedVertically=willBleedVertically=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),t.top+e.height+t.bottom>getHeight()},exp.withdraw=withdraw=function(e,t){var r;return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),has(e,t)&&(r=e[t],delete e[t]),r},exp.within=within=function(e,t,r){return assertArgument(isNumber(e),1,"number"),assertArgument(isNumber(t),2,"number"),assertArgument(isNumber(r),3,"number"),t>e?t:e>r?r:e},exp.without=without=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.without.apply(lodash,concat([e],slice(arguments,1)))},exp.words=words=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t)||isString(t),2,"RegExp or string"),e?lodash.words(e,t):[]},exp.wrap=wrap=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.wrap(e,t)},exp.xnor=xnor=function(e,t){return!xor(e,t)},exp.xor=xor=function(e,t){return Boolean(e)!==Boolean(t)},exp.zip=zip=function(e){return lodash.union.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.zipObject=zipObject=function(e,t){assertArgument(isString(e,!0)||isDefined(e=toArray(e)),1,"Arrayable or string");var r={},n=isArrayable(t);return isString(e)?r[e]=t:e.forEach(function(e,i){r[e]=n?t[i]:t}),r},browser&&(global._=lodash,global.XPClass=exp.Class,global.XPDeferred=exp.Deferred,global.XPPromise=exp.Promise)}("undefined"!=typeof window?window:global,"undefined"!=typeof window);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash":8,"q":9,"url":6}],8:[function(require,module,exports){
(function (global){
(function(){function n(n,t){if(n!==t){var r=null===n,e=n===b,u=n===n,i=null===t,o=t===b,a=t===t;if(n>t&&!i||!u||r&&!o&&a||e&&a)return 1;if(t>n&&!r||!a||i&&!e&&u||o&&u)return-1}return 0}function t(n,t,r){for(var e=n.length,u=r?e:-1;r?u--:++u<e;)if(t(n[u],u,n))return u;return-1}function r(n,t,r){if(t!==t)return p(n,r);for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function e(n){return"function"==typeof n||!1}function u(n){return"string"==typeof n?n:null==n?"":n+""}function i(n,t){for(var r=-1,e=n.length;++r<e&&t.indexOf(n.charAt(r))>-1;);return r}function o(n,t){for(var r=n.length;r--&&t.indexOf(n.charAt(r))>-1;);return r}function a(t,r){return n(t.criteria,r.criteria)||t.index-r.index}function f(t,r,e){for(var u=-1,i=t.criteria,o=r.criteria,a=i.length,f=e.length;++u<a;){var l=n(i[u],o[u]);if(l)return u>=f?l:l*(e[u]?1:-1)}return t.index-r.index}function l(n){return Dn[n]}function c(n){return Mn[n]}function s(n){return"\\"+Yn[n]}function p(n,t,r){for(var e=n.length,u=t+(r?0:-1);r?u--:++u<e;){var i=n[u];if(i!==i)return u}return-1}function h(n){return!!n&&"object"==typeof n}function v(n){return 160>=n&&n>=9&&13>=n||32==n||160==n||5760==n||6158==n||n>=8192&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n)}function _(n,t){for(var r=-1,e=n.length,u=-1,i=[];++r<e;)n[r]===t&&(n[r]=z,i[++u]=r);return i}function g(n,t){for(var r,e=-1,u=n.length,i=-1,o=[];++e<u;){var a=n[e],f=t?t(a,e,n):a;e&&r===f||(r=f,o[++i]=a)}return o}function y(n){for(var t=-1,r=n.length;++t<r&&v(n.charCodeAt(t)););return t}function d(n){for(var t=n.length;t--&&v(n.charCodeAt(t)););return t}function m(n){return Kn[n]}function w(v){function Y(n){if(h(n)&&!ka(n)&&!(n instanceof Dn)){if(n instanceof Q)return n;if(Gi.call(n,"__chain__")&&Gi.call(n,"__wrapped__"))return le(n)}return new Q(n)}function Z(){}function Q(n,t,r){this.__wrapped__=n,this.__actions__=r||[],this.__chain__=!!t}function Dn(n){this.__wrapped__=n,this.__actions__=null,this.__dir__=1,this.__dropCount__=0,this.__filtered__=!1,this.__iteratees__=null,this.__takeCount__=Oo,this.__views__=null}function Mn(){var n=this.__actions__,t=this.__iteratees__,r=this.__views__,e=new Dn(this.__wrapped__);return e.__actions__=n?et(n):null,e.__dir__=this.__dir__,e.__filtered__=this.__filtered__,e.__iteratees__=t?et(t):null,e.__takeCount__=this.__takeCount__,e.__views__=r?et(r):null,e}function Kn(){if(this.__filtered__){var n=new Dn(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Vn(){var n=this.__wrapped__.value();if(!ka(n))return rr(n,this.__actions__);var t=this.__dir__,r=0>t,e=qr(0,n.length,this.__views__),u=e.start,i=e.end,o=i-u,a=r?i:u-1,f=mo(o,this.__takeCount__),l=this.__iteratees__,c=l?l.length:0,s=0,p=[];n:for(;o--&&f>s;){a+=t;for(var h=-1,v=n[a];++h<c;){var _=l[h],g=_.iteratee,y=_.type;if(y==F){if(_.done&&(r?a>_.index:a<_.index)&&(_.count=0,_.done=!1),_.index=a,!_.done){var d=_.limit;if(!(_.done=d>-1?_.count++>=d:!g(v)))continue n}}else{var m=g(v);if(y==L)v=m;else if(!m){if(y==N)continue n;break n}}}p[s++]=v}return p}function Yn(){this.__data__={}}function Gn(n){return this.has(n)&&delete this.__data__[n]}function Jn(n){return"__proto__"==n?b:this.__data__[n]}function Xn(n){return"__proto__"!=n&&Gi.call(this.__data__,n)}function Zn(n,t){return"__proto__"!=n&&(this.__data__[n]=t),this}function Hn(n){var t=n?n.length:0;for(this.data={hash:ho(null),set:new ao};t--;)this.push(n[t])}function Qn(n,t){var r=n.data,e="string"==typeof t||Iu(t)?r.set.has(t):r.hash[t];return e?0:-1}function rt(n){var t=this.data;"string"==typeof n||Iu(n)?t.set.add(n):t.hash[n]=!0}function et(n,t){var r=-1,e=n.length;for(t||(t=Ti(e));++r<e;)t[r]=n[r];return t}function ut(n,t){for(var r=-1,e=n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function it(n,t){for(var r=n.length;r--&&t(n[r],r,n)!==!1;);return n}function ot(n,t){for(var r=-1,e=n.length;++r<e;)if(!t(n[r],r,n))return!1;return!0}function at(n,t,r,e){for(var u=-1,i=n.length,o=e,a=o;++u<i;){var f=n[u],l=+t(f);r(l,o)&&(o=l,a=f)}return a}function ft(n,t){for(var r=-1,e=n.length,u=-1,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[++u]=o)}return i}function lt(n,t){for(var r=-1,e=n.length,u=Ti(e);++r<e;)u[r]=t(n[r],r,n);return u}function ct(n,t,r,e){var u=-1,i=n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function st(n,t,r,e){var u=n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function pt(n,t){for(var r=-1,e=n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function ht(n){for(var t=n.length,r=0;t--;)r+=+n[t]||0;return r}function vt(n,t){return n===b?t:n}function _t(n,t,r,e){return n!==b&&Gi.call(e,r)?n:t}function gt(n,t,r){for(var e=-1,u=Ba(t),i=u.length;++e<i;){var o=u[e],a=n[o],f=r(a,t[o],o,n,t);(f===f?f===a:a!==a)&&(a!==b||o in n)||(n[o]=f)}return n}function yt(n,t){return null==t?n:mt(t,Ba(t),n)}function dt(n,t){for(var r=-1,e=null==n,u=!e&&Yr(n),i=u?n.length:0,o=t.length,a=Ti(o);++r<o;){var f=t[r];u?a[r]=Gr(f,i)?n[f]:b:a[r]=e?b:n[f]}return a}function mt(n,t,r){r||(r={});for(var e=-1,u=t.length;++e<u;){var i=t[e];r[i]=n[i]}return r}function wt(n,t,r){var e=typeof n;return"function"==e?t===b?n:ir(n,t,r):null==n?wi:"object"==e?Bt(n):t===b?Ri(n):zt(n,t)}function bt(n,t,r,e,u,i,o){var a;if(r&&(a=u?r(n,e,u):r(n)),a!==b)return a;if(!Iu(n))return n;var f=ka(n);if(f){if(a=Dr(n),!t)return et(n,a)}else{var l=Xi.call(n),c=l==V;if(l!=J&&l!=P&&(!c||u))return Pn[l]?Kr(n,l,t):u?n:{};if(a=Mr(c?{}:n),!t)return yt(a,n)}i||(i=[]),o||(o=[]);for(var s=i.length;s--;)if(i[s]==n)return o[s];return i.push(n),o.push(a),(f?ut:Wt)(n,function(e,u){a[u]=bt(e,t,r,u,n,i,o)}),a}function xt(n,t,r){if("function"!=typeof n)throw new qi(B);return fo(function(){n.apply(b,r)},t)}function At(n,t){var e=n?n.length:0,u=[];if(!e)return u;var i=-1,o=Br(),a=o==r,f=a&&t.length>=200?zo(t):null,l=t.length;f&&(o=Qn,a=!1,t=f);n:for(;++i<e;){var c=n[i];if(a&&c===c){for(var s=l;s--;)if(t[s]===c)continue n;u.push(c)}else o(t,c,0)<0&&u.push(c)}return u}function jt(n,t){var r=!0;return $o(n,function(n,e,u){return r=!!t(n,e,u)}),r}function Ot(n,t,r,e){var u=e,i=u;return $o(n,function(n,o,a){var f=+t(n,o,a);(r(f,u)||f===e&&f===i)&&(u=f,i=n)}),i}function Rt(n,t,r,e){var u=n.length;for(r=null==r?0:+r||0,0>r&&(r=-r>u?0:u+r),e=e===b||e>u?u:+e||0,0>e&&(e+=u),u=r>e?0:e>>>0,r>>>=0;u>r;)n[r++]=t;return n}function kt(n,t){var r=[];return $o(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function It(n,t,r,e){var u;return r(n,function(n,r,i){return t(n,r,i)?(u=e?r:n,!1):void 0}),u}function Et(n,t,r){for(var e=-1,u=n.length,i=-1,o=[];++e<u;){var a=n[e];if(h(a)&&Yr(a)&&(r||ka(a)||bu(a))){t&&(a=Et(a,t,r));for(var f=-1,l=a.length;++f<l;)o[++i]=a[f]}else r||(o[++i]=a)}return o}function Ct(n,t){return No(n,t,Yu)}function Wt(n,t){return No(n,t,Ba)}function St(n,t){return Lo(n,t,Ba)}function Tt(n,t){for(var r=-1,e=t.length,u=-1,i=[];++r<e;){var o=t[r];Ea(n[o])&&(i[++u]=o)}return i}function Ut(n,t,r){if(null!=n){r!==b&&r in ae(n)&&(t=[r]);for(var e=0,u=t.length;null!=n&&u>e;)n=n[t[e++]];return e&&e==u?n:b}}function $t(n,t,r,e,u,i){return n===t?!0:null==n||null==t||!Iu(n)&&!h(t)?n!==n&&t!==t:Ft(n,t,$t,r,e,u,i)}function Ft(n,t,r,e,u,i,o){var a=ka(n),f=ka(t),l=q,c=q;a||(l=Xi.call(n),l==P?l=J:l!=J&&(a=Fu(n))),f||(c=Xi.call(t),c==P?c=J:c!=J&&(f=Fu(t)));var s=l==J,p=c==J,h=l==c;if(h&&!a&&!s)return $r(n,t,l);if(!u){var v=s&&Gi.call(n,"__wrapped__"),_=p&&Gi.call(t,"__wrapped__");if(v||_)return r(v?n.value():n,_?t.value():t,e,u,i,o)}if(!h)return!1;i||(i=[]),o||(o=[]);for(var g=i.length;g--;)if(i[g]==n)return o[g]==t;i.push(n),o.push(t);var y=(a?Ur:Fr)(n,t,r,e,u,i,o);return i.pop(),o.pop(),y}function Nt(n,t,r){var e=t.length,u=e,i=!r;if(null==n)return!u;for(n=ae(n);e--;){var o=t[e];if(i&&o[2]?o[1]!==n[o[0]]:!(o[0]in n))return!1}for(;++e<u;){o=t[e];var a=o[0],f=n[a],l=o[1];if(i&&o[2]){if(f===b&&!(a in n))return!1}else{var c=r?r(f,l,a):b;if(!(c===b?$t(l,f,r,!0):c))return!1}}return!0}function Lt(n,t){var r=-1,e=Yr(n)?Ti(n.length):[];return $o(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Bt(n){var t=zr(n);if(1==t.length&&t[0][2]){var r=t[0][0],e=t[0][1];return function(n){return null==n?!1:n[r]===e&&(e!==b||r in ae(n))}}return function(n){return Nt(n,t)}}function zt(n,t){var r=ka(n),e=Xr(n)&&Qr(t),u=n+"";return n=fe(n),function(i){if(null==i)return!1;var o=u;if(i=ae(i),!(!r&&e||o in i)){if(i=1==n.length?i:Ut(i,Gt(n,0,-1)),null==i)return!1;o=xe(n),i=ae(i)}return i[o]===t?t!==b||o in i:$t(t,i[o],b,!0)}}function Pt(n,t,r,e,u){if(!Iu(n))return n;var i=Yr(t)&&(ka(t)||Fu(t)),o=i?null:Ba(t);return ut(o||t,function(a,f){if(o&&(f=a,a=t[f]),h(a))e||(e=[]),u||(u=[]),qt(n,t,f,Pt,r,e,u);else{var l=n[f],c=r?r(l,a,f,n,t):b,s=c===b;s&&(c=a),c===b&&(!i||f in n)||!s&&(c===c?c===l:l!==l)||(n[f]=c)}}),n}function qt(n,t,r,e,u,i,o){for(var a=i.length,f=t[r];a--;)if(i[a]==f)return void(n[r]=o[a]);var l=n[r],c=u?u(l,f,r,n,t):b,s=c===b;s&&(c=f,Yr(f)&&(ka(f)||Fu(f))?c=ka(l)?l:Yr(l)?et(l):[]:Ca(f)||bu(f)?c=bu(l)?Pu(l):Ca(l)?l:{}:s=!1),i.push(f),o.push(c),s?n[r]=e(c,f,u,i,o):(c===c?c!==l:l===l)&&(n[r]=c)}function Dt(n){return function(t){return null==t?b:t[n]}}function Mt(n){var t=n+"";return n=fe(n),function(r){return Ut(r,n,t)}}function Kt(n,t){for(var r=n?t.length:0;r--;){var e=t[r];if(e!=u&&Gr(e)){var u=e;lo.call(n,e,1)}}return n}function Vt(n,t){return n+eo(Ao()*(t-n+1))}function Yt(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function Gt(n,t,r){var e=-1,u=n.length;t=null==t?0:+t||0,0>t&&(t=-t>u?0:u+t),r=r===b||r>u?u:+r||0,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=Ti(u);++e<u;)i[e]=n[e+t];return i}function Jt(n,t){var r;return $o(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function Xt(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function Zt(n,t,r){var e=Nr(),u=-1;t=lt(t,function(n){return e(n)});var i=Lt(n,function(n){var r=lt(t,function(t){return t(n)});return{criteria:r,index:++u,value:n}});return Xt(i,function(n,t){return f(n,t,r)})}function Ht(n,t){var r=0;return $o(n,function(n,e,u){r+=+t(n,e,u)||0}),r}function Qt(n,t){var e=-1,u=Br(),i=n.length,o=u==r,a=o&&i>=200,f=a?zo():null,l=[];f?(u=Qn,o=!1):(a=!1,f=t?[]:l);n:for(;++e<i;){var c=n[e],s=t?t(c,e,n):c;if(o&&c===c){for(var p=f.length;p--;)if(f[p]===s)continue n;t&&f.push(s),l.push(c)}else u(f,s,0)<0&&((t||a)&&f.push(s),l.push(c))}return l}function nr(n,t){for(var r=-1,e=t.length,u=Ti(e);++r<e;)u[r]=n[t[r]];return u}function tr(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?Gt(n,e?0:i,e?i+1:u):Gt(n,e?i+1:0,e?u:i)}function rr(n,t){var r=n;r instanceof Dn&&(r=r.value());for(var e=-1,u=t.length;++e<u;){var i=[r],o=t[e];oo.apply(i,o.args),r=o.func.apply(o.thisArg,i)}return r}function er(n,t,r){var e=0,u=n?n.length:e;if("number"==typeof t&&t===t&&Io>=u){for(;u>e;){var i=e+u>>>1,o=n[i];(r?t>=o:t>o)&&null!==o?e=i+1:u=i}return u}return ur(n,t,wi,r)}function ur(n,t,r,e){t=r(t);for(var u=0,i=n?n.length:0,o=t!==t,a=null===t,f=t===b;i>u;){var l=eo((u+i)/2),c=r(n[l]),s=c!==b,p=c===c;if(o)var h=p||e;else h=a?p&&s&&(e||null!=c):f?p&&(e||s):null==c?!1:e?t>=c:t>c;h?u=l+1:i=l}return mo(i,ko)}function ir(n,t,r){if("function"!=typeof n)return wi;if(t===b)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)};case 5:return function(r,e,u,i,o){return n.call(t,r,e,u,i,o)}}return function(){return n.apply(t,arguments)}}function or(n){return no.call(n,0)}function ar(n,t,r){for(var e=r.length,u=-1,i=yo(n.length-e,0),o=-1,a=t.length,f=Ti(i+a);++o<a;)f[o]=t[o];for(;++u<e;)f[r[u]]=n[u];for(;i--;)f[o++]=n[u++];return f}function fr(n,t,r){for(var e=-1,u=r.length,i=-1,o=yo(n.length-u,0),a=-1,f=t.length,l=Ti(o+f);++i<o;)l[i]=n[i];for(var c=i;++a<f;)l[c+a]=t[a];for(;++e<u;)l[c+r[e]]=n[i++];return l}function lr(n,t){return function(r,e,u){var i=t?t():{};if(e=Nr(e,u,3),ka(r))for(var o=-1,a=r.length;++o<a;){var f=r[o];n(i,f,e(f,o,r),r)}else $o(r,function(t,r,u){n(i,t,e(t,r,u),u)});return i}}function cr(n){return hu(function(t,r){var e=-1,u=null==t?0:r.length,i=u>2?r[u-2]:b,o=u>2?r[2]:b,a=u>1?r[u-1]:b;for("function"==typeof i?(i=ir(i,a,5),u-=2):(i="function"==typeof a?a:b,u-=i?1:0),o&&Jr(r[0],r[1],o)&&(i=3>u?b:i,u=1);++e<u;){var f=r[e];f&&n(t,f,i)}return t})}function sr(n,t){return function(r,e){var u=r?qo(r):0;if(!Hr(u))return n(r,e);for(var i=t?u:-1,o=ae(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function pr(n){return function(t,r,e){for(var u=ae(t),i=e(t),o=i.length,a=n?o:-1;n?a--:++a<o;){var f=i[a];if(r(u[f],f,u)===!1)break}return t}}function hr(n,t){function r(){var u=this&&this!==nt&&this instanceof r?e:n;return u.apply(t,arguments)}var e=_r(n);return r}function vr(n){return function(t){for(var r=-1,e=yi(ei(t)),u=e.length,i="";++r<u;)i=n(i,e[r],r);return i}}function _r(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4])}var r=Uo(n.prototype),e=n.apply(r,t);return Iu(e)?e:r}}function gr(n){function t(r,e,u){u&&Jr(r,e,u)&&(e=null);var i=Tr(r,n,null,null,null,null,null,e);return i.placeholder=t.placeholder,i}return t}function yr(n,t){return function(r,e,u){if(u&&Jr(r,e,u)&&(e=null),e=Nr(e,u,3),1==e.length){r=oe(r);var i=at(r,e,n,t);if(!r.length||i!==t)return i}return Ot(r,e,n,t)}}function dr(n,r){return function(e,u,i){if(u=Nr(u,i,3),ka(e)){var o=t(e,u,r);return o>-1?e[o]:b}return It(e,u,n)}}function mr(n){return function(r,e,u){return r&&r.length?(e=Nr(e,u,3),t(r,e,n)):-1}}function wr(n){return function(t,r,e){return r=Nr(r,e,3),It(t,r,n,!0)}}function br(n){return function(){for(var t,r=arguments.length,e=n?r:-1,u=0,i=Ti(r);n?e--:++e<r;){var o=i[u++]=arguments[e];if("function"!=typeof o)throw new qi(B);!t&&Q.prototype.thru&&"wrapper"==Lr(o)&&(t=new Q([]))}for(e=t?-1:r;++e<r;){o=i[e];var a=Lr(o),f="wrapper"==a?Po(o):null;t=f&&Zr(f[0])&&f[1]==(C|R|I|W)&&!f[4].length&&1==f[9]?t[Lr(f[0])].apply(t,f[3]):1==o.length&&Zr(o)?t[a]():t.thru(o)}return function(){var n=arguments;if(t&&1==n.length&&ka(n[0]))return t.plant(n[0]).value();for(var e=0,u=r?i[e].apply(this,n):n[0];++e<r;)u=i[e].call(this,u);return u}}}function xr(n,t){return function(r,e,u){return"function"==typeof e&&u===b&&ka(r)?n(r,e):t(r,ir(e,u,3))}}function Ar(n){return function(t,r,e){return("function"!=typeof r||e!==b)&&(r=ir(r,e,3)),n(t,r,Yu)}}function jr(n){return function(t,r,e){return("function"!=typeof r||e!==b)&&(r=ir(r,e,3)),n(t,r)}}function Or(n){return function(t,r,e){var u={};return r=Nr(r,e,3),Wt(t,function(t,e,i){var o=r(t,e,i);e=n?o:e,t=n?t:o,u[e]=t}),u}}function Rr(n){return function(t,r,e){return t=u(t),(n?t:"")+Cr(t,r,e)+(n?"":t)}}function kr(n){var t=hu(function(r,e){var u=_(e,t.placeholder);return Tr(r,n,null,e,u)});return t}function Ir(n,t){return function(r,e,u,i){var o=arguments.length<3;return"function"==typeof e&&i===b&&ka(r)?n(r,e,u,o):Yt(r,Nr(e,i,4),u,o,t)}}function Er(n,t,r,e,u,i,o,a,f,l){function c(){for(var m=arguments.length,w=m,x=Ti(m);w--;)x[w]=arguments[w];if(e&&(x=ar(x,e,u)),i&&(x=fr(x,i,o)),v||y){var O=c.placeholder,R=_(x,O);if(m-=R.length,l>m){var k=a?et(a):null,C=yo(l-m,0),W=v?R:null,S=v?null:R,T=v?x:null,U=v?null:x;t|=v?I:E,t&=~(v?E:I),g||(t&=~(A|j));var $=[n,t,r,T,W,U,S,k,f,C],F=Er.apply(b,$);return Zr(n)&&Do(F,$),F.placeholder=O,F}}var N=p?r:this,L=h?N[n]:n;return a&&(x=ee(x,a)),s&&f<x.length&&(x.length=f),this&&this!==nt&&this instanceof c&&(L=d||_r(n)),L.apply(N,x)}var s=t&C,p=t&A,h=t&j,v=t&R,g=t&O,y=t&k,d=h?null:_r(n);return c}function Cr(n,t,r){var e=n.length;if(t=+t,e>=t||!_o(t))return"";var u=t-e;return r=null==r?" ":r+"",li(r,to(u/r.length)).slice(0,u)}function Wr(n,t,r,e){function u(){for(var t=-1,a=arguments.length,f=-1,l=e.length,c=Ti(a+l);++f<l;)c[f]=e[f];for(;a--;)c[f++]=arguments[++t];var s=this&&this!==nt&&this instanceof u?o:n;return s.apply(i?r:this,c)}var i=t&A,o=_r(n);return u}function Sr(n){return function(t,r,e,u){var i=Nr(e);return null==e&&i===wt?er(t,r,n):ur(t,r,i(e,u,1),n)}}function Tr(n,t,r,e,u,i,o,a){var f=t&j;if(!f&&"function"!=typeof n)throw new qi(B);var l=e?e.length:0;if(l||(t&=~(I|E),e=u=null),l-=u?u.length:0,t&E){var c=e,s=u;e=u=null}var p=f?null:Po(n),h=[n,t,r,e,u,c,s,i,o,a];if(p&&(ne(h,p),t=h[1],a=h[9]),h[9]=null==a?f?0:n.length:yo(a-l,0)||0,t==A)var v=hr(h[0],h[2]);else v=t!=I&&t!=(A|I)||h[4].length?Er.apply(b,h):Wr.apply(b,h);var _=p?Bo:Do;return _(v,h)}function Ur(n,t,r,e,u,i,o){var a=-1,f=n.length,l=t.length;if(f!=l&&!(u&&l>f))return!1;for(;++a<f;){var c=n[a],s=t[a],p=e?e(u?s:c,u?c:s,a):b;if(p!==b){if(p)continue;return!1}if(u){if(!pt(t,function(n){return c===n||r(c,n,e,u,i,o)}))return!1}else if(c!==s&&!r(c,s,e,u,i,o))return!1}return!0}function $r(n,t,r){switch(r){case D:case M:return+n==+t;case K:return n.name==t.name&&n.message==t.message;case G:return n!=+n?t!=+t:n==+t;case X:case H:return n==t+""}return!1}function Fr(n,t,r,e,u,i,o){var a=Ba(n),f=a.length,l=Ba(t),c=l.length;if(f!=c&&!u)return!1;for(var s=f;s--;){var p=a[s];if(!(u?p in t:Gi.call(t,p)))return!1}for(var h=u;++s<f;){p=a[s];var v=n[p],_=t[p],g=e?e(u?_:v,u?v:_,p):b;if(!(g===b?r(v,_,e,u,i,o):g))return!1;h||(h="constructor"==p)}if(!h){var y=n.constructor,d=t.constructor;if(y!=d&&"constructor"in n&&"constructor"in t&&!("function"==typeof y&&y instanceof y&&"function"==typeof d&&d instanceof d))return!1}return!0}function Nr(n,t,r){var e=Y.callback||di;return e=e===di?wt:e,r?e(n,t,r):e}function Lr(n){for(var t=n.name,r=So[t],e=r?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function Br(n,t,e){var u=Y.indexOf||we;return u=u===we?r:u,n?u(n,t,e):u}function zr(n){for(var t=Gu(n),r=t.length;r--;)t[r][2]=Qr(t[r][1]);return t}function Pr(n,t){var r=null==n?b:n[t];return Wu(r)?r:b}function qr(n,t,r){for(var e=-1,u=r?r.length:0;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=mo(t,n+o);break;case"takeRight":n=yo(n,t-o)}}return{start:n,end:t}}function Dr(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&Gi.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Mr(n){var t=n.constructor;return"function"==typeof t&&t instanceof t||(t=Bi),new t}function Kr(n,t,r){var e=n.constructor;switch(t){case nn:return or(n);case D:case M:return new e(+n);case tn:case rn:case en:case un:case on:case an:case fn:case ln:case cn:var u=n.buffer;return new e(r?or(u):u,n.byteOffset,n.length);case G:case H:return new e(n);case X:var i=new e(n.source,En.exec(n));i.lastIndex=n.lastIndex}return i}function Vr(n,t,r){null==n||Xr(t,n)||(t=fe(t),n=1==t.length?n:Ut(n,Gt(t,0,-1)),t=xe(t));var e=null==n?n:n[t];return null==e?b:e.apply(n,r)}function Yr(n){return null!=n&&Hr(qo(n))}function Gr(n,t){return n="number"==typeof n||Sn.test(n)?+n:-1,t=null==t?Co:t,n>-1&&n%1==0&&t>n}function Jr(n,t,r){if(!Iu(r))return!1;var e=typeof t;if("number"==e?Yr(r)&&Gr(t,r.length):"string"==e&&t in r){var u=r[t];return n===n?n===u:u!==u}return!1}function Xr(n,t){var r=typeof n;if("string"==r&&xn.test(n)||"number"==r)return!0;if(ka(n))return!1;var e=!bn.test(n);return e||null!=t&&n in ae(t)}function Zr(n){var t=Lr(n);if(!(t in Dn.prototype))return!1;var r=Y[t];if(n===r)return!0;var e=Po(r);return!!e&&n===e[0]}function Hr(n){return"number"==typeof n&&n>-1&&n%1==0&&Co>=n}function Qr(n){return n===n&&!Iu(n)}function ne(n,t){var r=n[1],e=t[1],u=r|e,i=C>u,o=e==C&&r==R||e==C&&r==W&&n[7].length<=t[8]||e==(C|W)&&r==R;if(!i&&!o)return n;e&A&&(n[2]=t[2],u|=r&A?0:O);var a=t[3];if(a){var f=n[3];n[3]=f?ar(f,a,t[4]):et(a),n[4]=f?_(n[3],z):et(t[4])}return a=t[5],a&&(f=n[5],n[5]=f?fr(f,a,t[6]):et(a),n[6]=f?_(n[5],z):et(t[6])),a=t[7],a&&(n[7]=et(a)),e&C&&(n[8]=null==n[8]?t[8]:mo(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function te(n,t){n=ae(n);for(var r=-1,e=t.length,u={};++r<e;){var i=t[r];i in n&&(u[i]=n[i])}return u}function re(n,t){var r={};return Ct(n,function(n,e,u){t(n,e,u)&&(r[e]=n)}),r}function ee(n,t){for(var r=n.length,e=mo(t.length,r),u=et(n);e--;){var i=t[e];n[e]=Gr(i,r)?u[i]:b}return n}function ue(n){var t;Y.support;if(!h(n)||Xi.call(n)!=J||!Gi.call(n,"constructor")&&(t=n.constructor,"function"==typeof t&&!(t instanceof t)))return!1;var r;return Ct(n,function(n,t){r=t}),r===b||Gi.call(n,r)}function ie(n){for(var t=Yu(n),r=t.length,e=r&&n.length,u=!!e&&Hr(e)&&(ka(n)||bu(n)),i=-1,o=[];++i<r;){var a=t[i];(u&&Gr(a,e)||Gi.call(n,a))&&o.push(a)}return o}function oe(n){return null==n?[]:Yr(n)?Iu(n)?n:Bi(n):Hu(n)}function ae(n){return Iu(n)?n:Bi(n)}function fe(n){if(ka(n))return n;var t=[];return u(n).replace(An,function(n,r,e,u){t.push(e?u.replace(kn,"$1"):r||n)}),t}function le(n){return n instanceof Dn?n.clone():new Q(n.__wrapped__,n.__chain__,et(n.__actions__))}function ce(n,t,r){t=(r?Jr(n,t,r):null==t)?1:yo(+t||1,1);for(var e=0,u=n?n.length:0,i=-1,o=Ti(to(u/t));u>e;)o[++i]=Gt(n,e,e+=t);return o}function se(n){for(var t=-1,r=n?n.length:0,e=-1,u=[];++t<r;){var i=n[t];i&&(u[++e]=i)}return u}function pe(n,t,r){var e=n?n.length:0;return e?((r?Jr(n,t,r):null==t)&&(t=1),Gt(n,0>t?0:t)):[]}function he(n,t,r){var e=n?n.length:0;return e?((r?Jr(n,t,r):null==t)&&(t=1),t=e-(+t||0),Gt(n,0,0>t?0:t)):[]}function ve(n,t,r){return n&&n.length?tr(n,Nr(t,r,3),!0,!0):[]}function _e(n,t,r){return n&&n.length?tr(n,Nr(t,r,3),!0):[]}function ge(n,t,r,e){var u=n?n.length:0;return u?(r&&"number"!=typeof r&&Jr(n,t,r)&&(r=0,e=u),Rt(n,t,r,e)):[]}function ye(n){return n?n[0]:b}function de(n,t,r){var e=n?n.length:0;return r&&Jr(n,t,r)&&(t=!1),e?Et(n,t):[]}function me(n){var t=n?n.length:0;return t?Et(n,!0):[]}function we(n,t,e){var u=n?n.length:0;if(!u)return-1;if("number"==typeof e)e=0>e?yo(u+e,0):e;else if(e){var i=er(n,t),o=n[i];return(t===t?t===o:o!==o)?i:-1}return r(n,t,e||0)}function be(n){return he(n,1)}function xe(n){var t=n?n.length:0;return t?n[t-1]:b}function Ae(n,t,r){var e=n?n.length:0;if(!e)return-1;var u=e;if("number"==typeof r)u=(0>r?yo(e+r,0):mo(r||0,e-1))+1;else if(r){u=er(n,t,!0)-1;var i=n[u];return(t===t?t===i:i!==i)?u:-1}if(t!==t)return p(n,u,!0);for(;u--;)if(n[u]===t)return u;return-1}function je(){var n=arguments,t=n[0];if(!t||!t.length)return t;for(var r=0,e=Br(),u=n.length;++r<u;)for(var i=0,o=n[r];(i=e(t,o,i))>-1;)lo.call(t,i,1);return t}function Oe(n,t,r){var e=[];if(!n||!n.length)return e;var u=-1,i=[],o=n.length;for(t=Nr(t,r,3);++u<o;){var a=n[u];t(a,u,n)&&(e.push(a),i.push(u))}return Kt(n,i),e}function Re(n){return pe(n,1)}function ke(n,t,r){var e=n?n.length:0;return e?(r&&"number"!=typeof r&&Jr(n,t,r)&&(t=0,r=e),Gt(n,t,r)):[]}function Ie(n,t,r){var e=n?n.length:0;return e?((r?Jr(n,t,r):null==t)&&(t=1),Gt(n,0,0>t?0:t)):[]}function Ee(n,t,r){var e=n?n.length:0;return e?((r?Jr(n,t,r):null==t)&&(t=1),t=e-(+t||0),Gt(n,0>t?0:t)):[]}function Ce(n,t,r){return n&&n.length?tr(n,Nr(t,r,3),!1,!0):[]}function We(n,t,r){return n&&n.length?tr(n,Nr(t,r,3)):[]}function Se(n,t,e,u){var i=n?n.length:0;if(!i)return[];null!=t&&"boolean"!=typeof t&&(u=e,e=Jr(n,t,u)?null:t,t=!1);var o=Nr();return(null!=e||o!==wt)&&(e=o(e,u,3)),t&&Br()==r?g(n,e):Qt(n,e)}function Te(n){if(!n||!n.length)return[];var t=-1,r=0;n=ft(n,function(n){return Yr(n)?(r=yo(n.length,r),!0):void 0});for(var e=Ti(r);++t<r;)e[t]=lt(n,Dt(t));return e}function Ue(n,t,r){var e=n?n.length:0;if(!e)return[];var u=Te(n);return null==t?u:(t=ir(t,r,4),lt(u,function(n){return ct(n,t,b,!0)}))}function $e(){for(var n=-1,t=arguments.length;++n<t;){var r=arguments[n];if(Yr(r))var e=e?At(e,r).concat(At(r,e)):r}return e?Qt(e):[]}function Fe(n,t){var r=-1,e=n?n.length:0,u={};for(!e||t||ka(n[0])||(t=[]);++r<e;){var i=n[r];t?u[i]=t[r]:i&&(u[i[0]]=i[1])}return u}function Ne(n){var t=Y(n);return t.__chain__=!0,t}function Le(n,t,r){return t.call(r,n),n}function Be(n,t,r){return t.call(r,n)}function ze(){return Ne(this)}function Pe(){return new Q(this.value(),this.__chain__)}function qe(n){for(var t,r=this;r instanceof Z;){var e=le(r);t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function De(){var n=this.__wrapped__;return n instanceof Dn?(this.__actions__.length&&(n=new Dn(this)),new Q(n.reverse(),this.__chain__)):this.thru(function(n){return n.reverse()})}function Me(){return this.value()+""}function Ke(){return rr(this.__wrapped__,this.__actions__)}function Ve(n,t,r){var e=ka(n)?ot:jt;return r&&Jr(n,t,r)&&(t=null),("function"!=typeof t||r!==b)&&(t=Nr(t,r,3)),e(n,t)}function Ye(n,t,r){var e=ka(n)?ft:kt;return t=Nr(t,r,3),e(n,t)}function Ge(n,t){return ea(n,Bt(t))}function Je(n,t,r,e){var u=n?qo(n):0;return Hr(u)||(n=Hu(n),u=n.length),u?(r="number"!=typeof r||e&&Jr(t,r,e)?0:0>r?yo(u+r,0):r||0,"string"==typeof n||!ka(n)&&$u(n)?u>r&&n.indexOf(t,r)>-1:Br(n,t,r)>-1):!1}function Xe(n,t,r){var e=ka(n)?lt:Lt;return t=Nr(t,r,3),e(n,t)}function Ze(n,t){return Xe(n,Ri(t))}function He(n,t,r){var e=ka(n)?ft:kt;return t=Nr(t,r,3),e(n,function(n,r,e){return!t(n,r,e)})}function Qe(n,t,r){if(r?Jr(n,t,r):null==t){n=oe(n);var e=n.length;return e>0?n[Vt(0,e-1)]:b}var u=-1,i=zu(n),e=i.length,o=e-1;for(t=mo(0>t?0:+t||0,e);++u<t;){var a=Vt(u,o),f=i[a];i[a]=i[u],i[u]=f}return i.length=t,i}function nu(n){return Qe(n,Oo)}function tu(n){var t=n?qo(n):0;return Hr(t)?t:Ba(n).length}function ru(n,t,r){var e=ka(n)?pt:Jt;return r&&Jr(n,t,r)&&(t=null),("function"!=typeof t||r!==b)&&(t=Nr(t,r,3)),e(n,t)}function eu(n,t,r){if(null==n)return[];r&&Jr(n,t,r)&&(t=null);var e=-1;t=Nr(t,r,3);var u=Lt(n,function(n,r,u){return{criteria:t(n,r,u),index:++e,value:n}});return Xt(u,a)}function uu(n,t,r,e){return null==n?[]:(e&&Jr(t,r,e)&&(r=null),ka(t)||(t=null==t?[]:[t]),ka(r)||(r=null==r?[]:[r]),Zt(n,t,r))}function iu(n,t){return Ye(n,Bt(t))}function ou(n,t){if("function"!=typeof t){if("function"!=typeof n)throw new qi(B);var r=n;n=t,t=r}return n=_o(n=+n)?n:0,function(){return--n<1?t.apply(this,arguments):void 0}}function au(n,t,r){return r&&Jr(n,t,r)&&(t=null),t=n&&null==t?n.length:yo(+t||0,0),Tr(n,C,null,null,null,null,t)}function fu(n,t){var r;if("function"!=typeof t){if("function"!=typeof n)throw new qi(B);var e=n;n=t,t=e}return function(){return--n>0&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}}function lu(n,t,r){function e(){p&&ro(p),f&&ro(f),f=p=h=b}function u(){var r=t-(va()-c);if(0>=r||r>t){f&&ro(f);var e=h;f=p=h=b,e&&(v=va(),l=n.apply(s,a),p||f||(a=s=null))}else p=fo(u,r)}function i(){p&&ro(p),f=p=h=b,(g||_!==t)&&(v=va(),l=n.apply(s,a),p||f||(a=s=null))}function o(){if(a=arguments,c=va(),s=this,h=g&&(p||!y),_===!1)var r=y&&!p;else{f||y||(v=c);var e=_-(c-v),o=0>=e||e>_;o?(f&&(f=ro(f)),v=c,l=n.apply(s,a)):f||(f=fo(i,e))}return o&&p?p=ro(p):p||t===_||(p=fo(u,t)),r&&(o=!0,l=n.apply(s,a)),!o||p||f||(a=s=null),l}var a,f,l,c,s,p,h,v=0,_=!1,g=!0;if("function"!=typeof n)throw new qi(B);if(t=0>t?0:+t||0,r===!0){var y=!0;g=!1}else Iu(r)&&(y=r.leading,_="maxWait"in r&&yo(+r.maxWait||0,t),g="trailing"in r?r.trailing:g);return o.cancel=e,o}function cu(n,t){if("function"!=typeof n||t&&"function"!=typeof t)throw new qi(B);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o),o};return r.cache=new cu.Cache,r}function su(n){if("function"!=typeof n)throw new qi(B);return function(){return!n.apply(this,arguments)}}function pu(n){return fu(2,n)}function hu(n,t){if("function"!=typeof n)throw new qi(B);return t=yo(t===b?n.length-1:+t||0,0),function(){for(var r=arguments,e=-1,u=yo(r.length-t,0),i=Ti(u);++e<u;)i[e]=r[t+e];switch(t){case 0:return n.call(this,i);case 1:return n.call(this,r[0],i);case 2:return n.call(this,r[0],r[1],i)}var o=Ti(t+1);for(e=-1;++e<t;)o[e]=r[e];return o[t]=i,n.apply(this,o)}}function vu(n){if("function"!=typeof n)throw new qi(B);return function(t){return n.apply(this,t)}}function _u(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new qi(B);return r===!1?e=!1:Iu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),qn.leading=e,qn.maxWait=+t,qn.trailing=u,lu(n,t,qn)}function gu(n,t){return t=null==t?wi:t,Tr(t,I,null,[n],[])}function yu(n,t,r,e){return t&&"boolean"!=typeof t&&Jr(n,t,r)?t=!1:"function"==typeof t&&(e=r,r=t,t=!1),"function"==typeof r?bt(n,t,ir(r,e,1)):bt(n,t)}function du(n,t,r){return"function"==typeof t?bt(n,!0,ir(t,r,1)):bt(n,!0)}function mu(n,t){return n>t}function wu(n,t){return n>=t}function bu(n){return h(n)&&Yr(n)&&Xi.call(n)==P}function xu(n){return n===!0||n===!1||h(n)&&Xi.call(n)==D}function Au(n){return h(n)&&Xi.call(n)==M}function ju(n){return!!n&&1===n.nodeType&&h(n)&&Xi.call(n).indexOf("Element")>-1}function Ou(n){return null==n?!0:Yr(n)&&(ka(n)||$u(n)||bu(n)||h(n)&&Ea(n.splice))?!n.length:!Ba(n).length}function Ru(n,t,r,e){r="function"==typeof r?ir(r,e,3):b;var u=r?r(n,t):b;return u===b?$t(n,t,r):!!u}function ku(n){return h(n)&&"string"==typeof n.message&&Xi.call(n)==K}function Iu(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function Eu(n,t,r,e){return r="function"==typeof r?ir(r,e,3):b,Nt(n,zr(t),r)}function Cu(n){return Tu(n)&&n!=+n}function Wu(n){return null==n?!1:Xi.call(n)==V?Hi.test(Yi.call(n)):h(n)&&Wn.test(n)}function Su(n){return null===n}function Tu(n){return"number"==typeof n||h(n)&&Xi.call(n)==G}function Uu(n){return h(n)&&Xi.call(n)==X}function $u(n){return"string"==typeof n||h(n)&&Xi.call(n)==H}function Fu(n){return h(n)&&Hr(n.length)&&!!zn[Xi.call(n)]}function Nu(n){return n===b}function Lu(n,t){return t>n}function Bu(n,t){return t>=n}function zu(n){var t=n?qo(n):0;return Hr(t)?t?et(n):[]:Hu(n)}function Pu(n){return mt(n,Yu(n))}function qu(n,t,r){var e=Uo(n);return r&&Jr(n,t,r)&&(t=null),t?yt(e,t):e}function Du(n){return Tt(n,Yu(n))}function Mu(n,t,r){var e=null==n?b:Ut(n,fe(t),t+"");return e===b?r:e}function Ku(n,t){if(null==n)return!1;var r=Gi.call(n,t);if(!r&&!Xr(t)){if(t=fe(t),n=1==t.length?n:Ut(n,Gt(t,0,-1)),null==n)return!1;t=xe(t),r=Gi.call(n,t)}return r||Hr(n.length)&&Gr(t,n.length)&&(ka(n)||bu(n))}function Vu(n,t,r){r&&Jr(n,t,r)&&(t=null);for(var e=-1,u=Ba(n),i=u.length,o={};++e<i;){var a=u[e],f=n[a];t?Gi.call(o,f)?o[f].push(a):o[f]=[a]:o[f]=a}return o}function Yu(n){if(null==n)return[];Iu(n)||(n=Bi(n));var t=n.length;t=t&&Hr(t)&&(ka(n)||bu(n))&&t||0;for(var r=n.constructor,e=-1,u="function"==typeof r&&r.prototype===n,i=Ti(t),o=t>0;++e<t;)i[e]=e+"";for(var a in n)o&&Gr(a,t)||"constructor"==a&&(u||!Gi.call(n,a))||i.push(a);return i}function Gu(n){n=ae(n);for(var t=-1,r=Ba(n),e=r.length,u=Ti(e);++t<e;){var i=r[t];u[t]=[i,n[i]]}return u}function Ju(n,t,r){var e=null==n?b:n[t];return e===b&&(null==n||Xr(t,n)||(t=fe(t),n=1==t.length?n:Ut(n,Gt(t,0,-1)),e=null==n?b:n[xe(t)]),e=e===b?r:e),Ea(e)?e.call(n):e}function Xu(n,t,r){if(null==n)return n;var e=t+"";t=null!=n[e]||Xr(t,n)?[e]:fe(t);for(var u=-1,i=t.length,o=i-1,a=n;null!=a&&++u<i;){var f=t[u];Iu(a)&&(u==o?a[f]=r:null==a[f]&&(a[f]=Gr(t[u+1])?[]:{})),a=a[f]}return n}function Zu(n,t,r,e){var u=ka(n)||Fu(n);if(t=Nr(t,e,4),null==r)if(u||Iu(n)){var i=n.constructor;r=u?ka(n)?new i:[]:Uo(Ea(i)?i.prototype:null)}else r={};return(u?ut:Wt)(n,function(n,e,u){return t(r,n,e,u)}),r}function Hu(n){return nr(n,Ba(n))}function Qu(n){return nr(n,Yu(n))}function ni(n,t,r){return t=+t||0,"undefined"==typeof r?(r=t,t=0):r=+r||0,n>=mo(t,r)&&n<yo(t,r)}function ti(n,t,r){r&&Jr(n,t,r)&&(t=r=null);var e=null==n,u=null==t;if(null==r&&(u&&"boolean"==typeof n?(r=n,n=1):"boolean"==typeof t&&(r=t,u=!0)),e&&u&&(t=1,u=!1),n=+n||0,u?(t=n,n=0):t=+t||0,r||n%1||t%1){var i=Ao();return mo(n+i*(t-n+io("1e-"+((i+"").length-1))),t)}return Vt(n,t)}function ri(n){return n=u(n),n&&n.charAt(0).toUpperCase()+n.slice(1)}function ei(n){return n=u(n),n&&n.replace(Tn,l).replace(Rn,"")}function ui(n,t,r){n=u(n),t+="";var e=n.length;return r=r===b?e:mo(0>r?0:+r||0,e),r-=t.length,r>=0&&n.indexOf(t,r)==r}function ii(n){return n=u(n),n&&yn.test(n)?n.replace(_n,c):n}function oi(n){return n=u(n),n&&On.test(n)?n.replace(jn,"\\$&"):n}function ai(n,t,r){n=u(n),t=+t;var e=n.length;if(e>=t||!_o(t))return n;var i=(t-e)/2,o=eo(i),a=to(i);return r=Cr("",a,r),r.slice(0,o)+n+r}function fi(n,t,r){return r&&Jr(n,t,r)&&(t=0),xo(n,t)}function li(n,t){
var r="";if(n=u(n),t=+t,1>t||!n||!_o(t))return r;do t%2&&(r+=n),t=eo(t/2),n+=n;while(t);return r}function ci(n,t,r){return n=u(n),r=null==r?0:mo(0>r?0:+r||0,n.length),n.lastIndexOf(t,r)==r}function si(n,t,r){var e=Y.templateSettings;r&&Jr(n,t,r)&&(t=r=null),n=u(n),t=gt(yt({},r||t),e,_t);var i,o,a=gt(yt({},t.imports),e.imports,_t),f=Ba(a),l=nr(a,f),c=0,p=t.interpolate||Un,h="__p += '",v=zi((t.escape||Un).source+"|"+p.source+"|"+(p===wn?In:Un).source+"|"+(t.evaluate||Un).source+"|$","g"),_="//# sourceURL="+("sourceURL"in t?t.sourceURL:"lodash.templateSources["+ ++Bn+"]")+"\n";n.replace(v,function(t,r,e,u,a,f){return e||(e=u),h+=n.slice(c,f).replace($n,s),r&&(i=!0,h+="' +\n__e("+r+") +\n'"),a&&(o=!0,h+="';\n"+a+";\n__p += '"),e&&(h+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),c=f+t.length,t}),h+="';\n";var g=t.variable;g||(h="with (obj) {\n"+h+"\n}\n"),h=(o?h.replace(sn,""):h).replace(pn,"$1").replace(hn,"$1;"),h="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(i?", __e = _.escape":"")+(o?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+h+"return __p\n}";var y=Za(function(){return Fi(f,_+"return "+h).apply(b,l)});if(y.source=h,ku(y))throw y;return y}function pi(n,t,r){var e=n;return(n=u(n))?(r?Jr(e,t,r):null==t)?n.slice(y(n),d(n)+1):(t+="",n.slice(i(n,t),o(n,t)+1)):n}function hi(n,t,r){var e=n;return n=u(n),n?(r?Jr(e,t,r):null==t)?n.slice(y(n)):n.slice(i(n,t+"")):n}function vi(n,t,r){var e=n;return n=u(n),n?(r?Jr(e,t,r):null==t)?n.slice(0,d(n)+1):n.slice(0,o(n,t+"")+1):n}function _i(n,t,r){r&&Jr(n,t,r)&&(t=null);var e=S,i=T;if(null!=t)if(Iu(t)){var o="separator"in t?t.separator:o;e="length"in t?+t.length||0:e,i="omission"in t?u(t.omission):i}else e=+t||0;if(n=u(n),e>=n.length)return n;var a=e-i.length;if(1>a)return i;var f=n.slice(0,a);if(null==o)return f+i;if(Uu(o)){if(n.slice(a).search(o)){var l,c,s=n.slice(0,a);for(o.global||(o=zi(o.source,(En.exec(o)||"")+"g")),o.lastIndex=0;l=o.exec(s);)c=l.index;f=f.slice(0,null==c?a:c)}}else if(n.indexOf(o,a)!=a){var p=f.lastIndexOf(o);p>-1&&(f=f.slice(0,p))}return f+i}function gi(n){return n=u(n),n&&gn.test(n)?n.replace(vn,m):n}function yi(n,t,r){return r&&Jr(n,t,r)&&(t=null),n=u(n),n.match(t||Fn)||[]}function di(n,t,r){return r&&Jr(n,t,r)&&(t=null),h(n)?bi(n):wt(n,t)}function mi(n){return function(){return n}}function wi(n){return n}function bi(n){return Bt(bt(n,!0))}function xi(n,t){return zt(n,bt(t,!0))}function Ai(n,t,r){if(null==r){var e=Iu(t),u=e?Ba(t):null,i=u&&u.length?Tt(t,u):null;(i?i.length:e)||(i=!1,r=t,t=n,n=this)}i||(i=Tt(t,Ba(t)));var o=!0,a=-1,f=Ea(n),l=i.length;r===!1?o=!1:Iu(r)&&"chain"in r&&(o=r.chain);for(;++a<l;){var c=i[a],s=t[c];n[c]=s,f&&(n.prototype[c]=function(t){return function(){var r=this.__chain__;if(o||r){var e=n(this.__wrapped__),u=e.__actions__=et(this.__actions__);return u.push({func:t,args:arguments,thisArg:n}),e.__chain__=r,e}var i=[this.value()];return oo.apply(i,arguments),t.apply(n,i)}}(s))}return n}function ji(){return v._=Zi,this}function Oi(){}function Ri(n){return Xr(n)?Dt(n):Mt(n)}function ki(n){return function(t){return Ut(n,fe(t),t+"")}}function Ii(n,t,r){r&&Jr(n,t,r)&&(t=r=null),n=+n||0,r=null==r?1:+r||0,null==t?(t=n,n=0):t=+t||0;for(var e=-1,u=yo(to((t-n)/(r||1)),0),i=Ti(u);++e<u;)i[e]=n,n+=r;return i}function Ei(n,t,r){if(n=eo(n),1>n||!_o(n))return[];var e=-1,u=Ti(mo(n,Ro));for(t=ir(t,r,1);++e<n;)Ro>e?u[e]=t(e):t(e);return u}function Ci(n){var t=++Ji;return u(n)+t}function Wi(n,t){return(+n||0)+(+t||0)}function Si(n,t,r){r&&Jr(n,t,r)&&(t=null);var e=Nr(),u=null==t;return u&&e===wt||(u=!1,t=e(t,r,3)),u?ht(ka(n)?n:oe(n)):Ht(n,t)}v=v?tt.defaults(nt.Object(),v,tt.pick(nt,Ln)):nt;var Ti=v.Array,Ui=v.Date,$i=v.Error,Fi=v.Function,Ni=v.Math,Li=v.Number,Bi=v.Object,zi=v.RegExp,Pi=v.String,qi=v.TypeError,Di=Ti.prototype,Mi=Bi.prototype,Ki=Pi.prototype,Vi=(Vi=v.window)?Vi.document:null,Yi=Fi.prototype.toString,Gi=Mi.hasOwnProperty,Ji=0,Xi=Mi.toString,Zi=v._,Hi=zi("^"+oi(Yi.call(Gi)).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Qi=Pr(v,"ArrayBuffer"),no=Pr(Qi&&new Qi(0),"slice"),to=Ni.ceil,ro=v.clearTimeout,eo=Ni.floor,uo=Pr(Bi,"getPrototypeOf"),io=v.parseFloat,oo=Di.push,ao=Pr(v,"Set"),fo=v.setTimeout,lo=Di.splice,co=Pr(v,"Uint8Array"),so=Pr(v,"WeakMap"),po=function(){try{var n=Pr(v,"Float64Array"),t=new n(new Qi(10),0,1)&&n}catch(r){}return t||null}(),ho=Pr(Bi,"create"),vo=Pr(Ti,"isArray"),_o=v.isFinite,go=Pr(Bi,"keys"),yo=Ni.max,mo=Ni.min,wo=Pr(Ui,"now"),bo=Pr(Li,"isFinite"),xo=v.parseInt,Ao=Ni.random,jo=Li.NEGATIVE_INFINITY,Oo=Li.POSITIVE_INFINITY,Ro=4294967295,ko=Ro-1,Io=Ro>>>1,Eo=po?po.BYTES_PER_ELEMENT:0,Co=9007199254740991,Wo=so&&new so,So={},To=Y.support={};!function(n){var t=function(){this.x=n},r=[];t.prototype={valueOf:n,y:n};for(var e in new t)r.push(e);try{To.dom=11===Vi.createDocumentFragment().nodeType}catch(u){To.dom=!1}}(1,0),Y.templateSettings={escape:dn,evaluate:mn,interpolate:wn,variable:"",imports:{_:Y}};var Uo=function(){function n(){}return function(t){if(Iu(t)){n.prototype=t;var r=new n;n.prototype=null}return r||{}}}(),$o=sr(Wt),Fo=sr(St,!0),No=pr(),Lo=pr(!0),Bo=Wo?function(n,t){return Wo.set(n,t),n}:wi;no||(or=Qi&&co?function(n){var t=n.byteLength,r=po?eo(t/Eo):0,e=r*Eo,u=new Qi(t);if(r){var i=new po(u,0,r);i.set(new po(n,0,r))}return t!=e&&(i=new co(u,e),i.set(new co(n,e))),u}:mi(null));var zo=ho&&ao?function(n){return new Hn(n)}:mi(null),Po=Wo?function(n){return Wo.get(n)}:Oi,qo=Dt("length"),Do=function(){var n=0,t=0;return function(r,e){var u=va(),i=$-(u-t);if(t=u,i>0){if(++n>=U)return r}else n=0;return Bo(r,e)}}(),Mo=hu(function(n,t){return Yr(n)?At(n,Et(t,!1,!0)):[]}),Ko=mr(),Vo=mr(!0),Yo=hu(function(n){for(var t=n.length,e=t,u=Ti(s),i=Br(),o=i==r,a=[];e--;){var f=n[e]=Yr(f=n[e])?f:[];u[e]=o&&f.length>=120?zo(e&&f):null}var l=n[0],c=-1,s=l?l.length:0,p=u[0];n:for(;++c<s;)if(f=l[c],(p?Qn(p,f):i(a,f,0))<0){for(var e=t;--e;){var h=u[e];if((h?Qn(h,f):i(n[e],f,0))<0)continue n}p&&p.push(f),a.push(f)}return a}),Go=hu(function(t,r){r=Et(r);var e=dt(t,r);return Kt(t,r.sort(n)),e}),Jo=Sr(),Xo=Sr(!0),Zo=hu(function(n){return Qt(Et(n,!1,!0))}),Ho=hu(function(n,t){return Yr(n)?At(n,t):[]}),Qo=hu(Te),na=hu(function(n){var t=n.length,r=t>2?n[t-2]:b,e=t>1?n[t-1]:b;return t>2&&"function"==typeof r?t-=2:(r=t>1&&"function"==typeof e?(--t,e):b,e=b),n.length=t,Ue(n,r,e)}),ta=hu(function(n,t){return dt(n,Et(t))}),ra=lr(function(n,t,r){Gi.call(n,r)?++n[r]:n[r]=1}),ea=dr($o),ua=dr(Fo,!0),ia=xr(ut,$o),oa=xr(it,Fo),aa=lr(function(n,t,r){Gi.call(n,r)?n[r].push(t):n[r]=[t]}),fa=lr(function(n,t,r){n[r]=t}),la=hu(function(n,t,r){var e=-1,u="function"==typeof t,i=Xr(t),o=Yr(n)?Ti(n.length):[];return $o(n,function(n){var a=u?t:i&&null!=n?n[t]:null;o[++e]=a?a.apply(n,r):Vr(n,t,r)}),o}),ca=lr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),sa=Ir(ct,$o),pa=Ir(st,Fo),ha=hu(function(n,t){if(null==n)return[];var r=t[2];return r&&Jr(t[0],t[1],r)&&(t.length=1),Zt(n,Et(t),[])}),va=wo||function(){return(new Ui).getTime()},_a=hu(function(n,t,r){var e=A;if(r.length){var u=_(r,_a.placeholder);e|=I}return Tr(n,e,t,r,u)}),ga=hu(function(n,t){t=t.length?Et(t):Du(n);for(var r=-1,e=t.length;++r<e;){var u=t[r];n[u]=Tr(n[u],A,n)}return n}),ya=hu(function(n,t,r){var e=A|j;if(r.length){var u=_(r,ya.placeholder);e|=I}return Tr(t,e,n,r,u)}),da=gr(R),ma=gr(k),wa=hu(function(n,t){return xt(n,1,t)}),ba=hu(function(n,t,r){return xt(n,t,r)}),xa=br(),Aa=br(!0),ja=kr(I),Oa=kr(E),Ra=hu(function(n,t){return Tr(n,W,null,null,null,Et(t))}),ka=vo||function(n){return h(n)&&Hr(n.length)&&Xi.call(n)==q};To.dom||(ju=function(n){return!!n&&1===n.nodeType&&h(n)&&!Ca(n)});var Ia=bo||function(n){return"number"==typeof n&&_o(n)},Ea=e(/x/)||co&&!e(co)?function(n){return Xi.call(n)==V}:e,Ca=uo?function(n){if(!n||Xi.call(n)!=J)return!1;var t=Pr(n,"valueOf"),r=t&&(r=uo(t))&&uo(r);return r?n==r||uo(n)==r:ue(n)}:ue,Wa=cr(function(n,t,r){return r?gt(n,t,r):yt(n,t)}),Sa=hu(function(n){var t=n[0];return null==t?t:(n.push(vt),Wa.apply(b,n))}),Ta=wr(Wt),Ua=wr(St),$a=Ar(No),Fa=Ar(Lo),Na=jr(Wt),La=jr(St),Ba=go?function(n){var t=null==n?null:n.constructor;return"function"==typeof t&&t.prototype===n||"function"!=typeof n&&Yr(n)?ie(n):Iu(n)?go(n):[]}:ie,za=Or(!0),Pa=Or(),qa=cr(Pt),Da=hu(function(n,t){if(null==n)return{};if("function"!=typeof t[0]){var t=lt(Et(t),Pi);return te(n,At(Yu(n),t))}var r=ir(t[0],t[1],3);return re(n,function(n,t,e){return!r(n,t,e)})}),Ma=hu(function(n,t){return null==n?{}:"function"==typeof t[0]?re(n,ir(t[0],t[1],3)):te(n,Et(t))}),Ka=vr(function(n,t,r){return t=t.toLowerCase(),n+(r?t.charAt(0).toUpperCase()+t.slice(1):t)}),Va=vr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Ya=Rr(),Ga=Rr(!0);8!=xo(Nn+"08")&&(fi=function(n,t,r){return(r?Jr(n,t,r):null==t)?t=0:t&&(t=+t),n=pi(n),xo(n,t||(Cn.test(n)?16:10))});var Ja=vr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Xa=vr(function(n,t,r){return n+(r?" ":"")+(t.charAt(0).toUpperCase()+t.slice(1))}),Za=hu(function(n,t){try{return n.apply(b,t)}catch(r){return ku(r)?r:new $i(r)}}),Ha=hu(function(n,t){return function(r){return Vr(r,n,t)}}),Qa=hu(function(n,t){return function(r){return Vr(n,r,t)}}),nf=yr(mu,jo),tf=yr(Lu,Oo);return Y.prototype=Z.prototype,Q.prototype=Uo(Z.prototype),Q.prototype.constructor=Q,Dn.prototype=Uo(Z.prototype),Dn.prototype.constructor=Dn,Yn.prototype["delete"]=Gn,Yn.prototype.get=Jn,Yn.prototype.has=Xn,Yn.prototype.set=Zn,Hn.prototype.push=rt,cu.Cache=Yn,Y.after=ou,Y.ary=au,Y.assign=Wa,Y.at=ta,Y.before=fu,Y.bind=_a,Y.bindAll=ga,Y.bindKey=ya,Y.callback=di,Y.chain=Ne,Y.chunk=ce,Y.compact=se,Y.constant=mi,Y.countBy=ra,Y.create=qu,Y.curry=da,Y.curryRight=ma,Y.debounce=lu,Y.defaults=Sa,Y.defer=wa,Y.delay=ba,Y.difference=Mo,Y.drop=pe,Y.dropRight=he,Y.dropRightWhile=ve,Y.dropWhile=_e,Y.fill=ge,Y.filter=Ye,Y.flatten=de,Y.flattenDeep=me,Y.flow=xa,Y.flowRight=Aa,Y.forEach=ia,Y.forEachRight=oa,Y.forIn=$a,Y.forInRight=Fa,Y.forOwn=Na,Y.forOwnRight=La,Y.functions=Du,Y.groupBy=aa,Y.indexBy=fa,Y.initial=be,Y.intersection=Yo,Y.invert=Vu,Y.invoke=la,Y.keys=Ba,Y.keysIn=Yu,Y.map=Xe,Y.mapKeys=za,Y.mapValues=Pa,Y.matches=bi,Y.matchesProperty=xi,Y.memoize=cu,Y.merge=qa,Y.method=Ha,Y.methodOf=Qa,Y.mixin=Ai,Y.negate=su,Y.omit=Da,Y.once=pu,Y.pairs=Gu,Y.partial=ja,Y.partialRight=Oa,Y.partition=ca,Y.pick=Ma,Y.pluck=Ze,Y.property=Ri,Y.propertyOf=ki,Y.pull=je,Y.pullAt=Go,Y.range=Ii,Y.rearg=Ra,Y.reject=He,Y.remove=Oe,Y.rest=Re,Y.restParam=hu,Y.set=Xu,Y.shuffle=nu,Y.slice=ke,Y.sortBy=eu,Y.sortByAll=ha,Y.sortByOrder=uu,Y.spread=vu,Y.take=Ie,Y.takeRight=Ee,Y.takeRightWhile=Ce,Y.takeWhile=We,Y.tap=Le,Y.throttle=_u,Y.thru=Be,Y.times=Ei,Y.toArray=zu,Y.toPlainObject=Pu,Y.transform=Zu,Y.union=Zo,Y.uniq=Se,Y.unzip=Te,Y.unzipWith=Ue,Y.values=Hu,Y.valuesIn=Qu,Y.where=iu,Y.without=Ho,Y.wrap=gu,Y.xor=$e,Y.zip=Qo,Y.zipObject=Fe,Y.zipWith=na,Y.backflow=Aa,Y.collect=Xe,Y.compose=Aa,Y.each=ia,Y.eachRight=oa,Y.extend=Wa,Y.iteratee=di,Y.methods=Du,Y.object=Fe,Y.select=Ye,Y.tail=Re,Y.unique=Se,Ai(Y,Y),Y.add=Wi,Y.attempt=Za,Y.camelCase=Ka,Y.capitalize=ri,Y.clone=yu,Y.cloneDeep=du,Y.deburr=ei,Y.endsWith=ui,Y.escape=ii,Y.escapeRegExp=oi,Y.every=Ve,Y.find=ea,Y.findIndex=Ko,Y.findKey=Ta,Y.findLast=ua,Y.findLastIndex=Vo,Y.findLastKey=Ua,Y.findWhere=Ge,Y.first=ye,Y.get=Mu,Y.gt=mu,Y.gte=wu,Y.has=Ku,Y.identity=wi,Y.includes=Je,Y.indexOf=we,Y.inRange=ni,Y.isArguments=bu,Y.isArray=ka,Y.isBoolean=xu,Y.isDate=Au,Y.isElement=ju,Y.isEmpty=Ou,Y.isEqual=Ru,Y.isError=ku,Y.isFinite=Ia,Y.isFunction=Ea,Y.isMatch=Eu,Y.isNaN=Cu,Y.isNative=Wu,Y.isNull=Su,Y.isNumber=Tu,Y.isObject=Iu,Y.isPlainObject=Ca,Y.isRegExp=Uu,Y.isString=$u,Y.isTypedArray=Fu,Y.isUndefined=Nu,Y.kebabCase=Va,Y.last=xe,Y.lastIndexOf=Ae,Y.lt=Lu,Y.lte=Bu,Y.max=nf,Y.min=tf,Y.noConflict=ji,Y.noop=Oi,Y.now=va,Y.pad=ai,Y.padLeft=Ya,Y.padRight=Ga,Y.parseInt=fi,Y.random=ti,Y.reduce=sa,Y.reduceRight=pa,Y.repeat=li,Y.result=Ju,Y.runInContext=w,Y.size=tu,Y.snakeCase=Ja,Y.some=ru,Y.sortedIndex=Jo,Y.sortedLastIndex=Xo,Y.startCase=Xa,Y.startsWith=ci,Y.sum=Si,Y.template=si,Y.trim=pi,Y.trimLeft=hi,Y.trimRight=vi,Y.trunc=_i,Y.unescape=gi,Y.uniqueId=Ci,Y.words=yi,Y.all=Ve,Y.any=ru,Y.contains=Je,Y.eq=Ru,Y.detect=ea,Y.foldl=sa,Y.foldr=pa,Y.head=ye,Y.include=Je,Y.inject=sa,Ai(Y,function(){var n={};return Wt(Y,function(t,r){Y.prototype[r]||(n[r]=t)}),n}(),!1),Y.sample=Qe,Y.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(t){return Qe(t,n)}):Qe(this.value())},Y.VERSION=x,ut(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){Y[n].placeholder=Y}),ut(["dropWhile","filter","map","takeWhile"],function(n,t){var r=t!=L,e=t==F;Dn.prototype[n]=function(n,u){var i=this.__filtered__,o=i&&e?new Dn(this):this.clone(),a=o.__iteratees__||(o.__iteratees__=[]);return a.push({done:!1,count:0,index:0,iteratee:Nr(n,u,1),limit:-1,type:t}),o.__filtered__=i||r,o}}),ut(["drop","take"],function(n,t){var r=n+"While";Dn.prototype[n]=function(r){var e=this.__filtered__,u=e&&!t?this.dropWhile():this.clone();if(r=null==r?1:yo(eo(r)||0,0),e)t?u.__takeCount__=mo(u.__takeCount__,r):xe(u.__iteratees__).limit=r;else{var i=u.__views__||(u.__views__=[]);i.push({size:r,type:n+(u.__dir__<0?"Right":"")})}return u},Dn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()},Dn.prototype[n+"RightWhile"]=function(n,t){return this.reverse()[r](n,t).reverse()}}),ut(["first","last"],function(n,t){var r="take"+(t?"Right":"");Dn.prototype[n]=function(){return this[r](1).value()[0]}}),ut(["initial","rest"],function(n,t){var r="drop"+(t?"":"Right");Dn.prototype[n]=function(){return this[r](1)}}),ut(["pluck","where"],function(n,t){var r=t?"filter":"map",e=t?Bt:Ri;Dn.prototype[n]=function(n){return this[r](e(n))}}),Dn.prototype.compact=function(){return this.filter(wi)},Dn.prototype.reject=function(n,t){return n=Nr(n,t,1),this.filter(function(t){return!n(t)})},Dn.prototype.slice=function(n,t){n=null==n?0:+n||0;var r=this;return 0>n?r=this.takeRight(-n):n&&(r=this.drop(n)),t!==b&&(t=+t||0,r=0>t?r.dropRight(-t):r.take(t-n)),r},Dn.prototype.toArray=function(){return this.drop(0)},Wt(Dn.prototype,function(n,t){var r=Y[t];if(r){var e=/^(?:filter|map|reject)|While$/.test(t),u=/^(?:first|last)$/.test(t);Y.prototype[t]=function(){var t=arguments,i=this.__chain__,o=this.__wrapped__,a=!!this.__actions__.length,f=o instanceof Dn,l=t[0],c=f||ka(o);c&&e&&"function"==typeof l&&1!=l.length&&(f=c=!1);var s=f&&!a;if(u&&!i)return s?n.call(o):r.call(Y,this.value());var p=function(n){var e=[n];return oo.apply(e,t),r.apply(Y,e)};if(c){var h=s?o:new Dn(this),v=n.apply(h,t);if(!u&&(a||v.__actions__)){var _=v.__actions__||(v.__actions__=[]);_.push({func:Be,args:[p],thisArg:Y})}return new Q(v,i)}return this.thru(p)}}}),ut(["concat","join","pop","push","replace","shift","sort","splice","split","unshift"],function(n){var t=(/^(?:replace|split)$/.test(n)?Ki:Di)[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:join|pop|replace|shift)$/.test(n);Y.prototype[n]=function(){var n=arguments;return e&&!this.__chain__?t.apply(this.value(),n):this[r](function(r){return t.apply(r,n)})}}),Wt(Dn.prototype,function(n,t){var r=Y[t];if(r){var e=r.name,u=So[e]||(So[e]=[]);u.push({name:t,func:r})}}),So[Er(null,j).name]=[{name:"wrapper",func:null}],Dn.prototype.clone=Mn,Dn.prototype.reverse=Kn,Dn.prototype.value=Vn,Y.prototype.chain=ze,Y.prototype.commit=Pe,Y.prototype.plant=qe,Y.prototype.reverse=De,Y.prototype.toString=Me,Y.prototype.run=Y.prototype.toJSON=Y.prototype.valueOf=Y.prototype.value=Ke,Y.prototype.collect=Y.prototype.map,Y.prototype.head=Y.prototype.first,Y.prototype.select=Y.prototype.filter,Y.prototype.tail=Y.prototype.rest,Y}var b,x="3.9.3",A=1,j=2,O=4,R=8,k=16,I=32,E=64,C=128,W=256,S=30,T="...",U=150,$=16,F=0,N=1,L=2,B="Expected a function",z="__lodash_placeholder__",P="[object Arguments]",q="[object Array]",D="[object Boolean]",M="[object Date]",K="[object Error]",V="[object Function]",Y="[object Map]",G="[object Number]",J="[object Object]",X="[object RegExp]",Z="[object Set]",H="[object String]",Q="[object WeakMap]",nn="[object ArrayBuffer]",tn="[object Float32Array]",rn="[object Float64Array]",en="[object Int8Array]",un="[object Int16Array]",on="[object Int32Array]",an="[object Uint8Array]",fn="[object Uint8ClampedArray]",ln="[object Uint16Array]",cn="[object Uint32Array]",sn=/\b__p \+= '';/g,pn=/\b(__p \+=) '' \+/g,hn=/(__e\(.*?\)|\b__t\)) \+\n'';/g,vn=/&(?:amp|lt|gt|quot|#39|#96);/g,_n=/[&<>"'`]/g,gn=RegExp(vn.source),yn=RegExp(_n.source),dn=/<%-([\s\S]+?)%>/g,mn=/<%([\s\S]+?)%>/g,wn=/<%=([\s\S]+?)%>/g,bn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,xn=/^\w*$/,An=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,jn=/[.*+?^${}()|[\]\/\\]/g,On=RegExp(jn.source),Rn=/[\u0300-\u036f\ufe20-\ufe23]/g,kn=/\\(\\)?/g,In=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,En=/\w*$/,Cn=/^0[xX]/,Wn=/^\[object .+?Constructor\]$/,Sn=/^\d+$/,Tn=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Un=/($^)/,$n=/['\n\r\u2028\u2029\\]/g,Fn=function(){var n="[A-Z\\xc0-\\xd6\\xd8-\\xde]",t="[a-z\\xdf-\\xf6\\xf8-\\xff]+";return RegExp(n+"+(?="+n+t+")|"+n+"?"+t+"|"+n+"+|[0-9]+","g")}(),Nn=" 	\f \ufeff\n\r\u2028\u2029 ᠎             　",Ln=["Array","ArrayBuffer","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Math","Number","Object","RegExp","Set","String","_","clearTimeout","document","isFinite","parseFloat","parseInt","setTimeout","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","window"],Bn=-1,zn={};zn[tn]=zn[rn]=zn[en]=zn[un]=zn[on]=zn[an]=zn[fn]=zn[ln]=zn[cn]=!0,zn[P]=zn[q]=zn[nn]=zn[D]=zn[M]=zn[K]=zn[V]=zn[Y]=zn[G]=zn[J]=zn[X]=zn[Z]=zn[H]=zn[Q]=!1;var Pn={};Pn[P]=Pn[q]=Pn[nn]=Pn[D]=Pn[M]=Pn[tn]=Pn[rn]=Pn[en]=Pn[un]=Pn[on]=Pn[G]=Pn[J]=Pn[X]=Pn[H]=Pn[an]=Pn[fn]=Pn[ln]=Pn[cn]=!0,Pn[K]=Pn[V]=Pn[Y]=Pn[Z]=Pn[Q]=!1;var qn={leading:!1,maxWait:0,trailing:!1},Dn={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss"},Mn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},Kn={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},Vn={"function":!0,object:!0},Yn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Gn=Vn[typeof exports]&&exports&&!exports.nodeType&&exports,Jn=Vn[typeof module]&&module&&!module.nodeType&&module,Xn=Gn&&Jn&&"object"==typeof global&&global&&global.Object&&global,Zn=Vn[typeof self]&&self&&self.Object&&self,Hn=Vn[typeof window]&&window&&window.Object&&window,Qn=Jn&&Jn.exports===Gn&&Gn,nt=Xn||Hn!==(this&&this.window)&&Hn||Zn||this,tt=w();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(nt._=tt,define(function(){return tt})):Gn&&Jn?Qn?(Jn.exports=tt)._=tt:Gn._=tt:nt._=tt}).call(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
(function (process){
!function(t){"use strict";if("function"==typeof bootstrap)bootstrap("promise",t);else if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeQ=t}else{if("undefined"==typeof window&&"undefined"==typeof self)throw new Error("This environment was not anticipated by Q. Please file a bug.");var n="undefined"!=typeof window?window:self,e=n.Q;n.Q=t(),n.Q.noConflict=function(){return n.Q=e,this}}}(function(){"use strict";function t(t){return function(){return K.apply(t,arguments)}}function n(t){return t===Object(t)}function e(t){return"[object StopIteration]"===et(t)||t instanceof _}function r(t,n){if(V&&n.stack&&"object"==typeof t&&null!==t&&t.stack&&-1===t.stack.indexOf(rt)){for(var e=[],r=n;r;r=r.source)r.stack&&e.unshift(r.stack);e.unshift(t.stack);var i=e.join("\n"+rt+"\n");t.stack=o(i)}}function o(t){for(var n=t.split("\n"),e=[],r=0;r<n.length;++r){var o=n[r];c(o)||i(o)||!o||e.push(o)}return e.join("\n")}function i(t){return-1!==t.indexOf("(module.js:")||-1!==t.indexOf("(node.js:")}function u(t){var n=/at .+ \((.+):(\d+):(?:\d+)\)$/.exec(t);if(n)return[n[1],Number(n[2])];var e=/at ([^ ]+):(\d+):(?:\d+)$/.exec(t);if(e)return[e[1],Number(e[2])];var r=/.*@(.+):(\d+)$/.exec(t);return r?[r[1],Number(r[2])]:void 0}function c(t){var n=u(t);if(!n)return!1;var e=n[0],r=n[1];return e===H&&r>=q&&st>=r}function s(){if(V)try{throw new Error}catch(t){var n=t.stack.split("\n"),e=n[0].indexOf("@")>0?n[1]:n[2],r=u(e);if(!r)return;return H=r[0],r[1]}}function f(t,n,e){return function(){return"undefined"!=typeof console&&"function"==typeof console.warn&&console.warn(n+" is deprecated, use "+e+" instead.",new Error("").stack),t.apply(t,arguments)}}function p(t){return t instanceof h?t:g(t)?O(t):E(t)}function a(){function t(t){n=t,i.source=t,W(e,function(n,e){p.nextTick(function(){t.promiseDispatch.apply(t,e)})},void 0),e=void 0,r=void 0}var n,e=[],r=[],o=Z(a.prototype),i=Z(h.prototype);if(i.promiseDispatch=function(t,o,i){var u=L(arguments);e?(e.push(u),"when"===o&&i[1]&&r.push(i[1])):p.nextTick(function(){n.promiseDispatch.apply(n,u)})},i.valueOf=function(){if(e)return i;var t=v(n);return m(t)&&(n=t),t},i.inspect=function(){return n?n.inspect():{state:"pending"}},p.longStackSupport&&V)try{throw new Error}catch(u){i.stack=u.stack.substring(u.stack.indexOf("\n")+1)}return o.promise=i,o.resolve=function(e){n||t(p(e))},o.fulfill=function(e){n||t(E(e))},o.reject=function(e){n||t(R(e))},o.notify=function(t){n||W(r,function(n,e){p.nextTick(function(){e(t)})},void 0)},o}function l(t){if("function"!=typeof t)throw new TypeError("resolver must be a function.");var n=a();try{t(n.resolve,n.reject,n.notify)}catch(e){n.reject(e)}return n.promise}function d(t){return l(function(n,e){for(var r=0,o=t.length;o>r;r++)p(t[r]).then(n,e)})}function h(t,n,e){void 0===n&&(n=function(t){return R(new Error("Promise does not support operation: "+t))}),void 0===e&&(e=function(){return{state:"unknown"}});var r=Z(h.prototype);if(r.promiseDispatch=function(e,o,i){var u;try{u=t[o]?t[o].apply(r,i):n.call(r,o,i)}catch(c){u=R(c)}e&&e(u)},r.inspect=e,e){var o=e();"rejected"===o.state&&(r.exception=o.reason),r.valueOf=function(){var t=e();return"pending"===t.state||"rejected"===t.state?r:t.value}}return r}function y(t,n,e,r){return p(t).then(n,e,r)}function v(t){if(m(t)){var n=t.inspect();if("fulfilled"===n.state)return n.value}return t}function m(t){return t instanceof h}function g(t){return n(t)&&"function"==typeof t.then}function k(t){return m(t)&&"pending"===t.inspect().state}function j(t){return!m(t)||"fulfilled"===t.inspect().state}function w(t){return m(t)&&"rejected"===t.inspect().state}function b(){ot.length=0,it.length=0,ct||(ct=!0)}function x(t,n){ct&&("object"==typeof process&&"function"==typeof process.emit&&p.nextTick.runAfter(function(){-1!==X(it,t)&&(process.emit("unhandledRejection",n,t),ut.push(t))}),it.push(t),n&&"undefined"!=typeof n.stack?ot.push(n.stack):ot.push("(no stack) "+n))}function T(t){if(ct){var n=X(it,t);-1!==n&&("object"==typeof process&&"function"==typeof process.emit&&p.nextTick.runAfter(function(){var e=X(ut,t);-1!==e&&(process.emit("rejectionHandled",ot[n],t),ut.splice(e,1))}),it.splice(n,1),ot.splice(n,1))}}function R(t){var n=h({when:function(n){return n&&T(this),n?n(t):this}},function(){return this},function(){return{state:"rejected",reason:t}});return x(n,t),n}function E(t){return h({when:function(){return t},get:function(n){return t[n]},set:function(n,e){t[n]=e},"delete":function(n){delete t[n]},post:function(n,e){return null===n||void 0===n?t.apply(void 0,e):t[n].apply(t,e)},apply:function(n,e){return t.apply(n,e)},keys:function(){return nt(t)}},void 0,function(){return{state:"fulfilled",value:t}})}function O(t){var n=a();return p.nextTick(function(){try{t.then(n.resolve,n.reject,n.notify)}catch(e){n.reject(e)}}),n.promise}function S(t){return h({isDef:function(){}},function(n,e){return A(t,n,e)},function(){return p(t).inspect()})}function N(t,n,e){return p(t).spread(n,e)}function D(t){return function(){function n(t,n){var u;if("undefined"==typeof StopIteration){try{u=r[t](n)}catch(c){return R(c)}return u.done?p(u.value):y(u.value,o,i)}try{u=r[t](n)}catch(c){return e(c)?p(c.value):R(c)}return y(u,o,i)}var r=t.apply(this,arguments),o=n.bind(n,"next"),i=n.bind(n,"throw");return o()}}function P(t){p.done(p.async(t)())}function C(t){throw new _(t)}function Q(t){return function(){return N([this,I(arguments)],function(n,e){return t.apply(n,e)})}}function A(t,n,e){return p(t).dispatch(n,e)}function I(t){return y(t,function(t){var n=0,e=a();return W(t,function(r,o,i){var u;m(o)&&"fulfilled"===(u=o.inspect()).state?t[i]=u.value:(++n,y(o,function(r){t[i]=r,0===--n&&e.resolve(t)},e.reject,function(t){e.notify({index:i,value:t})}))},void 0),0===n&&e.resolve(t),e.promise})}function U(t){if(0===t.length)return p.resolve();var n=p.defer(),e=0;return W(t,function(r,o,i){function u(t){n.resolve(t)}function c(){e--,0===e&&n.reject(new Error("Can't get fulfillment value from any promise, all promises were rejected."))}function s(t){n.notify({index:i,value:t})}var f=t[i];e++,y(f,u,c,s)},void 0),n.promise}function F(t){return y(t,function(t){return t=Y(t,p),y(I(Y(t,function(t){return y(t,z,z)})),function(){return t})})}function M(t){return p(t).allSettled()}function B(t,n){return p(t).then(void 0,void 0,n)}function $(t,n){return p(t).nodeify(n)}var V=!1;try{throw new Error}catch(G){V=!!G.stack}var H,_,q=s(),z=function(){},J=function(){function t(){for(var t,r;e.next;)e=e.next,t=e.task,e.task=void 0,r=e.domain,r&&(e.domain=void 0,r.enter()),n(t,r);for(;c.length;)t=c.pop(),n(t);o=!1}function n(n,e){try{n()}catch(r){if(u)throw e&&e.exit(),setTimeout(t,0),e&&e.enter(),r;setTimeout(function(){throw r},0)}e&&e.exit()}var e={task:void 0,next:null},r=e,o=!1,i=void 0,u=!1,c=[];if(J=function(t){r=r.next={task:t,domain:u&&process.domain,next:null},o||(o=!0,i())},"object"==typeof process&&"[object process]"===process.toString()&&process.nextTick)u=!0,i=function(){process.nextTick(t)};else if("function"==typeof setImmediate)i="undefined"!=typeof window?setImmediate.bind(window,t):function(){setImmediate(t)};else if("undefined"!=typeof MessageChannel){var s=new MessageChannel;s.port1.onmessage=function(){i=f,s.port1.onmessage=t,t()};var f=function(){s.port2.postMessage(0)};i=function(){setTimeout(t,0),f()}}else i=function(){setTimeout(t,0)};return J.runAfter=function(t){c.push(t),o||(o=!0,i())},J}(),K=Function.call,L=t(Array.prototype.slice),W=t(Array.prototype.reduce||function(t,n){var e=0,r=this.length;if(1===arguments.length)for(;;){if(e in this){n=this[e++];break}if(++e>=r)throw new TypeError}for(;r>e;e++)e in this&&(n=t(n,this[e],e));return n}),X=t(Array.prototype.indexOf||function(t){for(var n=0;n<this.length;n++)if(this[n]===t)return n;return-1}),Y=t(Array.prototype.map||function(t,n){var e=this,r=[];return W(e,function(o,i,u){r.push(t.call(n,i,u,e))},void 0),r}),Z=Object.create||function(t){function n(){}return n.prototype=t,new n},tt=t(Object.prototype.hasOwnProperty),nt=Object.keys||function(t){var n=[];for(var e in t)tt(t,e)&&n.push(e);return n},et=t(Object.prototype.toString);_="undefined"!=typeof ReturnValue?ReturnValue:function(t){this.value=t};var rt="From previous event:";p.resolve=p,p.nextTick=J,p.longStackSupport=!1,"object"==typeof process&&process&&process.env&&process.env.Q_DEBUG&&(p.longStackSupport=!0),p.defer=a,a.prototype.makeNodeResolver=function(){var t=this;return function(n,e){n?t.reject(n):arguments.length>2?t.resolve(L(arguments,1)):t.resolve(e)}},p.Promise=l,p.promise=l,l.race=d,l.all=I,l.reject=R,l.resolve=p,p.passByCopy=function(t){return t},h.prototype.passByCopy=function(){return this},p.join=function(t,n){return p(t).join(n)},h.prototype.join=function(t){return p([this,t]).spread(function(t,n){if(t===n)return t;throw new Error("Can't join: not the same: "+t+" "+n)})},p.race=d,h.prototype.race=function(){return this.then(p.race)},p.makePromise=h,h.prototype.toString=function(){return"[object Promise]"},h.prototype.then=function(t,n,e){function o(n){try{return"function"==typeof t?t(n):n}catch(e){return R(e)}}function i(t){if("function"==typeof n){r(t,c);try{return n(t)}catch(e){return R(e)}}return R(t)}function u(t){return"function"==typeof e?e(t):t}var c=this,s=a(),f=!1;return p.nextTick(function(){c.promiseDispatch(function(t){f||(f=!0,s.resolve(o(t)))},"when",[function(t){f||(f=!0,s.resolve(i(t)))}])}),c.promiseDispatch(void 0,"when",[void 0,function(t){var n,e=!1;try{n=u(t)}catch(r){if(e=!0,!p.onerror)throw r;p.onerror(r)}e||s.notify(n)}]),s.promise},p.tap=function(t,n){return p(t).tap(n)},h.prototype.tap=function(t){return t=p(t),this.then(function(n){return t.fcall(n).thenResolve(n)})},p.when=y,h.prototype.thenResolve=function(t){return this.then(function(){return t})},p.thenResolve=function(t,n){return p(t).thenResolve(n)},h.prototype.thenReject=function(t){return this.then(function(){throw t})},p.thenReject=function(t,n){return p(t).thenReject(n)},p.nearer=v,p.isPromise=m,p.isPromiseAlike=g,p.isPending=k,h.prototype.isPending=function(){return"pending"===this.inspect().state},p.isFulfilled=j,h.prototype.isFulfilled=function(){return"fulfilled"===this.inspect().state},p.isRejected=w,h.prototype.isRejected=function(){return"rejected"===this.inspect().state};var ot=[],it=[],ut=[],ct=!0;p.resetUnhandledRejections=b,p.getUnhandledReasons=function(){return ot.slice()},p.stopUnhandledRejectionTracking=function(){b(),ct=!1},b(),p.reject=R,p.fulfill=E,p.master=S,p.spread=N,h.prototype.spread=function(t,n){return this.all().then(function(n){return t.apply(void 0,n)},n)},p.async=D,p.spawn=P,p["return"]=C,p.promised=Q,p.dispatch=A,h.prototype.dispatch=function(t,n){var e=this,r=a();return p.nextTick(function(){e.promiseDispatch(r.resolve,t,n)}),r.promise},p.get=function(t,n){return p(t).dispatch("get",[n])},h.prototype.get=function(t){return this.dispatch("get",[t])},p.set=function(t,n,e){return p(t).dispatch("set",[n,e])},h.prototype.set=function(t,n){return this.dispatch("set",[t,n])},p.del=p["delete"]=function(t,n){return p(t).dispatch("delete",[n])},h.prototype.del=h.prototype["delete"]=function(t){return this.dispatch("delete",[t])},p.mapply=p.post=function(t,n,e){return p(t).dispatch("post",[n,e])},h.prototype.mapply=h.prototype.post=function(t,n){return this.dispatch("post",[t,n])},p.send=p.mcall=p.invoke=function(t,n){return p(t).dispatch("post",[n,L(arguments,2)])},h.prototype.send=h.prototype.mcall=h.prototype.invoke=function(t){return this.dispatch("post",[t,L(arguments,1)])},p.fapply=function(t,n){return p(t).dispatch("apply",[void 0,n])},h.prototype.fapply=function(t){return this.dispatch("apply",[void 0,t])},p["try"]=p.fcall=function(t){return p(t).dispatch("apply",[void 0,L(arguments,1)])},h.prototype.fcall=function(){return this.dispatch("apply",[void 0,L(arguments)])},p.fbind=function(t){var n=p(t),e=L(arguments,1);return function(){return n.dispatch("apply",[this,e.concat(L(arguments))])}},h.prototype.fbind=function(){var t=this,n=L(arguments);return function(){return t.dispatch("apply",[this,n.concat(L(arguments))])}},p.keys=function(t){return p(t).dispatch("keys",[])},h.prototype.keys=function(){return this.dispatch("keys",[])},p.all=I,h.prototype.all=function(){return I(this)},p.any=U,h.prototype.any=function(){return U(this)},p.allResolved=f(F,"allResolved","allSettled"),h.prototype.allResolved=function(){return F(this)},p.allSettled=M,h.prototype.allSettled=function(){return this.then(function(t){return I(Y(t,function(t){function n(){return t.inspect()}return t=p(t),t.then(n,n)}))})},p.fail=p["catch"]=function(t,n){return p(t).then(void 0,n)},h.prototype.fail=h.prototype["catch"]=function(t){return this.then(void 0,t)},p.progress=B,h.prototype.progress=function(t){return this.then(void 0,void 0,t)},p.fin=p["finally"]=function(t,n){return p(t)["finally"](n)},h.prototype.fin=h.prototype["finally"]=function(t){return t=p(t),this.then(function(n){return t.fcall().then(function(){return n})},function(n){return t.fcall().then(function(){throw n})})},p.done=function(t,n,e,r){return p(t).done(n,e,r)},h.prototype.done=function(t,n,e){var o=function(t){p.nextTick(function(){if(r(t,i),!p.onerror)throw t;p.onerror(t)})},i=t||n||e?this.then(t,n,e):this;"object"==typeof process&&process&&process.domain&&(o=process.domain.bind(o)),i.then(void 0,o)},p.timeout=function(t,n,e){return p(t).timeout(n,e)},h.prototype.timeout=function(t,n){var e=a(),r=setTimeout(function(){n&&"string"!=typeof n||(n=new Error(n||"Timed out after "+t+" ms"),n.code="ETIMEDOUT"),e.reject(n)},t);return this.then(function(t){clearTimeout(r),e.resolve(t)},function(t){clearTimeout(r),e.reject(t)},e.notify),e.promise},p.delay=function(t,n){return void 0===n&&(n=t,t=void 0),p(t).delay(n)},h.prototype.delay=function(t){return this.then(function(n){var e=a();return setTimeout(function(){e.resolve(n)},t),e.promise})},p.nfapply=function(t,n){return p(t).nfapply(n)},h.prototype.nfapply=function(t){var n=a(),e=L(t);return e.push(n.makeNodeResolver()),this.fapply(e).fail(n.reject),n.promise},p.nfcall=function(t){var n=L(arguments,1);return p(t).nfapply(n)},h.prototype.nfcall=function(){var t=L(arguments),n=a();return t.push(n.makeNodeResolver()),this.fapply(t).fail(n.reject),n.promise},p.nfbind=p.denodeify=function(t){var n=L(arguments,1);return function(){var e=n.concat(L(arguments)),r=a();return e.push(r.makeNodeResolver()),p(t).fapply(e).fail(r.reject),r.promise}},h.prototype.nfbind=h.prototype.denodeify=function(){var t=L(arguments);return t.unshift(this),p.denodeify.apply(void 0,t)},p.nbind=function(t,n){var e=L(arguments,2);return function(){function r(){return t.apply(n,arguments)}var o=e.concat(L(arguments)),i=a();return o.push(i.makeNodeResolver()),p(r).fapply(o).fail(i.reject),i.promise}},h.prototype.nbind=function(){var t=L(arguments,0);return t.unshift(this),p.nbind.apply(void 0,t)},p.nmapply=p.npost=function(t,n,e){return p(t).npost(n,e)},h.prototype.nmapply=h.prototype.npost=function(t,n){var e=L(n||[]),r=a();return e.push(r.makeNodeResolver()),this.dispatch("post",[t,e]).fail(r.reject),r.promise},p.nsend=p.nmcall=p.ninvoke=function(t,n){var e=L(arguments,2),r=a();return e.push(r.makeNodeResolver()),p(t).dispatch("post",[n,e]).fail(r.reject),r.promise},h.prototype.nsend=h.prototype.nmcall=h.prototype.ninvoke=function(t){var n=L(arguments,1),e=a();return n.push(e.makeNodeResolver()),this.dispatch("post",[t,n]).fail(e.reject),e.promise},p.nodeify=$,h.prototype.nodeify=function(t){return t?void this.then(function(n){p.nextTick(function(){t(null,n)})},function(n){p.nextTick(function(){t(n)})}):this},p.noConflict=function(){throw new Error("Q.noConflict only works when Q is used as a global")};var st=s();return p});
}).call(this,require('_process'))

},{"_process":1}]},{},[7])(7)
});


//# sourceMappingURL=expandjs.min.map</script><script>
    Polymer.MatPalette = {

        /**
         * Returns the palette's RGB value.
         *
         * @method _getColor
         * @param {string} palette
         * @returns {string}
         * @private
         */
        _getColor: function (palette) {
            return this.palettes.light[palette] || this.palettes.dark[palette] || null;
        },

        /**
         * Returns the palette's foreground.
         *
         * @method _getForeground
         * @param {string} [palette = "light"]
         * @param {boolean} [inverse = false]
         * @returns {string}
         * @private
         */
        _getForeground: function (palette, inverse) {
            var result = palette && (palette === 'dark' || this.palettes.dark[palette]) ? 'light' : 'dark';
            return inverse ? (result === 'light' ? 'dark' : 'light') : result;
        },

        /*********************************************************************/

        /**
         * The list of material palettes.
         *
         * @property palettes
         * @type Object
         * @readonly
         */
        palettes: {
            light: {
                'amber': '#FFC107',
                'amber-100': '#FFECB3',
                'amber-200': '#FFE082',
                'amber-300': '#FFD54F',
                'amber-400': '#FFCA28',
                'amber-50': '#FFF8E1',
                'amber-500': '#FFC107',
                'amber-600': '#FFB300',
                'amber-700': '#FFA000',
                'amber-800': '#FF8F00',
                'amber-900': '#FF6F00',
                'amber-a100': '#FFE57F',
                'amber-a200': '#FFD740',
                'amber-a400': '#FFC400',
                'amber-a700': '#FFAB00',
                'blue-100': '#BBDEFB',
                'blue-200': '#90CAF9',
                'blue-300': '#64B5F6',
                'blue-400': '#42A5F5',
                'blue-50': '#E3F2FD',
                'blue-a100': '#82B1FF',
                'blue-grey-100': '#CFD8DC',
                'blue-grey-200': '#B0BEC5',
                'blue-grey-300': '#90A4AE',
                'blue-grey-50': '#ECEFF1',
                'brown-100': '#D7CCC8',
                'brown-200': '#BCAAA4',
                'brown-50': '#EFEBE9',
                'cyan-100': '#B2EBF2',
                'cyan-200': '#80DEEA',
                'cyan-300': '#4DD0E1',
                'cyan-400': '#26C6DA',
                'cyan-50': '#E0F7FA',
                'cyan-a100': '#84FFFF',
                'cyan-a200': '#18FFFF',
                'cyan-a400': '#00E5FF',
                'cyan-a700': '#00B8D4',
                'deep-orange-100': '#FFCCBC',
                'deep-orange-200': '#FFAB91',
                'deep-orange-300': '#FF8A65',
                'deep-orange-400': '#FF7043',
                'deep-orange-50': '#FBE9E7',
                'deep-orange-a100': '#FF9E80',
                'deep-orange-a200': '#FF6E40',
                'deep-purple-100': '#D1C4E9',
                'deep-purple-200': '#B39DDB',
                'deep-purple-50': '#EDE7F6',
                'deep-purple-a100': '#B388FF',
                'green-100': '#C8E6C9',
                'green-200': '#A5D6A7',
                'green-300': '#81C784',
                'green-400': '#66BB6A',
                'green-50': '#E8F5E9',
                'green-a100': '#B9F6CA',
                'green-a200': '#69F0AE',
                'green-a400': '#00E676',
                'green-a700': '#00C853',
                'grey': '#9E9E9E',
                'grey-100': '#F5F5F5',
                'grey-200': '#EEEEEE',
                'grey-300': '#E0E0E0',
                'grey-400': '#BDBDBD',
                'grey-50': '#FAFAFA',
                'grey-500': '#9E9E9E',
                'indigo-100': '#C5CAE9',
                'indigo-200': '#9FA8DA',
                'indigo-50': '#E8EAF6',
                'indigo-a100': '#8C9EFF',
                'light-blue-100': '#B3E5FC',
                'light-blue-200': '#81D4FA',
                'light-blue-300': '#4FC3F7',
                'light-blue-400': '#29B6F6',
                'light-blue-50': '#E1F5FE',
                'light-blue-a100': '#80D8FF',
                'light-blue-a200': '#40C4FF',
                'light-blue-a400': '#00B0FF',
                'light-green': '#8BC34A',
                'light-green-100': '#DCEDC8',
                'light-green-200': '#C5E1A5',
                'light-green-300': '#AED581',
                'light-green-400': '#9CCC65',
                'light-green-50': '#F1F8E9',
                'light-green-500': '#8BC34A',
                'light-green-600': '#7CB342',
                'light-green-700': '#689F38',
                'light-green-a100': '#CCFF90',
                'light-green-a200': '#B2FF59',
                'light-green-a400': '#76FF03',
                'light-green-a700': '#64DD17',
                'lime': '#CDDC39',
                'lime-100': '#F0F4C3',
                'lime-200': '#E6EE9C',
                'lime-300': '#DCE775',
                'lime-400': '#D4E157',
                'lime-50': '#F9FBE7',
                'lime-500': '#CDDC39',
                'lime-600': '#C0CA33',
                'lime-700': '#AFB42B',
                'lime-800': '#9E9D24',
                'lime-a100': '#F4FF81',
                'lime-a200': '#EEFF41',
                'lime-a400': '#C6FF00',
                'lime-a700': '#AEEA00',
                'orange': '#FF9800',
                'orange-100': '#FFE0B2',
                'orange-200': '#FFCC80',
                'orange-300': '#FFB74D',
                'orange-400': '#FFA726',
                'orange-50': '#FFF3E0',
                'orange-500': '#FF9800',
                'orange-600': '#FB8C00',
                'orange-700': '#F57C00',
                'orange-a100': '#FFD180',
                'orange-a200': '#FFAB40',
                'orange-a400': '#FF9100',
                'orange-a700': '#FF6D00',
                'pink-100': '#F8BBD0',
                'pink-200': '#F48FB1',
                'pink-300': '#F06292',
                'pink-400': '#EC407A',
                'pink-50': '#FCE4EC',
                'pink-a100': '#FF80AB',
                'purple-100': '#E1BEE7',
                'purple-200': '#CE93D8',
                'purple-50': '#F3E5F5',
                'purple-a100': '#EA80FC',
                'red-100': '#FFCDD2',
                'red-200': '#EF9A9A',
                'red-300': '#E57373',
                'red-400': '#EF5350',
                'red-50': '#FFEBEE',
                'red-a100': '#FF8A80',
                'teal-100': '#B2DFDB',
                'teal-200': '#80CBC4',
                'teal-300': '#4DB6AC',
                'teal-400': '#26A69A',
                'teal-50': '#E0F2F1',
                'teal-a100': '#A7FFEB',
                'teal-a200': '#64FFDA',
                'teal-a400': '#1DE9B6',
                'teal-a700': '#00BFA5',
                'white': '#FFFFFF',
                'yellow': '#FFEB3B',
                'yellow-100': '#FFF9C4',
                'yellow-200': '#FFF59D',
                'yellow-300': '#FFF176',
                'yellow-400': '#FFEE58',
                'yellow-50': '#FFFDE7',
                'yellow-500': '#FFEB3B',
                'yellow-600': '#FDD835',
                'yellow-700': '#FBC02D',
                'yellow-800': '#F9A825',
                'yellow-900': '#F57F17',
                'yellow-a100': '#FFFF8D',
                'yellow-a200': '#FFFF00',
                'yellow-a400': '#FFEA00',
                'yellow-a700': '#FFD600'
            },
            dark: {
                'black': '#000000',
                'blue': '#2196F3',
                'blue-500': '#2196F3',
                'blue-600': '#1E88E5',
                'blue-700': '#1976D2',
                'blue-800': '#1565C0',
                'blue-900': '#0D47A1',
                'blue-a200': '#448AFF',
                'blue-a400': '#2979FF',
                'blue-a700': '#2962FF',
                'blue-grey': '#607D8B',
                'blue-grey-400': '#78909C',
                'blue-grey-500': '#607D8B',
                'blue-grey-600': '#546E7A',
                'blue-grey-700': '#455A64',
                'blue-grey-800': '#37474F',
                'blue-grey-900': '#263238',
                'brown': '#795548',
                'brown-300': '#A1887F',
                'brown-400': '#8D6E63',
                'brown-500': '#795548',
                'brown-600': '#6D4C41',
                'brown-700': '#5D4037',
                'brown-800': '#4E342E',
                'brown-900': '#3E2723',
                'cyan': '#00BCD4',
                'cyan-500': '#00BCD4',
                'cyan-600': '#00ACC1',
                'cyan-700': '#0097A7',
                'cyan-800': '#00838F',
                'cyan-900': '#006064',
                'deep-orange': '#FF5722',
                'deep-orange-500': '#FF5722',
                'deep-orange-600': '#F4511E',
                'deep-orange-700': '#E64A19',
                'deep-orange-800': '#D84315',
                'deep-orange-900': '#BF360C',
                'deep-orange-a400': '#FF3D00',
                'deep-orange-a700': '#DD2C00',
                'deep-purple': '#673AB7',
                'deep-purple-300': '#9575CD',
                'deep-purple-400': '#7E57C2',
                'deep-purple-500': '#673AB7',
                'deep-purple-600': '#5E35B1',
                'deep-purple-700': '#512DA8',
                'deep-purple-800': '#4527A0',
                'deep-purple-900': '#311B92',
                'deep-purple-a200': '#7C4DFF',
                'deep-purple-a400': '#651FFF',
                'deep-purple-a700': '#6200EA',
                'green': '#4CAF50',
                'green-500': '#4CAF50',
                'green-600': '#43A047',
                'green-700': '#388E3C',
                'green-800': '#2E7D32',
                'green-900': '#1B5E20',
                'grey-600': '#757575',
                'grey-700': '#616161',
                'grey-800': '#424242',
                'grey-900': '#212121',
                'indigo': '#3F51B5',
                'indigo-300': '#7986CB',
                'indigo-400': '#5C6BC0',
                'indigo-500': '#3F51B5',
                'indigo-600': '#3949AB',
                'indigo-700': '#303F9F',
                'indigo-800': '#283593',
                'indigo-900': '#1A237E',
                'indigo-a200': '#536DFE',
                'indigo-a400': '#3D5AFE',
                'indigo-a700': '#304FFE',
                'light-blue': '#03A9F4',
                'light-blue-500': '#03A9F4',
                'light-blue-600': '#039BE5',
                'light-blue-700': '#0288D1',
                'light-blue-800': '#0277BD',
                'light-blue-900': '#01579B',
                'light-blue-a700': '#0091EA',
                'light-green-800': '#558B2F',
                'light-green-900': '#33691E',
                'lime-900': '#827717',
                'orange-800': '#EF6C00',
                'orange-900': '#E65100',
                'pink': '#E91E63',
                'pink-500': '#E91E63',
                'pink-600': '#D81B60',
                'pink-700': '#C2185B',
                'pink-800': '#AD1457',
                'pink-900': '#880E4F',
                'pink-a200': '#FF4081',
                'pink-a400': '#F50057',
                'pink-a700': '#C51162',
                'purple': '#9C27B0',
                'purple-300': '#BA68C8',
                'purple-400': '#AB47BC',
                'purple-500': '#9C27B0',
                'purple-600': '#8E24AA',
                'purple-700': '#7B1FA2',
                'purple-800': '#6A1B9A',
                'purple-900': '#4A148C',
                'purple-a200': '#E040FB',
                'purple-a400': '#D500F9',
                'purple-a700': '#AA00FF',
                'red': '#F44336',
                'red-500': '#F44336',
                'red-600': '#E53935',
                'red-700': '#D32F2F',
                'red-800': '#C62828',
                'red-900': '#B71C1C',
                'red-a200': '#FF5252',
                'red-a400': '#FF1744',
                'red-a700': '#D50000',
                'teal': '#009688',
                'teal-500': '#009688',
                'teal-600': '#00897B',
                'teal-700': '#00796B',
                'teal-800': '#00695C',
                'teal-900': '#004D40'
            }
        }
    };
</script><style is="custom-style">
    :root {

        /* CAPTION */

        --mat-font-caption: {
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 0.02em;
            line-height: 14px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* BODY */

        --mat-font-body: {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-body2: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 24px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* MENU */

        --mat-font-menu: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* BUTTON */

        --mat-font-button: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            text-transform: uppercase;
            white-space: nowrap;
        };

        /* SUBHEAD */

        --mat-font-subhead: {
            font-size: 16px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 24px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-subhead2: {
            font-size: 16px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 28px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* TITLE */

        --mat-font-title: {
            font-size: 20px;
            font-weight: 500;
            letter-spacing: 0.005em;
            line-height: 24px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* HEADLINE */

        --mat-font-headline: {
            font-size: 24px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 32px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* DISPLAY */

        --mat-font-display: {
            font-size: 34px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 40px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-display2: {
            font-size: 45px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 48px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-display3: {
            font-size: 56px;
            font-weight: 400;
            letter-spacing: -0.005em;
            line-height: 68px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        --mat-font-display4: {
            font-size: 112px;
            font-weight: 300;
            letter-spacing: -0.01em;
            line-height: 134px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

    }

    /* DEFAULT */

    html {
        background: hsla(0, 0%, 93%, 1);
        color: hsla(0, 0%, 0%, 0.87);
        font-family: RobotoDraft, Roboto, sans-serif;
        font-size: 16px;
        -webkit-font-smoothing: antialiased;
        font-weight: 400;
        letter-spacing: 0.01em;
        line-height: 24px;
        text-overflow: clip;
        text-rendering: optimizeLegibility;
        white-space: normal;
    }

    /* ANCHORS */

    html /deep/ a {
        color: inherit;
    }

    /* FONTS */

    html /deep/ [font-type="caption"] { @apply(--mat-font-caption); }
    html /deep/ [font-type="body"] { @apply(--mat-font-body); }
    html /deep/ [font-type="body2"] { @apply(--mat-font-body2); }
    html /deep/ [font-type="menu"] { @apply(--mat-font-menu); }
    html /deep/ [font-type="subhead"] { @apply(--mat-font-subhead); }
    html /deep/ [font-type="subhead2"] { @apply(--mat-font-subhead2); }
    html /deep/ [font-type="title"] { @apply(--mat-font-title); }
    html /deep/ [font-type="headline"] { @apply(--mat-font-headline); }
    html /deep/ [font-type="display"] { @apply(--mat-font-display); }
    html /deep/ [font-type="display2"] { @apply(--mat-font-display2); }
    html /deep/ [font-type="display3"] { @apply(--mat-font-display3); }
    html /deep/ [font-type="display4"] { @apply(--mat-font-display4); }

</style><script>
    Polymer.XPSharedBehavior = {

        /**
         * Share `value` with others.
         *
         * @method share
         * @param {string} key
         * @param {*} value
         * @returns {Element}
         */
        share: function (key, value) {

            // Asserting
            XP.assertArgument(XP.isString(key, true), 1, 'string');

            // Vars
            var self = this;

            // Sharing
            self.sharers.forEach(function (sharer) { sharer.set('shared.' + key, value); });

            return self;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The shared data.
             *
             * @attribute shared
             * @type Object
             * @notifies
             * @readOnly
             */
            shared: {
                notify: true,
                readOnly: true,
                type: Object,
                value: function () { return (this.sharers[0] && this.sharers[0].shared) || {}; }
            }
        },

        /**
         * The list of sharers.
         *
         * @property sharers
         * @type Array
         * @default []
         * @readonly
         */
        sharers: [],

        /*********************************************************************/

        // LISTENER
        ready: function () {
            this.push('sharers', this);
        }
    };
</script><script>
    Polymer({

        // ELEMENT
        is: 'xp-slave-state',

        // EXTENDS
        extends: 'template',

        /*********************************************************************/

        /**
         * Fired when the slave is attached.
         *
         * @event xp-slave-state
         * @param {Element} firer
         * @param {Function} coupler
         * @param {string} masterSelector
         * @param {string} masterTag
         * @param {boolean} isAttached
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Couples the slave to a master.
         *
         * @method _couple
         * @param {Element} master
         * @returns {Element}
         * @private
         */
        _couple: function (master) {
            var self = this;
            if (!self.master) { self._setMaster(master); }
            return master === self.master ? master : null;
        },

        /**
         * Decouples the slave from its master.
         *
         * @method _decouple
         * @param {Element} master
         * @returns {Element}
         * @private
         */
        _decouple: function (master) {
            var self = this;
            if (self.master === master) { self._setMaster(null); }
            return !self.master ? master : null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The slave's master.
             *
             * @attribute master
             * @type Element
             * @notifies
             * @readonly
             */
            master: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * A selector used to recognize the master.
             *
             * @attribute master-selector
             * @type string
             */
            masterSelector: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The `tagName` of the master.
             *
             * @attribute master-tag
             * @type string
             */
            masterTag: {
                reflectToAttribute: true,
                type: String,
                value: null
            }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {
            var self = this;
            XP.delay(function () { self.fire('xp-slave-state', {firer: self.domHost, coupler: self._couple.bind(self), masterSelector: self.masterSelector, masterTag: self.masterTag, isAttached: true}); });
        },

        // LISTENER
        detached: function () {
            var self = this;
            if (!self.master) { return; }
            XP.delay(function () { self.master.fire('xp-slave-state', {firer: self.domHost, coupler: self._decouple.bind(self), masterSelector: self.masterSelector, masterTag: self.masterTag, isAttached: false}); });
        }
    });
</script><script>
    Polymer.XPAdapterBehavior = {

        /**
         * Used to set the adaptee.
         *
         * @method _adapt
         * @param {Element | Object} [adaptee]
         * @returns {Element | Object}
         * @private
         */
        _adapt: function (adaptee) {

            // Asserting
            XP.assertArgument(XP.isVoid(adaptee) || XP.isElement(adaptee) || XP.isObject(adaptee), 1, 'Element or Object');

            // Vars
            var self  = this,
                value = adaptee || null;

            // Setting
            self._setAdaptee(value);

            return value;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The adapted element or object.
             *
             * @attribute adaptee
             * @type Element | Object
             * @notifies
             * @readonly
             */
            adaptee: {
                notify: true,
                readOnly: true,
                type: Object,
                value: null
            }
        }
    };
</script><script>
    Polymer.XPArrayBehavior = {

        /**
         * Adds a value at the end of an array, if it doesn't already exist,
         * and returns the passed element.
         *
         * @method append
         * @param {string} array
         * @param {*} value
         * @returns {*}
         */
        append: function (array, value) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this, includes = XP.includes(self[array], value);
            if (!includes) { self.push(array, value); }
            return value;
        },

        /**
         * Substitutes all items of `array` with ones from `other`, and returns the modified `array`.
         * The substitution happens only if necessary.
         *
         * @method overwrite
         * @param {string} array
         * @param {Array} other
         * @returns {Array}
         */
        overwrite: function (array, other) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertArgument(XP.isArrayable(other), 2, 'Arrayable');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this, differs = self[array].length !== other.length || XP.mapOne(self[array], function (val, i) { if (val !== other[i]) { return true; } });
            if (differs) { self.splice.apply(self, XP.concat([array, 0, self[array].length], other)); }
            return self[array];
        },

        /**
         * Removes all instances of `value` from `array`.
         *
         * @method pull
         * @param {string} array
         * @param {*} [value]
         * @returns {Array}
         */
        pull: function (array, value) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this;
            XP.forEachRight(self[array], function (val, i) { if (value === val) { self.splice(array, i, 1); } });
            return self[array];
        },

        /**
         * Removes an element from `array` corresponding to the given index and returns it.
         *
         * @method pullAt
         * @param {string} array
         * @param {number} index
         * @returns {*}
         */
        pullAt: function (array, index) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertArgument(XP.isVoid(index) || XP.isIndex(index), 2, 'number');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            return index < this[array].length ? this.splice(array, index, 1)[0] : undefined;
        }
    };
</script><script>
    Polymer.XPAnchorBehavior = {

        /**
         * Refreshes the anchor.
         *
         * @method _updateAnchor
         * @returns {Element}
         * @private
         */
        _updateAnchor: function () {

            // Vars
            var self = this;

            // Setting
            XP.setAttribute(self.anchor, 'download', (self.href && self.download) || null);
            XP.setAttribute(self.anchor, 'href', self.href || null);
            XP.setAttribute(self.anchor, 'rel', (self.href && self.rel) || null);
            XP.setAttribute(self.anchor, 'target', (self.href && self.target) || null);

            return self;
        },

        /*********************************************************************/

        // OBSERVERS
        observers: [
            '_updateAnchor(anchor, download, href, rel, target)'
        ],

        // PROPERTIES
        properties: {

            /**
             * The element's anchor.
             *
             * @attribute anchor
             * @type Element
             * @notifies
             * @readonly
             */
            anchor: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * The anchor's download property's value.
             *
             * @attribute download
             * @type string
             */
            download: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's href property's value.
             *
             * @attribute href
             * @type string
             */
            href: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's rel property's value.
             *
             * @attribute rel
             * @type string
             */
            rel: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's target property's value.
             *
             * @attribute target
             * @type string
             * @notifies
             */
            target: {
                notify: true,
                value: null
            }
        }
    };
</script><script>
    Polymer.XPFocusedBehavior = {

        // LISTENERS
        listeners: {
            blur: '_blurHandler',
            focus: '_focusHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * If set to true, the element is disabled.
             *
             * @attribute disabled
             * @type boolean
             * @default false
             */
            disabled: {
                observer: '_disabledChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the element is focused.
             *
             * @attribute focused
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            focused: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /**
         * The last value of tabIndex.
         *
         * @property lastTabIndex
         * @type number
         * @default 0
         * @readonly
         */
        lastTabIndex: 0,

        /*********************************************************************/

        // OBSERVER
        _disabledChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            self.focused      = self.focused && !post;
            self.lastTabIndex = post ? self.tabIndex : self.lastTabIndex;
            self.tabIndex     = post ? -1 : self.lastTabIndex;

            // Styling
            self.style.pointerEvents = post ? 'none' : '';
        },

        /*********************************************************************/

        // LISTENER
        mutated: function () {

            // Vars
            var self = this;

            // Setting
            self.tabIndex = self.disabled ? -1 : self.tabIndex || 0;

            // Observing
            XP.onMutation(self, Polymer.XPFocusedBehavior.mutated.bind(self), {attributes: true, attributeFilter: ['tabindex']});
        },

        // LISTENER
        ready: function () {

            // Mutating
            Polymer.XPFocusedBehavior.mutated.apply(this);
        },

        /*********************************************************************/

        // HANDLER
        _blurHandler: function () {
            this._setFocused(false);
        },

        // HANDLER
        _focusHandler: function () {
            this._setFocused(!this.disabled);
        }
    };
</script><script>
    Polymer.XPTargeterBehavior = {

        /**
         * Finds the targeted element.
         *
         * @method findTarget
         * @returns {Element}
         */
        findTarget: function () {

            // Vars
            var self = this;

            // Finding
            if (XP.isElement(self.target)) { return self.target; }
            if (XP.isString(self.target, true)) { return XP.getElementById(self.target) || null; }

            return null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The element's target.
             *
             * @attribute target
             * @type Element | string
             * @notifies
             */
            target: {
                notify: true,
                value: null
            }
        }
    };
</script><script>
    Polymer.XPPressedBehaviorImp = {

        /**
         * Fired when the active state changes.
         *
         * @event xp-active
         * @param {Element} firer
         * @param {boolean} isActive
         * @bubbles
         */

        /**
         * Fired when the context element is clicked.
         *
         * @event xp-activate
         * @param {Element} firer
         * @param {Element} target
         * @param {boolean} isActive
         * @bubbles
         * @cancelable
         */

        /*********************************************************************/

        /**
         * Presses the context element.
         *
         * @method press
         * @returns {Element}
         */
        press: function () {

            // Vars
            var self   = this,
                target = self.findTarget();

            // Firing
            if (self.fire('xp-activate', {firer: self, target: target, isActive: self.active}, {cancelable: true}).defaultPrevented) { return self; }

            // Setting
            if (self.toggleable) { self.active = !self.active; }

            return self;
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            click: '_clickHandler',
            down: '_touchHandler',
            up: '_touchHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * If set to true, the element is active.
             *
             * @attribute active
             * @type boolean
             * @default false
             * @notifies
             */
            active: {
                notify: true,
                observer: '_activeChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the element is pressed.
             *
             * @attribute pressed
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            pressed: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, pressing will toggle active state on the context element.
             *
             * @attribute toggleable
             * @type boolean
             * @default false
             */
            toggleable: {
                observer: '_toggleableChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _activeChanged: function (post) {
            this.fire('xp-active', {firer: this, isActive: post});
        },

        // OBSERVER
        _toggleableChanged: function (post) {
            this.active = this.active && post;
        },

        /*********************************************************************/

        // HANDLER
        _clickHandler: function (event) {
            var self = this;
            if (self.disabled) { XP.stop(event); return; }
            if (!event.button) { self.press(); }
        },

        // HANDLER
        _touchHandler: function (event) {
            this._setPressed(event.type === 'down');
        }
    };

    Polymer.XPPressedBehavior = [
        Polymer.XPFocusedBehavior,
        Polymer.XPTargeterBehavior,
        Polymer.XPPressedBehaviorImp
    ];
</script><script>
    Polymer.XPReferralBehavior = {

        // PROPERTIES
        properties: {

            /**
             * The element itself.
             *
             * @attribute self
             * @type Element
             * @readonly
             */
            self: {
                readOnly: true,
                value: function () { return this; }
            }
        }
    };
</script><style>
    html [cascade] mat-option {
        height: 32px;
    }

    html [cascade] mat-option #matOptionMain {
        padding: 0 24px;
    }

    html [cascade] mat-option #matOptionIcon {
        margin-right: 16px;
    }
</style>

<style is="custom-style">
    :root {

        --mat-shadow-z1: {
            box-shadow: 0 1px 2px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 5px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 1px -2px hsla(0, 0%, 0%, 0.2);
        };

        --mat-shadow-z2: {
            box-shadow: 0 2px 2px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 5px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 1px -2px hsla(0, 0%, 0%, 0.2);
        };

        --mat-shadow-z3: {
            box-shadow: 0 3px 4px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 8px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 3px -2px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z4: {
            box-shadow: 0 4px  5px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 10px 0 hsla(0, 0%, 0%, 0.12),
                        0 2px  4px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z5: {
            box-shadow: 0 5px  8px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 18px 0 hsla(0, 0%, 0%, 0.12),
                        0 2px  5px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z6: {
            box-shadow: 0 6px 10px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 18px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px  5px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z7: {
            box-shadow: 0 7px 10px  1px hsla(0, 0%, 0%, 0.14),
                        0 2px 16px  2px hsla(0, 0%, 0%, 0.12),
                        0 4px  5px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z8: {
            box-shadow: 0 8px 10px  1px hsla(0, 0%, 0%, 0.14),
                        0 3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0 5px  5px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z9: {
            box-shadow: 0 9px 12px  1px hsla(0, 0%, 0%, 0.14),
                        0 3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0 5px  6px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z10: {
            box-shadow: 0 10px 13px  1px hsla(0, 0%, 0%, 0.14),
                        0  3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0  6px  6px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z11: {
            box-shadow: 0 11px 14px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 14px  3px hsla(0, 0%, 0%, 0.12),
                        0  6px  7px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z12: {
            box-shadow: 0 12px 16px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 14px  3px hsla(0, 0%, 0%, 0.12),
                        0  6px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z13: {
            box-shadow: 0 13px 18px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 18px  3px hsla(0, 0%, 0%, 0.12),
                        0  7px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z14: {
            box-shadow: 0 14px 20px  1px hsla(0, 0%, 0%, 0.14),
                        0  5px 22px  4px hsla(0, 0%, 0%, 0.12),
                        0  7px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z15: {
            box-shadow: 0 15px 22px  1px hsla(0, 0%, 0%, 0.14),
                        0  5px 26px  4px hsla(0, 0%, 0%, 0.12),
                        0  7px  9px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z16: {
            box-shadow: 0 16px 24px  2px hsla(0, 0%, 0%, 0.14),
                        0  5px 30px  5px hsla(0, 0%, 0%, 0.12),
                        0  8px 10px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z17: {
            box-shadow: 0 17px 26px  3px hsla(0, 0%, 0%, 0.14),
                        0  5px 32px  5px hsla(0, 0%, 0%, 0.12),
                        0  8px 10px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z18: {
            box-shadow: 0 18px 28px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 34px  6px hsla(0, 0%, 0%, 0.12),
                        0  8px 11px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z19: {
            box-shadow: 0 19px 30px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 36px  6px hsla(0, 0%, 0%, 0.12),
                        0  9px 11px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z20: {
            box-shadow: 0 20px 32px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 38px  7px hsla(0, 0%, 0%, 0.12),
                        0  9px 12px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z21: {
            box-shadow: 0 21px 34px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 40px  7px hsla(0, 0%, 0%, 0.12),
                        0  9px 12px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z22: {
            box-shadow: 0 22px 36px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 42px  8px hsla(0, 0%, 0%, 0.12),
                        0 10px 13px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z23: {
            box-shadow: 0 23px 38px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 44px  8px hsla(0, 0%, 0%, 0.12),
                        0 10px 13px -7px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z24: {
            box-shadow: 0 24px 40px  4px hsla(0, 0%, 0%, 0.14),
                        0  8px 46px  9px hsla(0, 0%, 0%, 0.12),
                        0 10px 10px -8px hsla(0, 0%, 0%, 0.4);
        };

    }
</style><script>
    Polymer({

        // ELEMENT
        is: 'xp-master-state',

        // EXTENDS
        extends: 'template',

        // BEHAVIORS
        behaviors: [
            Polymer.XPArrayBehavior
        ],

        /*********************************************************************/

        /**
         * Couples the master to a slave.
         *
         * @method _couple
         * @param {Element} slave
         * @returns {Element}
         * @private
         */
        _couple: function (slave) {
            return this.append('slaves', slave);
        },

        /**
         * Decouples the master from a slave.
         *
         * @method _decouple
         * @param {Element} slave
         * @returns {Element}
         * @private
         */
        _decouple: function (slave) {
            var self = this, index = self.slaves.indexOf(slave);
            return index >= 0 ? self.pullAt('slaves', index) : null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * A selector used to recognize the slaves.
             *
             * @attribute slave-selector
             * @type string
             */
            slaveSelector: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The `tagName` of the slaves.
             *
             * @attribute slave-tag
             * @type string
             */
            slaveTag: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The master's slaves.
             *
             * @attribute slaves
             * @type Array
             * @notifies
             * @readonly
             */
            slaves: {
                notify: true,
                readOnly: true,
                type: Array,
                value: function () { return []; }
            }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {
            this.listen(this.domHost, 'xp-slave-state', '_handleSlave');
        },

        /*********************************************************************/

        // HANDLER
        _handleSlave: function (event) {

            // Vars
            var self = this;

            // Checking
            if (self.domHost === event.detail.firer) { return; }
            if (self.slaveTag && self.slaveTag !== event.detail.firer.tagName.toLowerCase()) { return; }
            if (self.slaveSelector && !XP.matches(event.detail.firer, self.slaveSelector)) { return; }
            if (event.detail.masterTag && event.detail.masterTag !== self.domHost.tagName.toLowerCase()) { return; }
            if (event.detail.masterSelector && !XP.matches(self.domHost, event.detail.masterSelector)) { return; }

            // Coupling (master side)
            self[event.detail.isAttached ? '_couple' : '_decouple'](event.detail.firer);

            // Coupling (slave side)
            event.detail.coupler(self.domHost);

            // Stopping
            event.stopPropagation();
        }
    });
</script><script>
    Polymer.XPOverlayBehaviorImp = {

        /**
         * Fired when the showed state changes.
         *
         * @event xp-toggle
         * @param {Element} firer
         * @param {boolean} isShowed
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Hides the overlay.
         *
         * @method hide
         * @returns {Element}
         */
        hide: function () {
            var self = this;
            self.showed = false;
            return self;
        },

        /**
         * Shows the overlay.
         *
         * @method show
         * @param {Element | string} [target]
         * @param {*} [data]
         * @returns {Element}
         */
        show: function (target, data) {

            // Asserting
            XP.assertArgument(XP.isVoid(target) || XP.isElement(target) || XP.isString(target), 1, 'Element or string');

            // Vars
            var self = this;

            // Setting
            self.target = target || self.target;
            self.data   = data || (self.findTarget() || self).data || self.data;
            self.showed = true;

            return self;
        },

        /**
         * Toggles the overlay.
         *
         * @method toggle
         * @param {Element | string} target
         * @param {*} [data]
         * @returns {Element}
         */
        toggle: function (target, data) {
            return this[this.showed ? 'hide' : 'show'](target, data);
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * If set to true, the overlay will not close by clicking outside.
             *
             * @attribute auto-hide-disabled
             * @type boolean
             * @default false
             */
            autoHideDisabled: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The context element.
             *
             * @attribute context
             * @type Element
             */
            context: {
                value: null
            },

            /**
             * The element's data.
             *
             * @attribute data
             * @type *
             * @notifies
             */
            data: {
                notify: true,
                value: null
            },

            /**
             * If set to true, the overlay is showed.
             *
             * @attribute showed
             * @type boolean
             * @default false
             * @notifies
             */
            showed: {
                notify: true,
                observer: '_showedChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _showedChanged: function (post) {

            // Vars
            var self = this;

            // Firing
            self.fire('xp-toggle', {firer: self, isShowed: post});

            // Listening
            XP.delay(function () {
                self[post ? 'listen' : 'unlisten'](window, 'keyup', '_hideHandler');
                self[post ? 'listen' : 'unlisten'](window, 'click', '_hideHandler');
                self[post ? 'listen' : 'unlisten'](self, 'click', '_distinguishHandler');
            });
        },

        /*********************************************************************/

        // HANDLER
        _distinguishHandler: function (event) {
            (event.overlays = event.overlays || []).push(this);
        },

        // HANDLER
        _hideHandler: function (event) {

            // Vars
            var self = this;

            // Checking
            if (event.overlays && XP.includes(event.overlays, self)) { return; }
            if ((self.autoHideDisabled || event.keyCode) && event.keyCode !== 27) { return; }

            // Unlistening
            self.unlisten(window, 'keyup', '_hideHandler');
            self.unlisten(window, 'click', '_hideHandler');
            self.unlisten(self, 'click', '_distinguishHandler');

            // Hiding
            self.hide();
        }
    };

    Polymer.XPOverlayBehavior = [
        Polymer.XPTargeterBehavior,
        Polymer.XPOverlayBehaviorImp
    ];
</script><style>
    html [fullWidth] + [fullWidth] #matInputDivider {
        display: block;
    }
</style>

<script>
    Polymer.XPInputBehavior = {

        /**
         * Fired when the input's model changes.
         *
         * @event xp-input-change
         * @param {Element} firer
         * @param {boolean} isChanged
         * @param {*} model
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Blurs the input.
         *
         * @method focus
         * @abstract
         */
        blur: XP.mock(),

        /**
         * Focuses the input.
         *
         * @method focus
         * @abstract
         */
        focus: XP.mock(),

        /**
         * Selects the input.
         *
         * @method select
         * @abstract
         */
        select: XP.mock(),

        /*********************************************************************/

        /**
         * The operation used to reflect input's element's `value` onto input.
         *
         * @method _commitFrom
         * @abstract
         * @private
         */
        _commitFrom: XP.mock(),

        /**
         * The operation used to reflect input's `value` onto input's element.
         *
         * @method _commitTo
         * @abstract
         * @private
         */
        _commitTo: XP.mock(),

        /**
         * The operation used to reflect input's `tabIndex` onto input's element.
         *
         * @method _index
         * @abstract
         * @private
         */
        _index: XP.mock(),

        /**
         * The operation used to inject the input element.
         *
         * @method _inject
         * @abstract
         * @private
         */
        _inject: XP.mock(),

        /**
         * The operation used to sanitize input's `value`.
         *
         * @method _sanitize
         * @abstract
         * @private
         */
        _sanitize: XP.mock(),

        /**
         * The operation used to update input's element's attributes.
         *
         * @method _update
         * @abstract
         * @private
         */
        _update: XP.mock(),

        /**
         * The operation used to validate input's `value`.
         *
         * @method _validate
         * @abstract
         * @private
         */
        _validate: XP.mock(),

        /*********************************************************************/

        /**
         * Finds the label.
         *
         * @method findLabel
         * @returns {Element}
         */
        findLabel: function () {
            var self = this, label = (self.id && XP.getElement('label[for="' + self.id + '"]'));
            return label || XP.findParentElement(Polymer.dom(self), 'label') || null;
        },

        /**
         * Resets the input.
         *
         * @method reset
         * @returns {Element}
         */
        reset: function () {
            var self = XP.assign(this, this.initial);
            self._setInvalid(false);
            self._setInvalidMessage(null);
            return self;
        },

        /**
         * Toggles the checked state.
         *
         * @method toggle
         * @returns {Element}
         */
        toggle: function () {
            var self = this;
            if (self.primitive === 'boolean' && !self.disabled) { self.checked = !self.checked; }
            return self;
        },

        /*********************************************************************/

        /**
         * Refreshes the element.
         *
         * @method _refresh
         * @returns {Element}
         * @private
         */
        _refresh: function () {

            // Vars
            var self = this;

            // Checking
            if (!self.input) { return self; }

            // Updating
            self._update();

            // Sanitizing
            self._sanitize();

            // Validating
            if (self.value || !self.required) { self._validate(); }

            return self;
        },

        /**
         * Returns model representation of input's plain value.
         *
         * @method _toModel
         * @param {*} value
         * @returns {boolean | number | string}
         * @private
         */
        _toModel: function (value) {
            var self = this, from = XP.isPrimitive(value) ? value : null;
            if (self.primitive === 'boolean') { return XP.toBoolean(from); }
            if (self.primitive === 'number') { return XP.toNumber(from); }
            return XP.toString(from);
        },

        /**
         * Returns primitive representation of input's type
         *
         * @method _toPrimitive
         * @param {string} type
         * @returns {string}
         * @private
         */
        _toPrimitive: function (type) {
            if (type === 'checkbox') { return 'boolean'; }
            if (type === 'number') { return 'number'; }
            return 'string';
        },

        /**
         * Returns plain value representation of input's model.
         *
         * @method _toValue
         * @param {*} model
         * @returns {boolean | string}
         * @private
         */
        _toValue: function (model) {
            var self = this, from = XP.isPrimitive(model) ? model : null;
            if (self.primitive === 'boolean') { return XP.toBoolean(from, true); }
            return XP.toString(from, true);
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            click: '_clickHandler'
        },

        // OBSERVERS
        observers: [
            '_refresh(disabled, input, name, readonly, required)'
        ],

        // PROPERTIES
        properties: {

            /**
             * If set to true, the input will focus on attach.
             *
             * @attribute auto-focus
             * @type boolean
             * @default false
             */
            autoFocus: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input's model is changed.
             *
             * @attribute changed
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            changed: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's character counter.
             *
             * @attribute chars
             * @type number
             * @default 0
             * @notifies
             * @readonly
             */
            chars: {
                notify: true,
                readOnly: true,
                type: Number,
                value: 0
            },

            /**
             * If set to true, the input is checked.
             *
             * @attribute checked
             * @type boolean
             * @notifies
             */
            checked: {
                notify: true,
                observer: '_checkedChanged',
                reflectToAttribute: true,
                type: Boolean
            },

            /**
             * If set to true, the input is disabled.
             *
             * @attribute disabled
             * @type boolean
             * @default false
             */
            disabled: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input is empty.
             *
             * @attribute empty
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            empty: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the label is hidden.
             *
             * @attribute empty-label
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            emptyLabel: {
                computed: '_computeEmptyLabel(label)',
                notify: true,
                reflectToAttribute: true,
                type: Boolean
            },

            /**
             * The input's custom error message, used instead of `invalidMessage`.
             *
             * @attribute error
             * @type string
             */
            error: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * If set to true, the input is focused.
             *
             * @attribute focused
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            focused: {
                notify: true,
                observer: '_focusedChanged',
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's form.
             *
             * @attribute form
             * @type Element
             * @readonly
             */
            form: {
                observer: '_formChanged',
                readOnly: true,
                value: null
            },

            /**
             * The initial state.
             *
             * @attribute initial
             * @type Object
             * @readonly
             */
            initial: {
                readOnly: true,
                value: function () { return {}; }
            },

            /**
             * The physical input's element.
             *
             * @attribute input
             * @type Element
             * @readonly
             */
            input: {
                observer: '_inputChanged',
                readOnly: true,
                value: null
            },

            /**
             * If set to true, the input's value is not valid.
             *
             * @attribute invalid
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            invalid: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's system error message.
             *
             * @attribute invalid-message
             * @type string
             * @notifies
             * @readonly
             */
            invalidMessage: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's label.
             *
             * @attribute label
             * @type string
             */
            label: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's model.
             *
             * @attribute model
             * @type *
             * @notifies
             */
            model: {
                notify: true,
                observer: '_modelChanged'
            },

            /**
             * The input's name.
             *
             * @attribute name
             * @type string
             */
            name: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's primitive type.
             *
             * @attribute primitive
             * @type "boolean" | "number" | "string"
             * @default "string"
             * @readonly
             */
            primitive: {
                readOnly: true,
                type: String,
                value: 'string'
            },

            /**
             * If set to true, the input is readonly.
             *
             * @attribute readonly
             * @type boolean
             * @default false
             */
            readonly: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input is required.
             *
             * @attribute required
             * @type boolean
             * @default false
             */
            required: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's type.
             *
             * @attribute type
             * @type string
             * @default "text"
             */
            type: {
                observer: '_typeChanged',
                reflectToAttribute: true,
                type: String,
                value: 'text'
            },

            /**
             * The input's plain value.
             *
             * @attribute value
             * @type string
             * @notify
             */
            value: {
                notify: true,
                observer: '_valueChanged',
                type: String
            }
        },

        /**
         * The list of primitives.
         *
         * @property primitives
         * @type Array
         * @default ["boolean", "number", "string"]
         * @readonly
         */
        primitives: ['boolean', 'number', 'string'],

        /*********************************************************************/

        // COMPUTER
        _computeEmptyLabel: function (label) {
            return !label;
        },

        /*********************************************************************/

        // OBSERVER
        _checkedChanged: function (post) {

            // Vars
            var self = this;

            // Checking
            if (!self.input) { return; }

            // Setting
            self._setChanged(self.initial.checked !== post);
            self.model = self.changed ? self._toModel(post) : self.initial.model;

            // Committing
            self._commitTo();

            // Firing
            self.fire('xp-input-change', {firer: self, isChanged: self.changed, model: self.model});
        },

        // OBSERVER
        _focusedChanged: function (post) {

            // Vars
            var self = this;

            // Propagating
            XP.setAttribute(self.findLabel(), 'focused', post);
        },

        // OBSERVER
        _formChanged: function (post, pre) {

            // Vars
            var self = this;

            // Checking
            if (arguments.length < 2) { return; }

            // Listening
            if (pre) { self.unlisten(pre, 'reset', '_resetHandler'); }
            if (post) { self.listen(post, 'reset', '_resetHandler'); }

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _inputChanged: function (post, pre) {

            // Vars
            var self = this;

            // Checking
            if (arguments.length < 2) { return; }

            // Listening
            if (XP.isElement(pre)) { self.unlisten(pre, 'blur', '_blurHandler'); self.unlisten(pre, 'change', '_changeHandler'); self.unlisten(pre, 'focus', '_focusHandler'); }
            if (XP.isElement(post)) { self.listen(post, 'blur', '_blurHandler'); self.listen(post, 'change', '_changeHandler'); self.listen(post, 'focus', '_focusHandler'); }

            // Mutating
            Polymer.XPInputBehavior.mutated.apply(self);

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _modelChanged: function () {

            // Casting
            this[this.primitive === 'boolean' ? 'checked' : 'value'] = this._toValue(this.model);
        },

        // OBSERVER
        _typeChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            self._setPrimitive(self._toPrimitive(post));

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _valueChanged: function (post) {

            // Vars
            var self = this;

            // Checking
            if (!self.input) { return; }

            // Sanitizing
            self._sanitize();

            // Checking
            if (self.value !== post) { return; }

            // Setting
            self._setChanged(self.initial.value !== post);
            self._setEmpty(!self.value);
            self.model = self.changed ? self._toModel(post) : self.initial.model;

            // Committing
            self._commitTo();

            // Validating
            self._validate();

            // Firing
            self.fire('xp-input-change', {firer: self, isChanged: self.changed, model: self.model});
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {

            // Vars
            var self = this;

            // Setting
            self._setForm(XP.findParentElement(Polymer.dom(self), 'form'));
            self._setInvalid(false);

            // Focusing
            if (self.autoFocus) { XP.delay(function () { self.focus(); }); }
        },

        // LISTENER
        detached: function () {

            // Vars
            var self = this;

            // Setting
            self._setForm(null);
        },

        // LISTENER
        mutated: function () {

            // Vars
            var self = this;

            // Checking
            if (self._index === Polymer.XPInputBehavior._index) { return; }
            if (self._index === Polymer.XPInputBehavior._index) { return; }

            // Disconnecting
            if (self.indexObserver) { self.indexObserver.disconnect(); }

            // Indexing
            self.async(function () { self._index(Math.max(self.tabIndex, 0)); });

            // Setting
            self.removeAttribute(self.input ? 'tabindex' : '');

            // Observing
            self.indexObserver = XP.onMutation(self, Polymer.XPInputBehavior.mutated.bind(self), {attributes: true, attributeFilter: ['tabindex']});
        },

        // LISTENER
        ready: function () {

            // Vars
            var self = this;

            // Setting
            self.set('initial.checked', self.checked = self.model && self.primitive === 'boolean' ? true : self.checked || false);
            self.set('initial.value', self.value = self.model && self.primitive !== 'boolean' ? self._toValue(self.model) : self.value || '');
            self.set('initial.model', self.model = self.checked || (self.value ? self._toModel(self.value) : self.model || null));
            self._setEmpty(self.primitive !== 'boolean' && !self.value);

            // Injecting
            self._inject();

            // Committing
            self._commitTo();
        },

        /*********************************************************************/

        // HANDLER
        _blurHandler: function () {
            this._setFocused(false);
        },

        // HANDLER
        _changeHandler: function () {
            this._commitFrom();
        },

        // HANDLER
        _clickHandler: function () {
            this.focus();
        },

        // HANDLER
        _focusHandler: function () {
            this._setFocused(!this.disabled);
        },

        // HANDLER
        _resetHandler: function () {
            XP.delay(this.reset.bind(this));
        }
    };
</script><script>
    Polymer.XPSelectedBehaviorImp = {

        /**
         * Fired on item selection.
         *
         * @event xp-select
         * @param {Element} firer
         * @param {Element} item
         * @param {number} index
         * @param {boolean} isMulti
         * @param {boolean} isSelected
         * @param {boolean} isSwitchable
         * @bubbles
         * @cancelable
         */

        /**
         * Fired when the selection changes.
         *
         * @event xp-selection
         * @param {Element} firer
         * @param {Array | Element} selection
         * @param {Array | Element} selected
         * @param {boolean} isMulti
         * @param {boolean} isSwitchable
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Finds an item's index.
         *
         * @method findIndex
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {number | string}
         */
        findIndex: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            if (item && self.indexAttribute) { return XP.getAttribute(item, self.indexAttribute) || null; }
            if (item) { return XP.indexOf(self.items || [], item); }
            return null;
        },

        /**
         * Finds an item.
         *
         * @method findItem
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        findItem: function (identity, safe) {
            return safe ? identity : XP.find(this.items || [], this._toDOMIdentity(identity)) || null;
        },

        /**
         * Finds items filtered by predicate.
         *
         * @method findItems
         * @param {Function} [predicate]
         * @returns {Array}
         */
        findItems: function (predicate) {
            return XP.filter(this.items || [], this._toDOMPredicate(predicate));
        },

        /**
         * Finds an item's index, iterating from right to left.
         *
         * @method findLastIndex
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {number | string}
         */
        findLastIndex: function (identity, safe) {
            var self = this, item = self.findLastItem(identity, safe);
            if (item && self.indexAttribute) { return XP.getAttribute(item, self.indexAttribute) || null; }
            if (item) { return XP.indexOf(self.items || [], item) || null; }
            return null;
        },

        /**
         * Finds an item, iterating from right to left.
         *
         * @method findLastItem
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        findLastItem: function (identity, safe) {
            return safe ? identity : XP.findLast(this.items || [], this._toDOMIdentity(identity)) || null;
        },

        /**
         * Checks if an item is selectable.
         *
         * @method isSelectable
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isSelectable: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            return XP.isElement(item) && !self.isSelected(item);
        },

        /**
         * Checks if an item is selected.
         *
         * @method isSelected
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isSelected: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            return self.multi ? XP.includes(self.selection, item) : self.selection === item;
        },

        /**
         * Checks if an item is unselectable.
         *
         * @method isUnselectable
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isUnselectable: function (identity, force, safe) {
            var self = this, item = self.findItem(identity, safe);
            return XP.isElement(item) && self.isSelected(item) && (force || self.multi || self.switchable);
        },

        /**
         * Selects an item.
         *
         * @method select
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        select: function (identity, safe) {

            // Vars
            var self  = this,
                item  = self.findItem(identity, safe),
                index = self.findIndex(item, true);

            // Checking
            if (!item || !self.isSelectable(item)) { return null; }

            // Firing
            if (self.fire('xp-select', {firer: self, item: item, index: index, isMulti: self.multi, isSelected: true, isSwitchable: self.multi || self.switchable}, {cancelable: true}).defaultPrevented) { return null; }

            // Selecting
            self._setSelecting(true);
            if (self.multi) { self.append('selection', item); } else { self._setSelection(item); }
            if (self.multi) { self.append('selected', index); } else { self.selected = index; }
            self._setSelecting(false);

            return item;
        },

        /**
         * Selects all items.
         *
         * @method selectAll
         * @param {Function} [predicate]
         * @returns {Array}
         */
        selectAll: function (predicate) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.select(item, true); });
        },

        /**
         * Selects the next item.
         *
         * @method selectNext
         * @returns {Element}
         */
        selectNext: function () {
            var self = this, item = !self.multi ? XP.getNext(self.items || [], self.selection) : null;
            return item ? self.select(item, true) : null;
        },

        /**
         * Selects the previous item.
         *
         * @method selectPrevious
         * @returns {Element}
         */
        selectPrevious: function () {
            var self = this, item = !self.multi ? XP.getPrevious(self.items || [], self.selection) : null;
            return item ? self.select(item, true) : null;
        },

        /**
         * Toggles active state on an item.
         *
         * @method switch
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        switch: function (identity, force, safe) {
            var self = this, item = self.findItem(identity, safe);
            if (item && self.isSelected(item)) { return self.unselect(item, force, true); }
            if (item) { return self.select(item, true); }
            return null;
        },

        /**
         * Toggles active state on all items.
         *
         * @method switchAll
         * @param {Function} [predicate]
         * @param {boolean} [force = false]
         * @returns {Array}
         */
        switchAll: function (predicate, force) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.switch(item, force, true); });
        },

        /**
         * Unselects an item.
         *
         * @method unselect
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        unselect: function (identity, force, safe) {

            // Vars
            var self  = this,
                item  = self.findItem(identity, safe),
                index = self.findIndex(item, true);

            // Checking
            if (!item || !self.isUnselectable(item, force)) { return null; }

            // Firing
            if (self.fire('xp-select', {firer: self, item: item, index: index, isMulti: self.multi, isSelected: false, isSwitchable: self.multi || self.switchable}, {cancelable: true}).defaultPrevented && !force) { return null; }

            // Unselecting
            self._setSelecting(true);
            if (self.multi) { self.pull('selection', item); } else { self._setSelection(null); }
            if (self.multi) { self.pull('selected', index); } else { self.selected = null; }
            self._setSelecting(false);

            return item;
        },

        /**
         * Unselects all items.
         *
         * @method unselectAll
         * @param {Function} [predicate]
         * @param {boolean} [force = false]
         * @returns {Array}
         */
        unselectAll: function (predicate, force) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.unselect(item, force, true); });
        },

        /*********************************************************************/

        /**
         * Returns a DOM identity representation of `target`.
         *
         * @method _toDOMIdentity
         * @param {Element | Function | number | string} target
         * @returns {Function | number}
         * @private
         */
        _toDOMIdentity: function (target) {

            // Vars
            var self      = this,
                attribute = self.indexAttribute,
                index     = !attribute ? XP.toNumber(target) : null;

            // Casting
            if (XP.isIndex(index)) { return index; }
            if (XP.isString(target) && XP.isString(attribute, true)) { return function (element) { return XP.isElement(element) && target === element.getAttribute(attribute); }; }
            if (XP.isElement(target) || XP.isFunction(target) || XP.isNullable(target)) { return XP.toDOMIdentity(target); }

            // Asserting
            throw new XP.ArgumentError(1, 'Element, Function, number or string');
        },

        /**
         * Returns a DOM predicate representation of `target`.
         *
         * @method _toDOMPredicate
         * @param {Function} [target]
         * @returns {Function}
         * @private
         */
        _toDOMPredicate: function (target) {

            // Casting
            if (XP.isVoid(target) || XP.isFunction(target)) { return XP.toDOMPredicate(target); }

            // Asserting
            throw new XP.ArgumentError(1, 'Function');
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            'items-changed': '_itemsHandler',
            'selected-changed': '_selectedHandler',
            'selection-changed': '_selectionHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * The context element.
             *
             * @attribute context
             * @type Element
             */
            context: {
                value: null
            },

            /**
             * If set to true, the selectable items are searched deep.
             *
             * @attribute deep
             * @type boolean
             * @default false
             */
            deep: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The index of the item to select by default.
             *
             * @attribute default-selected
             * @type number | string
             */
            defaultSelected: {
                value: null
            },

            /**
             * If set to true, there are no items.
             *
             * @attribute empty-items
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            emptyItems: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The attribute used as index.
             *
             * @attribute index-attribute
             * @type string
             */
            indexAttribute: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * If set to true, the selector is initialized.
             *
             * @attribute initialized
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            initialized: {
                notify: true,
                observer: '_initializedChanged',
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the mutation observer is set.
             *
             * @attribute is-mutated
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            isMutated: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selector used to recognize selectable items.
             *
             * @attribute item-selector
             * @type string
             * @default "[selectable]"
             */
            itemSelector: {
                reflectToAttribute: true,
                type: String,
                value: '[selectable]'
            },

            /**
             * The selectable items.
             *
             * @attribute items
             * @type Array
             * @notifies
             */
            items: {
                notify: true,
                type: Array
            },

            /**
             * If set to true, multi selection is allowed.
             *
             * @attribute multi
             * @type boolean
             * @default false
             */
            multi: {
                observer: '_multiChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the selector is currently mutating.
             *
             * @attribute mutating
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            mutating: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selected item's index.
             *
             * @attribute selected
             * @type Array | number | string
             * @notifies
             */
            selected: {
                notify: true,
                value: null
            },

            /**
             * The attribute set on selection.
             *
             * @attribute selected-attribute
             * @type string
             * @default "active"
             */
            selectedAttribute: {
                reflectToAttribute: true,
                type: String,
                value: 'active'
            },

            /**
             * If set to true, the selection is about to change.
             *
             * @attribute selecting
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            selecting: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selected item.
             *
             * @attribute selection
             * @type Element
             * @notifies
             * @readonly
             */
            selection: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * If set to true, there's only one item.
             *
             * @attribute single-item
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            singleItem: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the unselection is allowed even if not multi.
             *
             * @attribute switchable
             * @type boolean
             * @default false
             */
            switchable: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _initializedChanged: function (post) {

            // Vars
            var self = this;

            // Checking
            if (!post) { return; }

            // Selecting
            if (XP.isString(self.defaultSelected, true) || XP.isFinite(self.defaultSelected)) { self.select(self.indexAttribute ? self.defaultSelected : XP.toIndex(self.defaultSelected, true)); return; }
            if (XP.isString(self.selected, true) || XP.isFinite(self.selected)) { self.select(self.selected); }
        },

        // OBSERVER
        _multiChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            if (post) { self._setSelection(XP.toArray(self.selection, true)); } else if (XP.isArray(self.selection)) { self._setSelection(null); }
            if (post) { self.selected = XP.toArray(self.selected, true); } else if (XP.isArray(self.selected)) { self.selected = null; }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {

            // Vars
            var self = this;

            // Setting
            if (!self.items) { self.items = []; } else { return; }

            // Mutating
            Polymer.XPSelectedBehaviorImp.mutated.apply(self);
        },

        // LISTENER
        mutated: function () {

            // Vars
            var self     = this,
                selector = self.context || self;

            // Checking
            if (self.selecting) { return; }

            // Finding
            self.overwrite('items', XP[self.deep ? 'getElements' : 'findElements'](Polymer.dom(selector), self.itemSelector));

            // Setting
            if (self.isMutated) { self._setMutating(true); }
            if (self.isMutated) { self._setSelection(self.multi ? self.overwrite('selection', XP.intersection(self.items, self.selection)) : self.findItem(self.selection)); }
            if (self.isMutated) { self.selected = self.multi ? self.overwrite('selected', XP.map(self.selection, function (item) { return self.findIndex(item, true); })) : self.findIndex(self.selection, true); }
            if (self.isMutated) { self._setMutating(false); }

            // Annotating
            self._setIsMutated(true);

            // Observing
            XP.onMutation(selector, Polymer.XPSelectedBehaviorImp.mutated.bind(self));
        },

        /*********************************************************************/

        // HANDLER
        _itemsHandler: function () {

            // Vars
            var self = this;

            // Setting
            self._setEmptyItems(self.items.length === 0);
            self._setInitialized(self.initialized || self.items.length > 0);
            self._setSingleItem(self.items.length === 1);
        },

        // HANDLER
        _selectedHandler: function () {

            // Vars
            var self     = this,
                changing = !self.mutating && !self.selecting,
                target   = self.findTarget();

            // Setting
            if (changing) { self._setSelection(self.multi ? self.overwrite('selection', XP.map(self.selected, function (identity) { return self.findItem(identity); })) : ((XP.isString(self.selected, true) || XP.isFinite(self.selected)) && self.findItem(self.selected)) || null); }

            // Propagating
            if (target) { target.selected = self.selected; }
        },

        // HANDLER
        _selectionHandler: function () {

            // Vars
            var self = this;

            // Firing
            self.fire('xp-selection', {firer: self, selection: self.selection, selected: self.selected, isMulti: self.multi, isSwitchable: self.multi || self.switchable});

            // Setting
            XP.forEach(self.items || [], function (item) { XP.setAttribute(item, self.selectedAttribute, self.isSelected(item, true)); });
        }
    };

    Polymer.XPSelectedBehavior = [
        Polymer.XPArrayBehavior,
        Polymer.XPTargeterBehavior,
        Polymer.XPSelectedBehaviorImp
    ];
</script>
<script>
  /**
   * The `<platinum-sw-cache>` element makes it easy to precache specific resources, perform runtime
   * caching, and serve your cached resources when a network is unavailable.
   * Under the hood, the [sw-toolbox](https://github.com/googlechrome/sw-toolbox) library is used
   * for all the caching and request handling logic.
   * `<platinum-sw-cache>` needs to be a child element of `<platinum-sw-register>`.
   * A simple, yet useful configuration is
   *
   *     <platinum-sw-register auto-register>
   *       <platinum-sw-cache></platinum-sw-cache>
   *     </platinum-sw-register>
   *
   * This is enough to have all of the resources your site uses cached at runtime, both local and
   * cross-origin.
   * (It uses the default `defaultCacheStrategy` of "networkFirst".)
   * When there's a network available, visits to your site will go against the network copy of the
   * resources, but if someone visits your site when they're offline, all the cached resources will
   * be used.
   *
   * @demo demo/index.html An offline-capable eReader demo.
   */
  Polymer({
    is: 'platinum-sw-cache',

    properties: {
      /**
       * The caching strategy used for all requests, both for local and cross-origin resources.
       *
       * For a list of strategies, see the [`sw-toolbox` documentation](https://github.com/GoogleChrome/sw-toolbox#built-in-handlers).
       * Specify a strategy as a string, without the "toolbox" prefix. E.g., for
       * `toolbox.networkFirst`, set `defaultCacheStrategy` to "networkFirst".
       *
       * Note that the "cacheFirst" and "cacheOnly" strategies are not recommended, and may be
       * explicitly prevented in a future release. More information can be found at
       * https://github.com/PolymerElements/platinum-sw#cacheonly--cachefirst-defaultcachestrategy-considered-harmful
       *
       * @see {@link https://github.com/GoogleChrome/sw-toolbox#built-in-handlers}
       */
      defaultCacheStrategy: {
        type: String,
        value: 'networkFirst'
      },

      /**
       * Used to provide a list of URLs that are always precached as soon as the service worker is
       * installed. Corresponds to  [`sw-toolbox`'s `precache()` method](https://github.com/GoogleChrome/sw-toolbox#toolboxprecachearrayofurls).
       *
       * This is useful for URLs that that wouldn't necessarily be picked up by runtime caching,
       * i.e. a list of resources that are needed by one of the subpages of your site, or a list of
       * resources that are only loaded via user interaction.
       *
       * `precache` can be used in conjunction with `precacheFile`, and the two arrays will be
       * concatenated.
       *
       * @see {@link https://github.com/GoogleChrome/sw-toolbox#toolboxprecachearrayofurls}
       */
      precache: {
        type: Array,
        value: function() { return []; }
      },

      /**
       * Used to provide a list of URLs that are always precached as soon as the service worker is
       * installed. Corresponds to  [`sw-toolbox`'s `precache()` method](https://github.com/GoogleChrome/sw-toolbox#toolboxprecachearrayofurls).
       *
       * While the `precache` option supports provided the array of URLs in as an inline attribute,
       * this option supports providing them as an array in JSON file, which is fetched at runtime.
       * This is useful if the array is generated via a separate build step, as it's easier to
       * write that output to a file then it is to modify inline HTML content.
       *
       * `precacheFile` can be used in conjunction with `precache`, and the two arrays will be
       * concatenated.
       *
       * @see {@link https://github.com/GoogleChrome/sw-toolbox#toolboxprecachearrayofurls}
       */
      precacheFile: String
    },

    _getParameters: function(baseURI) {
      return new Promise(function(resolve) {
        var params = {
          importscriptLate: new URL('bootstrap/sw-toolbox-setup.js', baseURI).href,
          defaultCacheStrategy: this.defaultCacheStrategy,
          precache: this.precache
        };

        if (this.precacheFile) {
          window.fetch(this.precacheFile).then(function(response) {
            if (!response.ok) {
              throw Error('unable to load ' + this.precacheFile);
            }
            return response.json();
          }.bind(this)).then(function(files) {
            params.precache = params.precache.concat(files);
          }).catch(function(error) {
            console.info('Skipping precaching: ' + error.message);
          }).then(function() {
            resolve(params);
          });
        } else {
          resolve(params);
        }
      }.bind(this));
    }
  });
</script>
<script>
  (function() {
    // Grab the URI of this file to use as a base when resolving relative paths.
    // Fallback to './' as a default, though current browsers that don't support
    // document.currentScript also don't support service workers.
    var baseURI = document.currentScript ? document.currentScript.baseURI : './';

    /**
     * The `<platinum-sw-register>` element handles
     * [service worker](http://www.html5rocks.com/en/tutorials/service-worker/introduction/)
     * registration, reflects the overall service worker state, and coordinates the configuration
     * provided by other Service Worker Elements.
     * `<platinum-sw-register>` is used as a parent element for child elements in the
     * `<platinum-sw-*>` group.
     *
     *     <platinum-sw-register skip-waiting
     *                           clients-claim
     *                           auto-register
     *                           state="{{state}}"
     *                           on-service-worker-error="handleSWError"
     *                           on-service-worker-updated="handleSWUpdated"
     *                           on-service-worker-installed="handleSWInstalled">
     *       ...one or more <platinum-sw-*> children which share the service worker registration...
     *     </platinum-sw-register>
     *
     * Please see https://github.com/PolymerElements/platinum-sw#top-level-sw-importjs for a
     * *crucial* prerequisite file you must create before `<platinum-sw-register>` can be used!
     *
     * @demo demo/index.html An offline-capable eReader demo.
     */
    Polymer({
      is: 'platinum-sw-register',

      // Used as an "emergency" switch if we make breaking changes in the way <platinum-sw-register>
      // talks to service-worker.js. Otherwise, it shouldn't need to change, and isn't meant to be
      // kept in sync with the element's release number.
      _version: '1.0',

      /**
       * Fired when the initial service worker installation completes successfully.
       * The service worker will normally only be installed once, the first time a page with a
       * `<platinum-sw-register>` element is visited in a given browser. If the same page is visited
       * again, the existing service worker will be reused, and there won't be another
       * `service-worker-installed` fired.
       *
       * @event service-worker-installed
       * @param {String} A message indicating that the installation succeeded.
       */

      /**
       * Fired when the service worker update flow completes successfully.
       * If you make changes to your `<platinum-sw-register>` configuration (i.e. by adding in new
       * `<platinum-sw-*>` child elements, or changing their attributes), users who had the old
       * service worker installed will get the update installed when they see the modified elements.
       *
       * @event service-worker-updated
       * @param {String} A message indicating that the update succeeded.
       */

      /**
       * Fired when an error prevents the service worker installation from completing.
       *
       * @event service-worker-error
       * @param {String} A message indicating what went wrong.
       */

      properties: {
        /**
         * Whether this element should automatically register the corresponding service worker as
         * soon as its added to a page.
         *
         * If set to `false`, then the service worker won't be automatically registered, and you
         * must call this element's `register()` method if you want service worker functionality.
         * This is useful if, for example, the service worker needs to be configured using
         * information that isn't immediately available at the time the page loads.
         *
         * If set to `true`, the service worker will be automatically registered without having to
         * call any methods.
         */
        autoRegister: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the activated service worker should [take immediate control](https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#clients-claim-method)
         * of any pages under its scope.
         *
         * If this is `false`, the service worker won't have any effect until the next time the page
         * is visited/reloaded.
         * If this is `true`, it will take control and start handling events for the current page
         * (and any pages under the same scope open in other tabs/windows) as soon it's active.
         * @see {@link https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#clients-claim-method}
         */
        clientsClaim: {
          type: Boolean,
          value: false
        },

        /**
         * The service worker script that is [registered](https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#navigator-service-worker-register).
         * The script *should* be located at the top level of your site, to ensure that it is able
         * to control all the pages on your site.
         *
         * It's *strongly* recommended that you create a top-level file named `sw-import.js`
         * containing only:
         *
         * `importScripts('bower_components/platinum-sw/service-worker.js');`
         *
         * (adjust to match the path where your `platinum-sw` element directory can be found).
         *
         * This will ensure that your service worker script contains everything needed to play
         * nicely with the Service Worker Elements group.
         *
         * @see {@link https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#navigator-service-worker-register}
         */
        href: {
          type: String,
          value: 'sw-import.js'
        },

        /**
         * Whether the page should be automatically reloaded (via `window.location.reload()`) when
         * the service worker is successfully installed.
         *
         * While it's perfectly valid to continue using a page with a freshly installed service
         * worker, it's a common pattern to want to reload it immediately following the install.
         * This ensures that, for example, if you're using a `<platinum-sw-cache>` with an on the
         * fly caching strategy, it will get a chance to intercept all the requests needed to render
         * your page and store them in the cache.
         *
         * If you don't immediately reload your page, then any resources that were loaded before the
         * service worker was installed (e.g. this `platinum-sw-register.html` file) won't be present
         * in the cache until the next time the page is loaded.
         *
         * Note that this reload will only happen when a service worker is installed for the first
         * time. If the service worker is subsequently updated, it won't trigger another reload.
         */
        reloadOnInstall: {
          type: Boolean,
          value: false
        },

        /**
         * The scope of the service worker, relative to the registered service worker script.
         * All pages that fall under this scope will be controlled by the registered service worker.
         *
         * Normally, this would not need to be changed, unless you want the service worker to only
         * apply to a subset of your site.
         *
         * @see {@link https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#navigator-service-worker-register}
         */
        scope: {
          type: String,
          value: './'
        },

        /**
         * Whether an updated service worker should [bypass the `waiting` state](https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#service-worker-global-scope-skipwaiting)
         * and immediately become `active`.
         *
         * Normally, during an update, the new service worker stays in the
         * `waiting` state until the current page and any other tabs/windows that are using the old
         * service worker are unloaded.
         *
         * If this is `false`, an updated service worker won't be activated until all instances of
         * the old server worker have been unloaded.
         *
         * If this is `true`, an updated service worker will become `active` immediately.
         * @see {@link https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#service-worker-global-scope-skipwaiting}
         */
        skipWaiting: {
          type: Boolean,
          value: false
        },

        /**
         * The current state of the service worker registered by this element.
         *
         * One of:
         * - 'installed'
         * - 'updated'
         * - 'error'
         * - 'unsupported'
         */
        state: {
          notify: true,
          readOnly: true,
          type: String
        }
      },

      /**
       * Registers the service worker based on the configuration options in this element and any
       * child elements.
       *
       * If you set the `autoRegister` property to `true`, then this method is called automatically
       * at page load.
       * It can be useful to set `autoRegister` to `false` and then explicitly call this method if
       * there are options that are only configured after the page is loaded.
       */
      register: function() {
        if ('serviceWorker' in navigator) {
          this._constructServiceWorkerUrl().then(function(serviceWorkerUrl) {
            this._registerServiceWorker(serviceWorkerUrl);
          }.bind(this));
        } else {
          this._setState('unsupported');
          this.fire('service-worker-error', 'Service workers are not available in the current browser.');
        }
      },

      _constructServiceWorkerUrl: function() {
        var paramsPromises = [];
        var children = Polymer.dom(this).children;
        for (var i = 0; i < children.length; i++) {
          if (typeof children[i]._getParameters === 'function') {
            paramsPromises.push(children[i]._getParameters(baseURI));
          }
        }

        return Promise.all(paramsPromises).then(function(paramsResolutions) {
          var params = {
            baseURI: baseURI,
            version: this._version
          };

          paramsResolutions.forEach(function(childParams) {
            Object.keys(childParams).forEach(function(key) {
              if (Array.isArray(params[key])) {
                params[key].push(childParams[key]);
              } else {
                params[key] = [childParams[key]];
              }
            });
          });

          return params;
        }.bind(this)).then(function(params) {
          if (params.importscriptLate) {
            if (params.importscript) {
              params.importscript = params.importscript.concat(params.importscriptLate);
            } else {
              params.importscript = params.importscriptLate;
            }
          }

          if (params.importscript) {
            params.importscript = this._unique(params.importscript);
          }

          params.clientsClaim = this.clientsClaim;
          params.skipWaiting = this.skipWaiting;

          var serviceWorkerUrl = new URL(this.href, window.location);
          // It's very important to ensure that the serialization is stable.
          // Serializing the same settings should always produce the same URL.
          // Serializing different settings should always produce a different URL.
          // This ensures that the service worker upgrade flow is triggered when settings change.
          serviceWorkerUrl.search = this._serializeUrlParams(params);

          return serviceWorkerUrl;
        }.bind(this));
      },

      _unique: function(arr) {
        return arr.filter(function(item, index) {
          return arr.indexOf(item) === index;
        });
      },

      _serializeUrlParams: function(params) {
        return Object.keys(params).sort().map(function(key) {
          // encodeURIComponent(['a', 'b']) => 'a%2Cb',
          // so this will still work when the values are Arrays.
          // TODO: It won't work if the values in the Arrays have ',' characters in them.
          return encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
        }).join('&');
      },

      _registerServiceWorker: function(serviceWorkerUrl) {
        navigator.serviceWorker.register(serviceWorkerUrl, {scope: this.scope}).then(function(registration) {
          if (registration.active) {
            this._setState('installed');
          }

          registration.onupdatefound = function() {
            var installingWorker = registration.installing;
            installingWorker.onstatechange = function() {
              switch (installingWorker.state) {
                case 'installed':
                  if (navigator.serviceWorker.controller) {
                    this._setState('updated');
                    this.fire('service-worker-updated',
                      'A new service worker was installed, replacing the old service worker.');
                  } else {
                    if (this.reloadOnInstall) {
                      window.location.reload();
                    } else {
                      this._setState('installed');
                      this.fire('service-worker-installed', 'A new service worker was installed.');
                    }
                  }
                break;

                case 'redundant':
                  this._setState('error');
                  this.fire('service-worker-error', 'The installing service worker became redundant.');
                break;
              }
            }.bind(this);
          }.bind(this);
        }.bind(this)).catch(function(error) {
          this._setState('error');
          this.fire('service-worker-error', error.toString());
          if (error.name === 'NetworkError') {
            var location = serviceWorkerUrl.origin + serviceWorkerUrl.pathname;
            console.error('A valid service worker script was not found at ' + location + '\n' +
              'To learn how to fix this, please see\n' +
              'https://github.com/PolymerElements/platinum-sw#top-level-sw-importjs');
          }
        }.bind(this));
      },

      attached: function() {
        if (this.autoRegister) {
          this.async(this.register);
        }
      }
    });
  })();
</script>

<style is="custom-style">

  /*
   Polymer includes a shim for CSS Custom Properties that we can use for application theming.
   Below, you'll find the default palette for the Polymer Starter Kit layout. Feel free to play
   with changing the colors used or generate your own palette of colours at MaterialPalette.com.

   See https://www.polymer-project.org/1.0/docs/devguide/styling.html#xscope-styling-details
   for further information on custom CSS properties.
   */

  /* Application theme */

  :root {
    --dark-primary-color: #151515;
    --default-primary-color: #272930;
    --light-primary-color: #A8A9AC;
    --text-primary-color: #ffffff; /*text/icons*/
    --accent-color: #FF4081;
    --primary-background-color: #c5cae9;
    --primary-text-color: #212121;
    --secondary-text-color: #727272;
    --disabled-text-color: #bdbdbd;
    --divider-color: #B6B6B6;

    /* custom vars */
    --primary-highlight-color:#7660A6;
    --selected-text-color: #ffffff;

    /* Components */

    /* paper-drawer-panel */
    --drawer-menu-color: var(--primary-highlight-color);
    --drawer-border-color: 1px solid #ccc;
    --drawer-toolbar-border-color: 1px solid rgba(0, 0, 0, 0.22);

    paper-drawer-panel {
      --paper-drawer-panel-left-drawer-container: {
        background-color: var(--default-primary-color);
      };
    }

    /* paper-menu */
    --paper-menu-background-color: var(--default-primary-color);
    --menu-link-color: var(--light-primary-color);

    /* paper-progress */
    paper-progress {
      --paper-progress-active-color: var(--primary-highlight-color);
      --paper-progress-secondary-color: var(--paper-light-blue-100);
    }
  }
  

  /* General styles */

  #drawerToolbar {
    color: var(--text-primary-color);
    background-color: var(--drawer-menu-color);
    border-bottom: var(--drawer-toolbar-border-color);
    height: 64px;
  }

  paper-material {
    border-radius: 2px;
    height: 100%;
    padding: 16px 0 16px 0;
    width: calc(98.66% - 16px);
    margin: 16px auto;
    background: white;
  }

  paper-menu iron-icon {
    margin-right: 33px;
    opacity: 0.54;
  }

  .paper-menu > .iron-selected {
    color: var(--selected-text-color);
  }

  paper-menu a {
    text-decoration: none;
    color: var(--menu-link-color);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
    font-family: 'Roboto', 'Noto', sans-serif;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    font-size: 14px;
    font-weight: 400;
    line-height: 24px;
    min-height: 48px;
    padding: 0 16px;
  }

  #mainToolbar .middle {
    margin-left: 48px;
  }

  #mainToolbar{
    background-color: white;
    color: black;
  }

  #mainToolbar.has-shadow .middle {
    font-size: 20px;
    padding-bottom: 0;
    margin-left: 48px;
  }

  /* Height of the scroll area */
  .content {
    height: 900px;
  }

  /* Breakpoints */

  /* Small */
  @media (max-width: 600px) {

    paper-material {
      --menu-container-display: none;
      width: calc(97.33% - 32px);
      padding-left: 16px;
      padding-right: 16px;
    }

    .paper-font-display1 {
      font-size: 12px;
    }

    .app-name {
      font-size: 26px;
    }

    #drawer .paper-toolbar {
      margin-left: 16px;
    }

    #overlay {
      min-width: 360px;
    }

    .bg {
      background: white;
    }

  }

  /* Tablet+ */
  @media (min-width: 601px) {

    paper-material {
      width: calc(98% - 46px);
      margin-bottom: 32px;
      padding-left: 30px;
      padding-right: 30px;
    }

    #drawer.paper-drawer-panel > [drawer] {
      border-right: 1px solid rgba(0, 0, 0, 0.14);
    }

    iron-pages {
      padding: 48px 62px;
    }

  }

  /* Material Design Adaptive Breakpoints */
  /*
    Below you'll find CSS media queries based on the breakpoint guidance
    published by the Material Design team. You can choose to use, customise
    or remove these breakpoints based on your needs.

    http://www.google.com/design/spec/layout/adaptive-ui.html#adaptive-ui-breakpoints
   */

  /* mobile-small */
  @media all and (min-width: 0) and (max-width: 360px) and (orientation: portrait) { }
  /* mobile-large */
  @media all and (min-width: 361px) and (orientation: portrait) { }
  /* mobile-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* mobile-large-landscape */
  @media all and (min-width: 481px) and (orientation: landscape) { }
  /* tablet-small-landscape */
  @media all and (min-width: 600px) and (max-width: 960px) and (orientation: landscape) { }
  /* tablet-large-landscape */
  @media all and (min-width: 961px) and (orientation: landscape) { }
  /* tablet-small */
  @media all and (min-width: 600px) and (orientation: portrait) { }
  /* tablet-large */
  @media all and (min-width: 601px) and (max-width: 840px) and (orientation : portrait) { }
  /* desktop-x-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* desktop-x-small */
  @media all and (min-width: 0) and (max-width: 480px) and (max-aspect-ratio: 4/3) { }
  /* desktop-small-landscape */
  @media all and (min-width: 481px) and (max-width: 840px) and (orientation: landscape) { }
  /* desktop-small */
  @media all and (min-width: 481px) and (max-width: 840px) and (max-aspect-ratio: 4/3) { }
  /* desktop-medium-landscape */
  @media all and (min-width: 841px) and (max-width: 1280px) and (orientation: landscape) { }
  /* desktop-medium */
  @media all and (min-width: 841px) and (max-width: 1280px) and (max-aspect-ratio: 4/3) { }
  /* desktop-large */
  @media all and (min-width: 1281px) and (max-width: 1600px) { }
  /* desktop-xlarge */
  @media all and (min-width: 1601px) and (max-width: 1920px) { }
</style>
<script>!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
  /* globals require, module */

  'use strict';

  /**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * Detect click event
   */
  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = ('undefined' !== typeof window) && (window.history.location || window.location);

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;


  /**
   * Decode URL components (query string, pathname, hash).
   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
   */
  var decodeURLComponents = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
   * HashBang option
   */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Current path being processed
   * @type {String}
   */
  page.current = '';

  /**
   * Number of pages navigated to.
   * @type {number}
   *
   *     page.len == 0;
   *     page('/login');
   *     page.len == 1;
   */

  page.len = 0;

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path) {
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options) {
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false === options.decodeURLComponents) decodeURLComponents = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) {
      document.addEventListener(clickEvent, onclick, false);
    }
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function() {
    if (!running) return;
    page.current = '';
    page.len = 0;
    running = false;
    document.removeEventListener(clickEvent, onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object} [state]
   * @api public
   */

  page.back = function(path, state) {
    if (page.len > 0) {
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      history.back();
      page.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    }else{
      setTimeout(function() {
        page.show(base, state);
      });
    }
  };


  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function(e) {
        setTimeout(function() {
          page.replace(to);
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        page.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */


  page.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx) {
    var prev = prevContext,
      i = 0,
      j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!', '');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path === 'function') {
      return page.exit('*', path);
    }

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {str} URL component to decode
   */
  function decodeURLEncodedURIComponent(val) {
    if (typeof val !== 'string') { return val; }
    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = parts[0];
      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    page.len++;
    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Object} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = decodeURLEncodedURIComponent(m[i]);
      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
        params[key.name] = val;
      }
    }

    return true;
  };


  /**
   * Handle "populate" events.
   */

  var onpopstate = (function () {
    var loaded = false;
    if ('undefined' === typeof window) {
      return;
    }
    if (document.readyState === 'complete') {
      loaded = true;
    } else {
      window.addEventListener('load', function() {
        setTimeout(function() {
          loaded = true;
        }, 0);
      });
    }
    return function onpopstate(e) {
      if (!loaded) return;
      if (e.state) {
        var path = e.state.path;
        page.replace(path, e.state);
      } else {
        page.show(location.pathname + location.hash, undefined, undefined, false);
      }
    };
  })();
  /**
   * Handle "click" events.
   */

  function onclick(e) {

    if (1 !== which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;



    // ensure link
    var el = e.target;
    while (el && 'A' !== el.nodeName) el = el.parentNode;
    if (!el || 'A' !== el.nodeName) return;



    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;



    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;



    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // strip leading "/[drive letter]:" on NW.js on Windows
    if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
      path = path.replace(/^\/[a-zA-Z]:\//, '/');
    }

    // same page
    var orig = path;

    if (path.indexOf(base) === 0) {
      path = path.substr(base.length);
    }

    if (hashbang) path = path.replace('#!', '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which ? e.button : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

}).call(this,require('_process'))
},{"_process":2,"path-to-regexp":3}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],3:[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":4}],4:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}]},{},[1])(1)
});</script>
<script>
  window.addEventListener('WebComponentsReady', function() {

    // We use Page.js for routing. This is a Micro
    // client-side router inspired by the Express router
    // More info: https://visionmedia.github.io/page.js/

    page('/', function () {
      app.route = 'dashboard';
    });

    page('/layouts', function () {
      app.route = 'layouts';
    });

    page('/uielements', function () {
      app.route = 'uielements';
    });

    page('/forms', function () {
      app.route = 'forms';
    });

    page('/tables', function () {
      app.route = 'tables';
    });

    page('/maps', function () {
      app.route = 'maps';
    });

    page('/email', function () {
      app.route = 'email';
    });

    page('/typography', function () {
      app.route = 'typography';
    });

    page('/charts', function () {
      app.route = 'charts';
    });

    page('/pages', function () {
      app.route = 'pages';
    });

    page('/menulevels', function () {
      app.route = 'menulevels';
    });

    // add #! before urls
    page({
      hashbang: true
    });

  });
</script>
<script>function MakePromise (asap) {
  function Promise(fn) {
		if (typeof this !== 'object' || typeof fn !== 'function') throw new TypeError();
		this._state = null;
		this._value = null;
		this._deferreds = []

		doResolve(fn, resolve.bind(this), reject.bind(this));
	}

	function handle(deferred) {
		var me = this;
		if (this._state === null) {
			this._deferreds.push(deferred);
			return
		}
		asap(function() {
			var cb = me._state ? deferred.onFulfilled : deferred.onRejected
			if (typeof cb !== 'function') {
				(me._state ? deferred.resolve : deferred.reject)(me._value);
				return;
			}
			var ret;
			try {
				ret = cb(me._value);
			}
			catch (e) {
				deferred.reject(e);
				return;
			}
			deferred.resolve(ret);
		})
	}

	function resolve(newValue) {
		try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === this) throw new TypeError();
			if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
				var then = newValue.then;
				if (typeof then === 'function') {
					doResolve(then.bind(newValue), resolve.bind(this), reject.bind(this));
					return;
				}
			}
			this._state = true;
			this._value = newValue;
			finale.call(this);
		} catch (e) { reject.call(this, e); }
	}

	function reject(newValue) {
		this._state = false;
		this._value = newValue;
		finale.call(this);
	}

	function finale() {
		for (var i = 0, len = this._deferreds.length; i < len; i++) {
			handle.call(this, this._deferreds[i]);
		}
		this._deferreds = null;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, onFulfilled, onRejected) {
		var done = false;
		try {
			fn(function (value) {
				if (done) return;
				done = true;
				onFulfilled(value);
			}, function (reason) {
				if (done) return;
				done = true;
				onRejected(reason);
			})
		} catch (ex) {
			if (done) return;
			done = true;
			onRejected(ex);
		}
	}

	Promise.prototype['catch'] = function (onRejected) {
		return this.then(null, onRejected);
	};

	Promise.prototype.then = function(onFulfilled, onRejected) {
		var me = this;
		return new Promise(function(resolve, reject) {
      handle.call(me, {
        onFulfilled: onFulfilled,
        onRejected: onRejected,
        resolve: resolve,
        reject: reject
      });
		})
	};

	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (value) {
		return new Promise(function (resolve, reject) {
			reject(value);
		});
	};

	
  return Promise;
}

if (typeof module !== 'undefined') {
  module.exports = MakePromise;
}

</script>
<script>
if (!window.Promise) {
  window.Promise = MakePromise(Polymer.Base.async);
}
</script>


<script>
  Polymer({
    is: 'iron-request',

    properties: {

      /**
       * A reference to the XMLHttpRequest instance used to generate the
       * network request.
       *
       * @attribute xhr
       * @type XMLHttpRequest
       * @default `new XMLHttpRequest`
       */
      xhr: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
          return new XMLHttpRequest();
        }
      },

      /**
       * A reference to the parsed response body, if the `xhr` has completely
       * resolved.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
         return null;
        }
      },

      /**
       * A promise that resolves when the `xhr` response comes back, or rejects
       * if there is an error before the `xhr` completes.
       *
       * @attribute completes
       * @type Promise
       * @default `new Promise`
       */
      completes: {
        type: Object,
        readOnly: true,
        notify: true,
        value: function() {
          return new Promise(function (resolve, reject) {
            this.resolveCompletes = resolve;
            this.rejectCompletes = reject;
          }.bind(this));
        }
      },

      /**
       * An object that contains progress information emitted by the XHR if
       * available.
       *
       * @attribute progress
       * @type Object
       * @default {}
       */
      progress: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
          return {};
        }
      },

      /**
       * Aborted will be true if an abort of the request is attempted.
       *
       * @attribute aborted
       * @type boolean
       * @default false
       */
      aborted: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false,
      }
    },

    /**
     * Succeeded is true if the request succeeded. The request succeeded if the
     * status code is greater-than-or-equal-to 200, and less-than 300. Also,
     * the status code 0 is accepted as a success even though the outcome may
     * be ambiguous.
     *
     * @return boolean
     */
    get succeeded() {
      var status = this.xhr.status || 0;

      // Note: if we are using the file:// protocol, the status code will be 0
      // for all outcomes (successful or otherwise).
      return status === 0 ||
        (status >= 200 && status < 300);
    },

    /**
     * Sends an HTTP request to the server and returns the XHR object.
     *
     * @method request
     * @param {{
     *   url: string,
     *   method: (string|undefined),
     *   async: (boolean|undefined),
     *   body: (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined),
     *   headers: (Object|undefined),
     *   handleAs: (string|undefined),
     *   withCredentials: (boolean|undefined)}} options -
     *     url The url to which the request is sent.
     *     method The HTTP method to use, default is GET.
     *     async By default, all requests are sent asynchronously. To send synchronous requests,
     *         set to true.
     *     body The content for the request body for POST method.
     *     headers HTTP request headers.
     *     handleAs The response type. Default is 'text'.
     *     withCredentials Whether or not to send credentials on the request. Default is false.
     * @return Promise
     */
    send: function (options) {
      var xhr = this.xhr;

      if (xhr.readyState > 0) {
        return;
      }

      xhr.addEventListener('readystatechange', function () {
        if (xhr.readyState === 4 && !this.aborted) {

          if (!this.succeeded) {
            this.rejectCompletes(new Error('The request failed with status code: ' + this.xhr.status));
            return;
          }

          this._setResponse(this.parseResponse());
          this.resolveCompletes(this);
        }
      }.bind(this));

      xhr.addEventListener('progress', function (progress) {
        this._setProgress({
          lengthComputable: progress.lengthComputable,
          loaded: progress.loaded,
          total: progress.total
        });
      }.bind(this))

      xhr.addEventListener('error', function (error) {
        this.rejectCompletes(error);
      }.bind(this));

      xhr.addEventListener('abort', function () {
        this.rejectCompletes(new Error('Request aborted.'));
      }.bind(this));

      xhr.open(
        options.method || 'GET',
        options.url,
        options.async !== false
      );

      if (options.headers) {
        Object.keys(options.headers).forEach(function (requestHeader) {
          xhr.setRequestHeader(
            requestHeader,
            options.headers[requestHeader]
          );
        }, this);
      }

      // In IE, `xhr.responseType` is an empty string when the response
      // returns. Hence, caching it as `xhr._responseType`.
      xhr.responseType = xhr._responseType = (options.handleAs || 'text');
      xhr.withCredentials = !!options.withCredentials;

      xhr.send(options.body);

      return this.completes;
    },

    parseResponse: function () {
      var xhr = this.xhr;
      var responseType = this.xhr.responseType ||
        this.xhr._responseType;
      // If we don't have a natural `xhr.responseType`, we prefer parsing
      // `xhr.responseText` over returning `xhr.response`..
      var preferResponseText = !this.xhr.responseType;

      try {
        switch (responseType) {
          case 'json':
            // If xhr.response is undefined, responseType `json` may
            // not be supported.
            if (preferResponseText || xhr.response === undefined) {
              // If accessing `xhr.responseText` throws, responseType `json`
              // is supported and the result is rightly `undefined`.
              try {
                xhr.responseText;
              } catch (e) {
                return xhr.response;
              }

              // Otherwise, attempt to parse `xhr.responseText` as JSON.
              if (xhr.responseText) {
                return JSON.parse(xhr.responseText);
              }
            }

            return xhr.response;
          case 'xml':
            return xhr.responseXML;
          case 'blob':
          case 'document':
          case 'arraybuffer':
            return xhr.response;
          case 'text':
          default:
            return xhr.responseText;
        }
      } catch (e) {
        this.rejectCompletes(new Error('Could not parse response. ' + e.message));
      }
    },

    abort: function () {
      this._setAborted(true);
      this.xhr.abort();
    }
  });
</script>



<script>

  Polymer({

    is: 'iron-ajax',

    /**
     * Fired when a request is sent.
     *
     * @event request
     */

    /**
     * Fired when a response is received.
     *
     * @event response
     */

    /**
     * Fired when an error is received.
     *
     * @event error
     */

    properties: {
      /**
       * The URL target of the request.
       */
      url: {
        type: String,
        value: ''
      },

      /**
       * An object that contains query parameters to be appended to the
       * specified `url` when generating a request.
       */
      params: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
       * Default is 'GET'.
       */
      method: {
        type: String,
        value: 'GET'
      },

      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <iron-ajax
       *         auto
       *         url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handle-as="json"
       *         last-response-changed="{{handleResponse}}"></iron-ajax>
       */
      headers: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * Content type to use when sending data. If the contenttype is set
       * and a `Content-Type` header is specified in the `headers` attribute,
       * the `headers` attribute value will take precedence.
       */
      contentType: {
        type: String,
        value: 'application/x-www-form-urlencoded'
      },

      /**
       * Optional raw body content to send when method === "POST".
       *
       * Example:
       *
       *     <iron-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </iron-ajax>
       */
      body: {
        type: String,
        value: ''
      },

      /**
       * Toggle whether XHR is synchronous or asynchronous. Don't change this
       * to true unless You Know What You Are Doing™.
       */
      sync: {
        type: Boolean,
        value: false
      },

      /**
       * Specifies what data to store in the `response` property, and
       * to deliver as `event.response` in `response` events.
       *
       * One of:
       *
       *    `text`: uses `XHR.responseText`.
       *
       *    `xml`: uses `XHR.responseXML`.
       *
       *    `json`: uses `XHR.responseText` parsed as JSON.
       *
       *    `arraybuffer`: uses `XHR.response`.
       *
       *    `blob`: uses `XHR.response`.
       *
       *    `document`: uses `XHR.response`.
       */
      handleAs: {
        type: String,
        value: 'json'
      },

      /**
       * Set the withCredentials flag on the request.
       */
      withCredentials: {
        type: Boolean,
        value: false
      },

      /**
       * If true, automatically performs an Ajax request when either `url` or
       * `params` changes.
       */
      auto: {
        type: Boolean,
        value: false
      },

      /**
       * If true, error messages will automatically be logged to the console.
       */
      verbose: {
        type: Boolean,
        value: false
      },

      /**
       * Will be set to true if there is at least one in-flight request
       * associated with this iron-ajax element.
       */
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      /**
       * Will be set to the most recent request made by this iron-ajax element.
       */
      lastRequest: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * Will be set to the most recent response received by a request
       * that originated from this iron-ajax element. The type of the response
       * is determined by the value of `handleas` at the time that the request
       * was generated.
       */
      lastResponse: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * Will be set to the most recent error that resulted from a request
       * that originated from this iron-ajax element.
       */
      lastError: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * An Array of all in-flight requests originating from this iron-ajax
       * element.
       */
      activeRequests: {
        type: Array,
        notify: true,
        readOnly: true,
        value: function() {
          this._setActiveRequests([]);
        }
      },

      /**
       * Length of time in milliseconds to debounce multiple requests.
       */
      debounceDuration: {
        type: Number,
        value: 0,
        notify: true
      },

      _boundHandleResponse: {
        type: Function,
        value: function() {
          return this.handleResponse.bind(this);
        }
      },

      _boundDiscardRequest: {
        type: Function,
        value: function() {
          return this.discardRequest.bind(this);
        }
      }
    },

    observers: [
      'requestOptionsChanged(url, method, params, headers,' +
        'contentType, body, sync, handleAs, withCredentials, auto)'
    ],

    get queryString () {
      var queryParts = [];
      var param;
      var value;

      for (param in this.params) {
        value = this.params[param];
        param = window.encodeURIComponent(param);

        if (value !== null) {
          param += '=' + window.encodeURIComponent(value);
        }

        queryParts.push(param);
      }

      return queryParts.join('&');
    },

    get requestUrl() {
      var queryString = this.queryString;

      if (queryString) {
        return this.url + '?' + queryString;
      }

      return this.url;
    },

    get requestHeaders() {
      var headers = {
        'content-type': this.contentType
      };
      var header;

      if (this.headers instanceof Object) {
        for (header in this.headers) {
          headers[header] = this.headers[header].toString();
        }
      }

      return headers;
    },

    toRequestOptions: function() {
      return {
        url: this.requestUrl,
        method: this.method,
        headers: this.requestHeaders,
        body: this.body,
        async: !this.sync,
        handleAs: this.handleAs,
        withCredentials: this.withCredentials
      };
    },

    requestOptionsChanged: function() {
      this.debounce('generate-request', function() {
        if (!this.url && this.url !== '') {
          return;
        }

        if (this.auto) {
          this.generateRequest();
        }
      }, this.debounceDuration);
    },

    /**
     * Performs an AJAX request to the specified URL.
     *
     * @method generateRequest
     */
    generateRequest: function() {
      var request = document.createElement('iron-request');
      var requestOptions = this.toRequestOptions();

      this.activeRequests.push(request);

      request.completes.then(
        this._boundHandleResponse
      ).catch(
        this.handleError.bind(this, request)
      ).then(
        this._boundDiscardRequest
      );

      request.send(requestOptions);

      this._setLastRequest(request);

      this.fire('request', {
        request: request,
        options: requestOptions
      });

      return request;
    },

    handleResponse: function(request) {
      this._setLastResponse(request.response);
      this.fire('response', request);
    },

    handleError: function(request, error) {
      if (this.verbose) {
        console.error(error);
      }

      this._setLastError({
        request: request,
        error: error
      });
      this.fire('error', {
        request: request,
        error: error
      });
    },

    discardRequest: function(request) {
      var requestIndex = this.activeRequests.indexOf(request);

      if (requestIndex > 0) {
        this.activeRequests.splice(requestIndex, 1);
      }
    }
  });
</script>
<script>
(function() {
  "use strict";
  /**
    `Polymer.IronJsonpLibraryBehavior` loads a jsonp library.
    Multiple components can request same library, only one copy will load.

    Some libraries require a specific global function be defined.
    If this is the case, specify the `callbackName` property.

    You should use an HTML Import to load library dependencies
    when possible instead of using this element.

    @hero hero.svg
    @demo demo/index.html
    @polymerBehavior
   */
  Polymer.IronJsonpLibraryBehavior = {

    properties: {
      /**
       * True if library has been successfully loaded
       */
      libraryLoaded: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Not null if library has failed to load
       */
      libraryErrorMessage: {
        type: String,
        value: null,
        notify: true,
        readOnly: true
      }
      // Following properties are to be set by behavior users
      /**
       * Library url. Must contain string `%%callback_name%%`.
       *
       * `%%callback_name%%` is a placeholder for jsonp wrapper function name
       *
       * Ex: https://maps.googleapis.com/maps/api/js?callback=%%callback%%
       * @property libraryUrl
       */
      /**
       * Set if library requires specific callback name.
       * Name will be automatically generated if not set.
       * @property callbackName
       */
      /**
       * name of event to be emitted when library loads. Standard is `api-load`
       * @property notifyEvent
       */
      /**
       * event with name specified in `notifyEvent` attribute
       * will fire upon successful load2
       * @event `notifyEvent`
       */
    },

    observers: [
      '_libraryUrlChanged(libraryUrl)'
    ],

    _libraryUrlChanged: function(libraryUrl) {
      // can't load before ready because notifyEvent might not be set
      if (this._isReady && this.libraryUrl)
        this._loadLibrary();
    },

    _libraryLoadCallback: function(err, result) {
      if (err) {
        console.warn("Library load failed:", err.message);
        this._setLibraryErrorMessage(err.message);
      }
      else {
        this._setLibraryErrorMessage(null);
        this._setLibraryLoaded(true);
        if (this.notifyEvent)
          this.fire(this.notifyEvent, result);
      }
    },

    /** loads the library, and fires this.notifyEvent upon completion */
    _loadLibrary: function() {
      LoaderMap.require(
        this.libraryUrl,
        this._libraryLoadCallback.bind(this),
        this.callbackName
      );
    },

    ready: function() {
      this._isReady = true;
      if (this.libraryUrl)
        this._loadLibrary();
    }
  };

  /**
   * LoaderMap keeps track of all Loaders
   */
  var LoaderMap = {
    apiMap: {}, // { hash -> Loader }

    /**
     * @param {Function} notifyCallback loaded callback fn(result)
     * @param {string} jsonpCallbackName name of jsonpcallback. If API does not provide it, leave empty. Optional.
     */
    require: function(url, notifyCallback, jsonpCallbackName) {

      // make hashable string form url
      var name = this.nameFromUrl(url);

      // create a loader as needed
      if (!this.apiMap[name])
        this.apiMap[name] = new Loader(name, url, jsonpCallbackName);

      // ask for notification
      this.apiMap[name].requestNotify(notifyCallback);
    },

    nameFromUrl: function(url) {
      return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
    }
  };

  /** @constructor */
  var Loader = function(name, url, callbackName) {
    this.notifiers = [];  // array of notifyFn [ notifyFn* ]

    // callback is specified either as callback name
    // or computed dynamically if url has callbackMacro in it
    if (!callbackName) {
      if (url.indexOf(this.callbackMacro) >= 0) {
        callbackName = name + '_loaded';
        url = url.replace(this.callbackMacro, callbackName);
      } else {
        this.error = new Error('IronJsonpLibraryBehavior a %%callback_name%% parameter is required in libraryUrl');
        // TODO(sjmiles): we should probably fallback to listening to script.load
        return;
      }
    }
    this.callbackName = callbackName;
    window[this.callbackName] = this.success.bind(this);
    this.addScript(url);
  };

  Loader.prototype = {

    callbackMacro: '%%callback%%',
    loaded: false,

    addScript: function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.onerror = this.handleError.bind(this);
      var s = document.querySelector('script') || document.body;
      s.parentNode.insertBefore(script, s);
      this.script = script;
    },

    removeScript: function() {
      if (this.script.parentNode) {
        this.script.parentNode.removeChild(this.script);
      }
      this.script = null;
    },

    handleError: function(ev) {
      this.error = new Error("Library failed to load");
      this.notifyAll();
      this.cleanup();
    },

    success: function() {
      this.loaded = true;
      this.result = Array.prototype.slice.call(arguments);
      this.notifyAll();
      this.cleanup();
    },

    cleanup: function() {
      delete window[this.callbackName];
    },

    notifyAll: function() {
      this.notifiers.forEach( function(notifyCallback) {
        notifyCallback(this.error, this.result);
      }.bind(this));
      this.notifiers = [];
    },

    requestNotify: function(notifyCallback) {
      if (this.loaded || this.error) {
        notifyCallback( this.error, this.result);
      } else {
        this.notifiers.push(notifyCallback);
      }
    }
  };
})();
</script>


<script>
  Polymer({

    is: 'iron-jsonp-library',

    behaviors: [ Polymer.IronJsonpLibraryBehavior ],

    properties: {
      /**
       * Library url. Must contain string `%%callback_name%%`.
       *
       * `%%callback_name%%` is a placeholder for jsonp wrapper function name
       *
       * Ex: https://maps.googleapis.com/maps/api/js?callback=%%callback%%
       */
      libraryUrl: String,
      /**
       * Set if library requires specific callback name.
       * Name will be automatically generated if not set.
       */
      callbackName: String,
      /**
       * event with name specified in 'notifyEvent' attribute
       * will fire upon successful load
       */
      notifyEvent: String
      /**
       * event with name specified in 'notifyEvent' attribute
       * will fire upon successful load
       * @event `notifyEvent`
       */

    }
  });

</script>
<script>
/**
Dynamically loads the legacy Google JavaScript API Loader (https://developers.google.com/loader/).

Fires `api-load` event when ready.
*/
  Polymer({

    is: 'google-legacy-loader',

    behaviors: [
      Polymer.IronJsonpLibraryBehavior
    ],

    properties: {

      /** @private */
      libraryUrl: {
        type: String,
        value: 'https://www.google.com/jsapi?callback=%%callback%%'
      },

      /**
       * Fired when the API library is loaded and available.
       * @event js-api-load
       */
      /**
       * Name of event fired when library is loaded and available.
       */
      notifyEvent: {
        type: String,
        value: 'api-load'
      }
    },

    /**
     * Wrapper for `google` API namespace.
     */
    get api() {
      return google;
    }
  });
</script>

<script src="http://code.highcharts.com/adapters/standalone-framework.js"></script>
<script src="http://code.highcharts.com/highcharts.js"></script>
<script src="http://code.highcharts.com/highcharts-more.js"></script>
<script src="http://code.highcharts.com/modules/heatmap.js"></script>
<script src="http://code.highcharts.com/modules/treemap.js"></script>
<script src="http://code.highcharts.com/modules/drilldown.js"></script>
<script src="http://code.highcharts.com/modules/data.js"></script>

<script>
    ChartSeries = Polymer({
        is: "v-series",
        properties: {

            /**
             * Series id
             */
            id: {
                type: String
            },

            /**
             * Is drilldown series
             */
            drilldown: {
                type: Boolean,
                value: false
            },

            /**
             * Series name
             */
            name: {
                type: String
            },

            /**
             * Series type.
             */
            type: {
                type: String
            },

            /**
             * Series yAxis ID.
             */
            yAxis: {
                type: String
            },

            /**
             * Series size.
             */
            size: {
                type: String
            },

            /**
             * Series innerSize.
             */
            innerSize: {
                type: String
            },

            /**
             * Series dashStyle.
             */
            dashStyle: {
                type: String
            },

            /* ----------- internal ----------- */

            /**
             * Initial chart configuration before initial rendering.
             **/
            _seriesConf: {
                type: Object,
                value: function () {
                    return {};
                }
            }

        },

        _ignoredNodes: ["#text", "#comment"],

        /**
         * Transform the given string to camel-case
         *
         * @param {string} str
         **/
        _toCamelCase: function (str) {
            var out = "";
            str.split("-").forEach(function (word, idx) {
                var add = word.toLowerCase();
                out += (idx === 0 ? add : add[0].toUpperCase() + add.slice(1));
            });
            return out;
        },

        _parentChart: function () {
            var parent = Polymer.dom(this.root).parentNode;
            while (parent._addSeries == undefined) {
                parent = parent.parentNode;
            }
            return parent;
        },

        /**
         * Load the configuration from the element attributes and the light-DOM elements.
         **/
        _loadConfiguration: function () {
            this._loadPropertiesFromAttributes();
            var element = Polymer.dom(this);
            this._cleanNode(element);
            for (var n = 0; n < element.childNodes.length; n++) {
                var node = element.childNodes[n];
                var name = node.nodeName.toLowerCase();
                if (this._ignoredNodes.indexOf(name) === -1) {
                    var camelName = this._toCamelCase(name);
                    var value = node.textContent;
                    if (camelName === 'data') {
                        if (this._hasPointNodes(node)) {
                            value = [];
                            for (var n = 0; n < node.childNodes.length; n++) {
                                value.push(this._parsePoint(node.childNodes[n]));
                            }
                        } else {
                            value = '[' + value + ']';
                        }
                    }
                    this._setProperty(camelName, value);
                }
            }
        },

        /**
         * Creates a point object from a point node.
         **/
        _parsePoint: function(pointNode){
            var result = {};
            for (var n = 0; n < pointNode.childNodes.length; n++) {
                var node = pointNode.childNodes[n];
                var camelName = this._toCamelCase(node.nodeName.toLowerCase());
                if (result[camelName] == undefined) {
                    try {
                        result[camelName] = JSON.parse(node.textContent);
                    } catch (e) {
                        result[camelName] = node.textContent;
                    }
                }
            }
            return result;
        },

        /**
         * Checks if nodes has child nodes that correspond to points.
         **/
        _hasPointNodes: function (node) {
            return node.childNodes.length > 0 && 'point' === node.childNodes[0].nodeName.toLowerCase();
        },

        /**
         * Removes all empty text and comment nodes.
         **/
        _cleanNode: function (node) {
            for (var n = 0; n < node.childNodes.length; n++) {
                var child = node.childNodes[n];
                if (child.nodeType === 8 || (child.nodeType === 3 && !/\S/.test(child.nodeValue))) {
                    node.removeChild(child);
                    n--;
                } else if (child.nodeType === 1) {
                    this._cleanNode(child);
                }
            }
        },

        /**
         * Load the configuration from the element attributes.
         **/
        _loadPropertiesFromAttributes: function () {
            for (var property in this.properties) {
                if (this.properties.hasOwnProperty(property) && property.indexOf('_') !== 0) {
                    this._setProperty(property, this[property]);
                }
            }
        },

        /**
         * Set single property in series configuration.
         * @param {string} name
         * @param {object} value to be set
         **/
        _setProperty: function (name, value) {
            //value might be undefined because all properties are iterated in _loadPropertiesFromAttributes
            //in such case it shouldn't be set to keep _seriesConf minimal
            if (undefined != value) {
                try {
                    //try to parse as simple JSON
                    this._seriesConf[name] = JSON.parse(value);
                } catch (e) {
                    try {
                        //try to parse as JSON with js code for instance Date.UTC(...)
                        this._seriesConf[name] = eval(value);
                    } catch (e) {
                        this._seriesConf[name] = value;
                    }
                }
            }
        },

        ready: function () {
            this._loadConfiguration();
            if(this.drilldown){
                this._parentChart()._addDrilldownSeries(this._seriesConf);
            }else{
                this._parentChart()._addSeries(this._seriesConf);
            }
        }

    });
</script>
<script>
    /**
     * Behavior that provides a function for loading the Valo theme for all charts.
     *
     * @type {{_loadTheme: Function}}
     */
    ValoThemeBehavior = {
        _loadTheme: function () {
            Highcharts
                    .setOptions({
                        "colors": ["#3090F0", "#EC6464", "#98DF58", "#F9DD51", "#24DCD4",
                            "#EC64A5", "#685CB0", "#FF7D42", "#336190", "#AA514D",
                            "#7FB053", "#BBA85B", "#247981", "#963970", "#4B56A8",
                            "#9A593D"],
                        "chart": {
                            "backgroundColor": "#FFFFFF",
                            "plotBackgroundColor": "rgba(255,255,255,0.00)",
                            "plotBackgroundImage": "",
                            "plotShadow": false,
                            "plotBorderWidth": 0,
                            "plotBorderColor": "rgba(255,255,255,0.00)",
                            "className": "vaadin-chart",
                            "borderRadius": 0,
                            "style": {
                                "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                "fontSize": "14px"
                            }
                        },
                        "title": {
                            "style": {
                                "color": "#197DE1",
                                "fontWeight": "normal",
                                "fontSize": "26px"
                            }
                        },
                        "subtitle": {
                            "style": {
                                "color": "#808080",
                                "fontWeight": "normal",
                                "fontSize": "14px"
                            }
                        },
                        "xAxis": {
                            "lineColor": "#FAFAFA",
                            "lineWidth": 0,
                            "tickWidth": 0,
                            "tickColor": "#C0D0E0",
                            "gridLineColor": "#DFDFDF",
                            "gridLineWidth": 0,
                            "alternateGridColor": "rgba(255,255,255,0.00)",
                            "title": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal"
                                }
                            },
                            "subtitle": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal",
                                    "fontSize": "14px"
                                }
                            },
                            "labels": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal",
                                    "fontSize": "14px"
                                }
                            }
                        },
                        "yAxis": {
                            "minorTickInterval": "",
                            "lineColor": "#FAFAFA",
                            "lineWidth": 0,
                            "tickWidth": 0,
                            "tickColor": "#C0D0E0",
                            "gridLineColor": "#DFDFDF",
                            "gridLineWidth": 1,
                            "alternateGridColor": "rgba(255,255,255,0.00)",
                            "title": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal"
                                }
                            },
                            "subtitle": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal",
                                    "fontSize": "14px"
                                }
                            },
                            "labels": {
                                "style": {
                                    "color": "#808080",
                                    "fontWeight": "normal",
                                    "fontSize": "14px"
                                }
                            }
                        },
                        "labels": {
                            "style": {
                                "color": "#808080"
                            }
                        },
                        "legend": {
                            "borderColor": "#DFDFDF",
                            "borderRadius": 5,
                            "backgroundColor": "rgba(255,255,255,0.90)",
                            "itemStyle": {
                                "color": "#808080",
                                "fontWeight": "normal",
                                "fontSize": "14px"
                            },
                            "itemHoverStyle": {
                                "color": "#808080"
                            },
                            "itemHiddenStyle": {
                                "color": "#808080"
                            }
                        },
                        "tooltip": {
                            "backgroundColor": "#FFFFFF",
                            "borderWidth": 0,
                            "borderRadius": 5,
                            "followPointer": false,
                            "style": {
                                "color": "#333333"
                            }
                        },
                        "plotOptions": {
                            "bar": {
                                "pointPadding": 0,
                                "borderWidth": 0,
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "area": {
                                "shadow": false
                            },
                            "arearange": {
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "areaspline": {},
                            "areasplinerange": {
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "pie": {
                                "borderWidth": 0,
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                },
                                "states": {
                                    "hover": {
                                        "enabled": false
                                    }
                                }
                            },
                            "line": {
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "column": {
                                "pointPadding": 0,
                                "borderWidth": 0,
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "spline": {
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "series": {},
                            "pyramid": {
                                "borderWidth": 0,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            },
                            "waterfall": {
                                "borderWidth": 0,
                                "shadow": false,
                                "dataLabels": {
                                    "style": {
                                        "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                                        "fontSize": "12px"
                                    },
                                    "color": "#808080"
                                }
                            }
                        },
                        "credits": {
                            "text": "",
                            "href": "",
                            "style": {
                                "color": "#808080",
                                "fontSize": "14px"
                            }
                        }
                    });
        }
    }
</script>

<script>
/**
Dynamically loads the Google Maps JavaScript API, firing the `api-load` event when ready.

#### Example

    <google-maps-api apiKey="abc123" version="3.exp"></google-maps-api>
    <script>
      var mapsAPI = document.querySelector('google-maps-api');
      mapsAPI.addEventListener('api-load', function(e) {
        // this.api === google.maps
      });
    <script>

Any number of components can use `<google-maps-api>` elements, and the library will only be loaded once.

@blurb Element wrapper around Google Maps API.

 */
  Polymer({

    is: 'google-maps-api',

    behaviors: [
      Polymer.IronJsonpLibraryBehavior
    ],

    properties: {

      /** @private */
      mapsUrl: {
        type: String,
        value: 'https://maps.googleapis.com/maps/api/js?callback=%%callback%%'
      },

      /**
       * A Maps API key. To obtain an API key, see developers.google.com/maps/documentation/javascript/tutorial#api_key.
       */
      apiKey: {
        type: String,
        value: ''
      },

      /**
       * A Maps API for Business Client ID. To obtain a Maps API for Business Client ID, see developers.google.com/maps/documentation/business/.
       * If set, a Client ID will take precedence over an API Key.
       */
      clientId: {
        type: String,
        value: ''
      },

      /**
       * The libraries to load with this map. Defaults to "places". For more information
       * see https://developers.google.com/maps/documentation/javascript/libraries.
       */
      libraries: {
        type: String,
        value: 'places'
      },

      /**
       * Version of the Maps API to use.
       */
      version: {
        type: String,
        value: '3.exp'
      },

      /**
       * The localized language to load the Maps API with. For more information
       * see https://developers.google.com/maps/documentation/javascript/basics#Language
       *
       * Note: the Maps API defaults to the preffered language setting of the browser.
       * Use this parameter to override that behavior.
       */
      language: {
        type: String,
        value: ''
      },
      /**
       * If true, sign-in is enabled.
       * See https://developers.google.com/maps/documentation/javascript/signedin#enable_sign_in
       */
      signedIn: {
        type: Boolean,
        value: false
      },

      /**
       * Fired when the Maps API library is loaded and ready.
       * @event api-load
       */
      /**
       * Name of event fired when library is loaded and available.
       */
      notifyEvent: {
        type: String,
        value: 'api-load'
      },

      /** @private */
      libraryUrl: {
        type: String,
        computed: '_computeUrl(mapsUrl, version, libraries, apiKey, clientId, language, signedIn)'
      }
    },

    _computeUrl: function(mapsUrl, version, libraries, apiKey, clientId, language, signedIn) {
      var url = mapsUrl + '&v=' + version;
      url += "&libraries=" + libraries;

      if (apiKey && !clientId) {
        url += '&key=' + apiKey;
      }

      if (clientId) {
        url += '&client=' + clientId;
      }

      if (language) {
        url += '&language=' + language;
      }

      if (signedIn) {
        url += '&signed_in=' + signedIn;
      }
      return url;
    },

    /**
     * Provides the google.maps JS API namespace.
     */
    get api() {
      return google.maps;
    }
  });
</script>






</head><body><div hidden="" by-vulcanize=""><dom-module id="iron-icon" assetpath="../bower_components/iron-icon/">

  <style>
    :host {
      @apply(--layout-inline);
      @apply(--layout-center-center);
      position: relative;

      vertical-align: middle;

      fill: currentcolor;

      width: var(--iron-icon-width, 24px);
      height: var(--iron-icon-height, 24px);
    }
  </style>

  <template>
    <iron-meta id="meta" type="iconset"></iron-meta>
  </template>

  <script>

    Polymer({

      is: 'iron-icon',

      properties: {

        /**
         * The name of the icon to use. The name should be of the form:
         * `iconset_name:icon_name`.
         */
        icon: {
          type: String,
          observer: '_iconChanged'
        },

        /**
         * The name of the theme to used, if one is specified by the
         * iconset.
         */
        theme: {
          type: String,
          observer: '_updateIcon'
        },

        /**
         * If using iron-icon without an iconset, you can set the src to be
         * the URL of an individual icon image file. Note that this will take
         * precedence over a given icon attribute.
         */
        src: {
          type: String,
          observer: '_srcChanged'
        }
      },

      _DEFAULT_ICONSET: 'icons',

      _iconChanged: function(icon) {
        var parts = (icon || '').split(':');
        this._iconName = parts.pop();
        this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
        this._updateIcon();
      },

      _srcChanged: function(src) {
        this._updateIcon();
      },

      _usesIconset: function() {
        return this.icon || !this.src;
      },

      _updateIcon: function() {
        if (this._usesIconset()) {
          if (this._iconsetName) {
            this._iconset = this.$.meta.byKey(this._iconsetName);
            if (this._iconset) {
              this._iconset.applyIcon(this, this._iconName, this.theme);
            } else {
              this._warn(this._logf('_updateIcon', 'could not find iconset `'
                + this._iconsetName + '`, did you import the iconset?'));
            }
          }
        } else {
          if (!this._img) {
            this._img = document.createElement('img');
            this._img.style.width = '100%';
            this._img.style.height = '100%';
          }
          this._img.src = this.src;
          Polymer.dom(this.root).appendChild(this._img);
        }
      }

    });

  </script>

</dom-module>
<iron-iconset-svg name="icons" size="24">
<svg><defs>
<g id="3d-rotation"><path d="M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43C9.1 8.05 8.76 8 8.39 8c-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09H7.5v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27H12v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zM12 0l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5C23.44 4.84 18.29 0 12 0z"></path></g>
<g id="accessibility"><path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"></path></g>
<g id="account-balance"><path d="M4 10v7h3v-7H4zm6 0v7h3v-7h-3zM2 22h19v-3H2v3zm14-12v7h3v-7h-3zm-4.5-9L2 6v2h19V6l-9.5-5z"></path></g>
<g id="account-balance-wallet"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="account-box"><path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1z"></path></g>
<g id="account-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></g>
<g id="add"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
<g id="add-alert"><path d="M10.01 21.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98zm8.87-4.19V11c0-3.25-2.25-5.97-5.29-6.69v-.72C13.59 2.71 12.88 2 12 2s-1.59.71-1.59 1.59v.72C7.37 5.03 5.12 7.75 5.12 11v5.82L3 18.94V20h18v-1.06l-2.12-2.12zM16 13.01h-3v3h-2v-3H8V11h3V8h2v3h3v2.01z"></path></g>
<g id="add-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle-outline"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="add-shopping-cart"><path d="M11 9h2V6h3V4h-3V1h-2v3H8v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01L19.42 4h-.01l-1.1 2-2.76 5H8.53l-.13-.27L6.16 6l-.95-2-.94-2H1v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.13 0-.25-.11-.25-.25z"></path></g>
<g id="alarm"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="alarm-add"><path d="M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z"></path></g>
<g id="alarm-off"><path d="M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91L9.6 6.43C10.35 6.16 11.16 6 12 6zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM2.92 2.29L1.65 3.57 2.98 4.9l-1.11.93 1.42 1.42 1.11-.94.8.8C3.83 8.69 3 10.75 3 13c0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27L3.89 3.27l-.97-.98zm13.55 16.1C15.26 19.39 13.7 20 12 20c-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zM8.02 3.28L6.6 1.86l-.86.71 1.42 1.42.86-.71z"></path></g>
<g id="alarm-on"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47L8.41 12.4l-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z"></path></g>
<g id="android"><path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48C13.85 1.23 12.95 1 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31C6.97 3.26 6 5.01 6 7h12c0-1.99-.97-3.75-2.47-4.84zM10 5H9V4h1v1zm5 0h-1V4h1v1z"></path></g>
<g id="announcement"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z"></path></g>
<g id="apps"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
<g id="archive"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"></path></g>
<g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
<g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
<g id="arrow-drop-down-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path></g>
<g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
<g id="arrow-forward"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></g>
<g id="aspect-ratio"><path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="assessment"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="assignment"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
<g id="assignment-ind"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V19z"></path></g>
<g id="assignment-late"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2V8h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></g>
<g id="assignment-return"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z"></path></g>
<g id="assignment-returned"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3V9h4v4h3l-5 5z"></path></g>
<g id="assignment-turned-in"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="attachment"><path d="M7.5 18C4.46 18 2 15.54 2 12.5S4.46 7 7.5 7H18c2.21 0 4 1.79 4 4s-1.79 4-4 4H9.5C8.12 15 7 13.88 7 12.5S8.12 10 9.5 10H17v1.5H9.5c-.55 0-1 .45-1 1s.45 1 1 1H18c1.38 0 2.5-1.12 2.5-2.5S19.38 8.5 18 8.5H7.5c-2.21 0-4 1.79-4 4s1.79 4 4 4H17V18H7.5z"></path></g>
<g id="autorenew"><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path></g>
<g id="backspace"><path d="M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-3 12.59L17.59 17 14 13.41 10.41 17 9 15.59 12.59 12 9 8.41 10.41 7 14 10.59 17.59 7 19 8.41 15.41 12 19 15.59z"></path></g>
<g id="backup"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="block"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"></path></g>
<g id="book"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="bookmark"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="bookmark-border"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="bug-report"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path></g>
<g id="build"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path></g>
<g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path></g>
<g id="camera-enhance"><path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zM12 17l1.25-2.75L16 13l-2.75-1.25L12 9l-1.25 2.75L8 13l2.75 1.25z"></path></g>
<g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
<g id="card-giftcard"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="card-membership"><path d="M20 2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2V4c0-1.11-.89-2-2-2zm0 13H4v-2h16v2zm0-5H4V4h16v6z"></path></g>
<g id="card-travel"><path d="M20 6h-3V4c0-1.11-.89-2-2-2H9c-1.11 0-2 .89-2 2v2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zM9 4h6v2H9V4zm11 15H4v-2h16v2zm0-5H4V8h3v2h2V8h6v2h2V8h3v6z"></path></g>
<g id="change-history"><path d="M12 7.77L18.39 18H5.61L12 7.77M12 4L2 20h20L12 4z"></path></g>
<g id="check"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
<g id="check-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="check-box-outline-blank"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="check-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
<g id="chrome-reader-mode"><path d="M13 12h7v1.5h-7zm0-2.5h7V11h-7zm0 5h7V16h-7zM21 4H3c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 15h-9V6h9v13z"></path></g>
<g id="class"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="cloud"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path></g>
<g id="cloud-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.5 14H8c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01C8.58 8.28 10.13 7 12 7c2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5S17.88 16 16.5 16z"></path></g>
<g id="cloud-done"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41L10 17z"></path></g>
<g id="cloud-download"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"></path></g>
<g id="cloud-off"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2L21 20.73 4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"></path></g>
<g id="cloud-queue"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 7.69 9.48 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3s-1.34 3-3 3z"></path></g>
<g id="cloud-upload"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="code"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></g>
<g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
<g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"></path></g>
<g id="content-paste"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path></g>
<g id="create"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="credit-card"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="dashboard"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></g>
<g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
<g id="description"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"></path></g>
<g id="dns"><path d="M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zM7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="done"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></g>
<g id="done-all"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"></path></g>
<g id="drafts"><path d="M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z"></path></g>
<g id="eject"><path d="M5 17h14v2H5zm7-12L5.33 15h13.34z"></path></g>
<g id="error"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
<g id="error-outline"><path d="M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="event"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></g>
<g id="event-seat"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M4 18v3h3v-3h10v3h3v-6H4zm15-8h3v3h-3zM2 10h3v3H2zm15 3H7V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v8z" clip-path="url(#b)"></path></g>
<g id="exit-to-app"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
<g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
<g id="explore"><path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z"></path></g>
<g id="extension"><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"></path></g>
<g id="face"><path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"></path></g>
<g id="favorite"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></g>
<g id="favorite-border"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"></path></g>
<g id="feedback"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z"></path></g>
<g id="file-download"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="file-upload"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"></path></g>
<g id="filter-list"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g>
<g id="find-in-page"><path d="M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path></g>
<g id="find-replace"><path d="M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z"></path></g>
<g id="flag"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></g>
<g id="flight-land"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><defs><path id="c" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><clipPath id="d" clip-path="url(#b)"><use xlink:href="#c" overflow="visible"></use></clipPath><path d="M2.5 19h19v2h-19zm7.18-5.73l4.35 1.16 5.31 1.42c.8.21 1.62-.26 1.84-1.06.21-.8-.26-1.62-1.06-1.84l-5.31-1.42-2.76-9.02L10.12 2v8.28L5.15 8.95l-.93-2.32-1.45-.39v5.17l1.6.43 5.31 1.43z" clip-path="url(#d)"></path></g>
<g id="flight-takeoff"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M2.5 19h19v2h-19zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 1.82 3.16.77 1.33 1.6-.43 5.31-1.42 4.35-1.16L21 11.49c.81-.23 1.28-1.05 1.07-1.85z" clip-path="url(#b)"></path></g>
<g id="flip-to-back"><path d="M9 7H7v2h2V7zm0 4H7v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2V3zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2V3zM9 17v-2H7c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2V7h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zM5 7H3v12c0 1.1.89 2 2 2h12v-2H5V7zm10-2h2V3h-2v2zm0 12h2v-2h-2v2z"></path></g>
<g id="flip-to-front"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.89 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z"></path></g>
<g id="folder"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"></path></g>
<g id="folder-open"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"></path></g>
<g id="folder-shared"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path></g>
<g id="font-download"><path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"></path></g>
<g id="forward"><path d="M12 8V4l8 8-8 8v-4H4V8z"></path></g>
<g id="fullscreen"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></g>
<g id="fullscreen-exit"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></g>
<g id="gesture"><path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path></g>
<g id="get-app"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="gif"><defs><path id="a" d="M24 24H0V0h24v24z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M11.5 9H13v6h-1.5zM9 9H6c-.6 0-1 .5-1 1v4c0 .5.4 1 1 1h3c.6 0 1-.5 1-1v-2H8.5v1.5h-2v-3H10V10c0-.5-.4-1-1-1zm10 1.5V9h-4.5v6H16v-2h2v-1.5h-2v-1z" clip-path="url(#b)"></path></g>
<g id="grade"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="group-work"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM8 17.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM9.5 8c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="help"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></g>
<g id="help-outline"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></g>
<g id="highlight-off"><path d="M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="history"><path opacity=".9" d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="home"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></g>
<g id="hourglass-empty"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5l-4-4V4h8v3.5l-4 4z"></path></g>
<g id="hourglass-full"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6z"></path></g>
<g id="http"><path d="M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5v2zm2.5-.5h1.5V15H10v-4.5h1.5V9H7v1.5zm5.5 0H14V15h1.5v-4.5H17V9h-4.5v1.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5zm0 2.5h-2v-1h2v1z"></path></g>
<g id="https"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="inbox"><path d="M19 3H4.99c-1.1 0-1.98.9-1.98 2L3 19c0 1.1.89 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.34 3-3 3s-3-1.34-3-3H4.99V5H19v10zm-3-5h-2V7h-4v3H8l4 4 4-4z"></path></g>
<g id="indeterminate-check-box"><defs><path id="a" d="M0 0h24v24H0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path clip-path="url(#b)" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"></path></g>
<g id="info"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></g>
<g id="info-outline"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"></path></g>
<g id="input"><path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"></path></g>
<g id="invert-colors"><path d="M17.66 7.93L12 2.27 6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58c2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"></path></g>
<g id="label"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"></path></g>
<g id="label-outline"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16zM16 17H5V7h11l3.55 5L16 17z"></path></g>
<g id="language"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"></path></g>
<g id="launch"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="link"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path></g>
<g id="list"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></g>
<g id="lock"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="lock-open"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"></path></g>
<g id="lock-outline"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6-5.1c1.71 0 3.1 1.39 3.1 3.1v2H9V6h-.1c0-1.71 1.39-3.1 3.1-3.1zM18 20H6V10h12v10zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
<g id="loyalty"><path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7zm11.77 8.27L13 19.54l-4.27-4.27C8.28 14.81 8 14.19 8 13.5c0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z"></path></g>
<g id="mail"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread-mailbox"><path d="M20 6H10v6H8V4h6V0H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"></path></g>
<g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
<g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="note-add"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"></path></g>
<g id="offline-pin"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path clip-path="url(#b)" d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm5 16H7v-2h10v2zm-6.7-4L7 10.7l1.4-1.4 1.9 1.9 5.3-5.3L17 7.3 10.3 14z"></path></g>
<g id="open-in-browser"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2H5V8h14v10h-4v2h4c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z"></path></g>
<g id="open-in-new"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="open-with"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"></path></g>
<g id="pageview"><path d="M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z"></path></g>
<g id="payment"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="perm-camera-mic"><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91V21h7c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2V9c0-1.1.9-2 2-2s2 .9 2 2v4z"></path></g>
<g id="perm-contact-calendar"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"></path></g>
<g id="perm-data-setting"><path d="M18.99 11.5c.34 0 .67.03 1 .07L20 0 0 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="perm-device-information"><path d="M13 7h-2v2h2V7zm0 4h-2v6h2v-6zm4-9.99L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"></path></g>
<g id="perm-identity"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="perm-media"><path d="M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z"></path></g>
<g id="perm-phone-msg"><path d="M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM12 3v10l3-3h6V3h-9z"></path></g>
<g id="perm-scan-wifi"><path d="M12 3C6.95 3 3.15 4.85 0 7.23L12 22 24 7.25C20.85 4.87 17.05 3 12 3zm1 13h-2v-6h2v6zm-2-8V6h2v2h-2z"></path></g>
<g id="picture-in-picture"><path d="M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"></path></g>
<g id="play-for-work"><path fill="#010101" d="M11 5v5.59H7.5l4.5 4.5 4.5-4.5H13V5h-2zm-5 9c0 3.31 2.69 6 6 6s6-2.69 6-6h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H6z"></path></g>
<g id="polymer"><path d="M19 4h-4L7.11 16.63 4.5 12 9 4H5L.5 12 5 20h4l7.89-12.63L19.5 12 15 20h4l4.5-8z"></path></g>
<g id="power-settings-new"><path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"></path></g>
<g id="print"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"></path></g>
<g id="query-builder"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="question-answer"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path></g>
<g id="radio-button-checked"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="radio-button-unchecked"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="receipt"><path d="M18 17H6v-2h12v2zm0-4H6v-2h12v2zm0-4H6V7h12v2zM3 22l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20z"></path></g>
<g id="redeem"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="redo"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path></g>
<g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
<g id="remove"><path d="M19 13H5v-2h14v2z"></path></g>
<g id="remove-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g>
<g id="remove-circle-outline"><path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="reorder"><path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"></path></g>
<g id="reply"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="reply-all"><path d="M7 8V5l-7 7 7 7v-3l-4-4 4-4zm6 1V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="report"><path d="M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"></path></g>
<g id="report-problem"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="restore"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="room"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="save"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></g>
<g id="schedule"><path fill-opacity=".9" d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="search"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></g>
<g id="select-all"><path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"></path></g>
<g id="send"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
<g id="settings"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></g>
<g id="settings-applications"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z"></path></g>
<g id="settings-backup-restore"><path d="M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9H0l4 4 4-4H5c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44C8.04 20.3 9.94 21 12 21c4.97 0 9-4.03 9-9s-4.03-9-9-9z"></path></g>
<g id="settings-bluetooth"><path d="M11 24h2v-2h-2v2zm-4 0h2v-2H7v2zm8 0h2v-2h-2v2zm2.71-18.29L12 0h-1v7.59L6.41 3 5 4.41 10.59 10 5 15.59 6.41 17 11 12.41V20h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 3.83l1.88 1.88L13 7.59V3.83zm1.88 10.46L13 16.17v-3.76l1.88 1.88z"></path></g>
<g id="settings-brightness"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5V16zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3V9z"></path></g>
<g id="settings-cell"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM16 .01L8 0C6.9 0 6 .9 6 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V2c0-1.1-.9-1.99-2-1.99zM16 16H8V4h8v12z"></path></g>
<g id="settings-ethernet"><path d="M7.77 6.76L6.23 5.48.82 12l5.41 6.52 1.54-1.28L3.42 12l4.35-5.24zM7 13h2v-2H7v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28L20.58 12l-4.35 5.24 1.54 1.28L23.18 12l-5.41-6.52z"></path></g>
<g id="settings-input-antenna"><path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"></path></g>
<g id="settings-input-component"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-composite"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-hdmi"><path d="M18 7V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v3H5v6l3 6v3h8v-3l3-6V7h-1zM8 4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z"></path></g>
<g id="settings-input-svideo"><path d="M8 11.5c0-.83-.67-1.5-1.5-1.5S5 10.67 5 11.5 5.67 13 6.5 13 8 12.33 8 11.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3C9.67 5 9 5.67 9 6.5S9.67 8 10.5 8h3c.83 0 1.5-.67 1.5-1.5zM8.5 15c-.83 0-1.5.67-1.5 1.5S7.67 18 8.5 18s1.5-.67 1.5-1.5S9.33 15 8.5 15zM12 1C5.93 1 1 5.93 1 12s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path></g>
<g id="settings-overscan"><path d="M12.01 5.5L10 8h4l-1.99-2.5zM18 10v4l2.5-1.99L18 10zM6 10l-2.5 2.01L6 14v-4zm8 6h-4l2.01 2.5L14 16zm7-13H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="settings-phone"><path d="M13 9h-2v2h2V9zm4 0h-2v2h2V9zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 9v2h2V9h-2z"></path></g>
<g id="settings-power"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm2-22h-2v10h2V2zm3.56 2.44l-1.45 1.45C16.84 6.94 18 8.83 18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12L7.44 4.44C5.36 5.88 4 8.28 4 11c0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zM15 24h2v-2h-2v2z"></path></g>
<g id="settings-remote"><path d="M15 9H9c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V10c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM7.05 6.05l1.41 1.41C9.37 6.56 10.62 6 12 6s2.63.56 3.54 1.46l1.41-1.41C15.68 4.78 13.93 4 12 4s-3.68.78-4.95 2.05zM12 0C8.96 0 6.21 1.23 4.22 3.22l1.41 1.41C7.26 3.01 9.51 2 12 2s4.74 1.01 6.36 2.64l1.41-1.41C17.79 1.23 15.04 0 12 0z"></path></g>
<g id="settings-voice"><path d="M7 24h2v-2H7v2zm5-11c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1S6.7 13 6.7 10H5c0 3.41 2.72 6.23 6 6.72V20h2v-3.28c3.28-.49 6-3.31 6-6.72z"></path></g>
<g id="shop"><path d="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z"></path></g>
<g id="shop-two"><path d="M3 9H1v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2H3V9zm15-4V3c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5h-5zm-6-2h4v2h-4V3zm0 12V8l5.5 3-5.5 4z"></path></g>
<g id="shopping-basket"><path d="M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="shopping-cart"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="sort"><path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"></path></g>
<g id="speaker-notes"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z"></path></g>
<g id="spellcheck"><path d="M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z"></path></g>
<g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="star-border"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
<g id="star-half"><path d="M22 9.74l-7.19-.62L12 2.5 9.19 9.13 2 9.74l5.46 4.73-1.64 7.03L12 17.77l6.18 3.73-1.63-7.03L22 9.74zM12 15.9V6.6l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.9z"></path></g>
<g id="stars"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm4.24 16L12 15.45 7.77 18l1.12-4.81-3.73-3.23 4.92-.42L12 5l1.92 4.53 4.92.42-3.73 3.23L16.23 18z"></path></g>
<g id="store"><path d="M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z"></path></g>
<g id="subject"><path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"></path></g>
<g id="supervisor-account"><path d="M16.5 12c1.38 0 2.49-1.12 2.49-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 2.99-1.34 2.99-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"></path></g>
<g id="swap-horiz"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"></path></g>
<g id="swap-vert"><path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"></path></g>
<g id="swap-vertical-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z"></path></g>
<g id="system-update-alt"><path d="M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.99h6v14.03H3V5.49h6V3.5H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path></g>
<g id="tab"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z"></path></g>
<g id="tab-unselected"><path d="M1 9h2V7H1v2zm0 4h2v-2H1v2zm0-8h2V3c-1.1 0-2 .9-2 2zm8 16h2v-2H9v2zm-8-4h2v-2H1v2zm2 4v-2H1c0 1.1.9 2 2 2zM21 3h-8v6h10V5c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zM9 5h2V3H9v2zM5 21h2v-2H5v2zM5 5h2V3H5v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z"></path></g>
<g id="text-format"><path d="M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z"></path></g>
<g id="theaters"><path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"></path></g>
<g id="thumb-down"><path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"></path></g>
<g id="thumb-up"><path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path></g>
<g id="thumbs-up-down"><path d="M12 6c0-.55-.45-1-1-1H5.82l.66-3.18.02-.23c0-.31-.13-.59-.33-.8L5.38 0 .44 4.94C.17 5.21 0 5.59 0 6v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55V6zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z"></path></g>
<g id="toc"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"></path></g>
<g id="today"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"></path></g>
<g id="toll"><path d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zM3 12c0-2.61 1.67-4.83 4-5.65V4.26C3.55 5.15 1 8.27 1 12s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65z"></path></g>
<g id="track-changes"><path fill="#231F20" d="M19.07 4.93l-1.41 1.41C19.1 7.79 20 9.79 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z"></path></g>
<g id="translate"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></g>
<g id="trending-down"><path d="M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z"></path></g>
<g id="trending-flat"><path d="M22 12l-4-4v3H3v2h15v3z"></path></g>
<g id="trending-up"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"></path></g>
<g id="turned-in"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="turned-in-not"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path></g>
<g id="unfold-less"><path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path></g>
<g id="unfold-more"><path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path></g>
<g id="verified-user"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="view-agenda"><path d="M20 13H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"></path></g>
<g id="view-array"><path d="M4 18h3V5H4v13zM18 5v13h3V5h-3zM8 18h9V5H8v13z"></path></g>
<g id="view-carousel"><path d="M7 19h10V4H7v15zm-5-2h4V6H2v11zM18 6v11h4V6h-4z"></path></g>
<g id="view-column"><path d="M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z"></path></g>
<g id="view-day"><path d="M2 21h19v-3H2v3zM20 8H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zM2 3v3h19V3H2z"></path></g>
<g id="view-headline"><path d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"></path></g>
<g id="view-list"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path></g>
<g id="view-module"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"></path></g>
<g id="view-quilt"><path d="M10 18h5v-6h-5v6zm-6 0h5V5H4v13zm12 0h5v-6h-5v6zM10 5v6h11V5H10z"></path></g>
<g id="view-stream"><path d="M4 18h17v-6H4v6zM4 5v6h17V5H4z"></path></g>
<g id="view-week"><path d="M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"></path></g>
<g id="visibility"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="visibility-off"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path></g>
<g id="warning"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="work"><path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"></path></g>
<g id="youtube-searched-for"><path d="M17.01 14h-.8l-.27-.27c.98-1.14 1.57-2.61 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51C6.51 7 8.53 5 11.01 5s4.5 2.01 4.5 4.5c0 2.48-2.02 4.5-4.5 4.5-.65 0-1.26-.14-1.82-.38L7.71 15.1c.97.57 2.09.9 3.3.9 1.61 0 3.08-.59 4.22-1.57l.27.27v.79l5.01 4.99L22 19l-4.99-5z"></path></g>
<g id="zoom-in"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"></path></g>
<g id="zoom-out"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"></path></g>
</defs></svg>
</iron-iconset-svg>
<dom-module id="iron-pages" assetpath="../bower_components/iron-pages/">

  <style>

    :host {
      display: block;
    }

    :host > ::content > :not(.iron-selected) {
      display: none !important;
    }

  </style>

  <template>

    <content></content>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'iron-pages',

    behaviors: [
      Polymer.IronResizableBehavior,
      Polymer.IronSelectableBehavior
    ],

    properties: {

      // as the selected page is the only one visible, activateEvent
      // is both non-sensical and problematic; e.g. in cases where a user
      // handler attempts to change the page and the activateEvent
      // handler immediately changes it back
      activateEvent: {
        value: null
      }

    },

    observers: [
      '_selectedPageChanged(selected)'
    ],

    _selectedPageChanged: function(selected, old) {
      this.async(this.notifyResize);
    }
  });

</script>
<dom-module id="paper-drawer-panel" assetpath="../bower_components/paper-drawer-panel/">
  <style>
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

iron-selector > #drawer {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background-color: white;

  -moz-box-sizing: border-box;
  box-sizing: border-box;

  @apply(--paper-drawer-panel-drawer-container);
}

.transition > #drawer {
  transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
  transition: transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
}

.left-drawer > #drawer {
  @apply(--paper-drawer-panel-left-drawer-container);
}

.right-drawer > #drawer {
  left: auto;
  right: 0;

  @apply(--paper-drawer-panel-right-drawer-container);
}

iron-selector > #main {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;

  @apply(--paper-drawer-panel-main-container);
}

.transition > #main {
  transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
}

.right-drawer > #main {
  left: 0;
}

.right-drawer.transition > #main {
  transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
}

#main > ::content > [main] {
  height: 100%;
}

#drawer > ::content > [drawer] {
  height: 100%;
}

#scrim {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  visibility: hidden;
  opacity: 0;
  transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
  background-color: rgba(0, 0, 0, 0.3);
}

.narrow-layout > #drawer {
  will-change: transform;
}

.narrow-layout > #drawer.iron-selected {
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
}

.right-drawer.narrow-layout > #drawer.iron-selected {
  box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
}

.narrow-layout > #drawer > ::content > [drawer] {
  border: 0;
}

.left-drawer.narrow-layout > #drawer:not(.iron-selected) {
  -webkit-transform: translateX(-100%);
  transform: translateX(-100%);
}

.right-drawer.narrow-layout > #drawer:not(.iron-selected) {
  left: auto;
  visibility: hidden;

  -webkit-transform: translateX(100%);
  transform: translateX(100%);
}

.right-drawer.narrow-layout.dragging > #drawer:not(.iron-selected),
.right-drawer.narrow-layout.peeking > #drawer:not(.iron-selected) {
  visibility: visible;
}

.narrow-layout > #main {
  padding: 0;
}

.right-drawer.narrow-layout > #main {
  left: 0;
  right: 0;
}

.narrow-layout > #main:not(.iron-selected) > #scrim,
.dragging > #main > #scrim {
  visibility: visible;
  opacity: var(--paper-drawer-panel-scrim-opacity, 1);
}

.narrow-layout > #main > * {
  margin: 0;
  min-height: 100%;
  left: 0;
  right: 0;

  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

iron-selector:not(.narrow-layout) #main ::content [paper-drawer-toggle] {
  display: none;
}
</style>

  <template>
    <iron-media-query id="mq" on-query-matches-changed="_onQueryMatchesChanged" query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]">
    </iron-media-query>

    <iron-selector attr-for-selected="id" class$="[[_computeIronSelectorClass(narrow, transition, dragging, rightDrawer, peeking)]]" activate-event="" selected="[[selected]]">

      <div id="main" style$="[[_computeMainStyle(narrow, rightDrawer, drawerWidth)]]">
        <content select="[main]"></content>
        <div id="scrim" on-tap="closeDrawer"></div>
      </div>

      <div id="drawer" style$="[[_computeDrawerStyle(drawerWidth)]]">
        <content select="[drawer]"></content>
      </div>

    </iron-selector>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

   // this would be the only `paper-drawer-panel` in
   // the whole app that can be in `dragging` state
    var sharedPanel = null;

    function classNames(obj) {
      var classes = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classes.push(key);
        }
      }

      return classes.join(' ');
    }

    Polymer({

      is: 'paper-drawer-panel',

      /**
       * Fired when the narrow layout changes.
       *
       * @event paper-responsive-change {{narrow: boolean}} detail -
       *     narrow: true if the panel is in narrow layout.
       */

      /**
       * Fired when the a panel is selected.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is selected.
       *
       * @event iron-select {{item: Object}} detail -
       *     item: The panel that the event refers to.
       */

      /**
       * Fired when a panel is deselected.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is deselected.
       *
       * @event iron-deselect {{item: Object}} detail -
       *     item: The panel that the event refers to.
       */
      properties: {

        /**
         * The panel to be selected when `paper-drawer-panel` changes to narrow
         * layout.
         */
        defaultSelected: {
          type: String,
          value: 'main'
        },

        /**
         * If true, swipe from the edge is disable.
         */
        disableEdgeSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * If true, swipe to open/close the drawer is disabled.
         */
        disableSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the user is dragging the drawer interactively.
         */
        dragging: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Width of the drawer panel.
         */
        drawerWidth: {
          type: String,
          value: '256px'
        },

        /**
         * How many pixels on the side of the screen are sensitive to edge
         * swipes and peek.
         */
        edgeSwipeSensitivity: {
          type: Number,
          value: 30
        },

        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         */
        forceNarrow: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the browser has support for the transform CSS property.
         */
        hasTransform: {
          type: Boolean,
          value: function() {
            return 'transform' in this.style;
          }
        },

        /**
         * Whether the browser has support for the will-change CSS property.
         */
        hasWillChange: {
          type: Boolean,
          value: function() {
            return 'willChange' in this.style;
          }
        },

        /**
         * Returns true if the panel is in narrow layout.  This is useful if you
         * need to show/hide elements based on the layout.
         */
        narrow: {
          reflectToAttribute: true,
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Whether the drawer is peeking out from the edge.
         */
        peeking: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Max-width when the panel changes to narrow layout.
         */
        responsiveWidth: {
          type: String,
          value: '640px'
        },

        /**
         * If true, position the drawer to the right.
         */
        rightDrawer: {
          type: Boolean,
          value: false
        },

        /**
         * The panel that is being selected. `drawer` for the drawer panel and
         * `main` for the main panel.
         */
        selected: {
          reflectToAttribute: true,
          notify: true,
          type: String,
          value: null
        },

        /**
         * The attribute on elements that should toggle the drawer on tap, also elements will
         * automatically be hidden in wide layout.
         */
        drawerToggleAttribute: {
          type: String,
          value: 'paper-drawer-toggle'
        },

        /**
         * Whether the transition is enabled.
         */
        transition: {
          type: Boolean,
          value: false
        },

      },

      listeners: {
        tap: '_onTap',
        track: '_onTrack',
        down: '_downHandler',
        up: '_upHandler'
      },

      observers: [
        '_forceNarrowChanged(forceNarrow, defaultSelected)'
      ],

      /**
       * Toggles the panel open and closed.
       *
       * @method togglePanel
       */
      togglePanel: function() {
        if (this._isMainSelected()) {
          this.openDrawer();
        } else {
          this.closeDrawer();
        }
      },

      /**
       * Opens the drawer.
       *
       * @method openDrawer
       */
      openDrawer: function() {
        this.selected = 'drawer';
      },

      /**
       * Closes the drawer.
       *
       * @method closeDrawer
       */
      closeDrawer: function() {
        this.selected = 'main';
      },

      ready: function() {
        // Avoid transition at the beginning e.g. page loads and enable
        // transitions only after the element is rendered and ready.
        this.transition = true;
      },

      _computeIronSelectorClass: function(narrow, transition, dragging, rightDrawer, peeking) {
        return classNames({
          dragging: dragging,
          'narrow-layout': narrow,
          'right-drawer': rightDrawer,
          'left-drawer': !rightDrawer,
          transition: transition,
          peeking: peeking
        });
      },

      _computeDrawerStyle: function(drawerWidth) {
        return 'width:' + drawerWidth + ';';
      },

      _computeMainStyle: function(narrow, rightDrawer, drawerWidth) {
        var style = '';

        style += 'left:' + ((narrow || rightDrawer) ? '0' : drawerWidth) + ';';

        if (rightDrawer) {
          style += 'right:' + (narrow ? '' : drawerWidth) + ';';
        }

        return style;
      },

      _computeMediaQuery: function(forceNarrow, responsiveWidth) {
        return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
      },

      _computeSwipeOverlayHidden: function(narrow, disableEdgeSwipe) {
        return !narrow || disableEdgeSwipe;
      },

      _onTrack: function(event) {
        if (sharedPanel && this !== sharedPanel) {
          return;
        }
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd(event);
            break;
        }

      },

      _responsiveChange: function(narrow) {
        this._setNarrow(narrow);

        if (this.narrow) {
          this.selected = this.defaultSelected;
        }

        this.setScrollDirection(this._swipeAllowed() ? 'y' : 'all');
        this.fire('paper-responsive-change', {narrow: this.narrow});
      },

      _onQueryMatchesChanged: function(event) {
        this._responsiveChange(event.detail.value);
      },

      _forceNarrowChanged: function() {
        // set the narrow mode only if we reached the `responsiveWidth`
        this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
      },

      _swipeAllowed: function() {
        return this.narrow && !this.disableSwipe;
      },

      _isMainSelected: function() {
        return this.selected === 'main';
      },

      _startEdgePeek: function() {
        this.width = this.$.drawer.offsetWidth;
        this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ?
            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
        this._setPeeking(true);
      },

      _stopEdgePeek: function() {
        if (this.peeking) {
          this._setPeeking(false);
          this._moveDrawer(null);
        }
      },

      _downHandler: function(event) {
        if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(event) && !sharedPanel) {
          this._startEdgePeek();
          // cancel selection
          event.preventDefault();
          // grab this panel
          sharedPanel = this;
        }
      },

      _upHandler: function() {
        this._stopEdgePeek();
        // release the panel
        sharedPanel = null;
      },

      _onTap: function(event) {
        var targetElement = Polymer.dom(event).localTarget;
        var isTargetToggleElement = targetElement &&
          this.drawerToggleAttribute &&
          targetElement.hasAttribute(this.drawerToggleAttribute);

        if (isTargetToggleElement) {
          this.togglePanel();
        }
      },

      _isEdgeTouch: function(event) {
        var x = event.detail.x;

        return !this.disableEdgeSwipe && this._swipeAllowed() &&
          (this.rightDrawer ?
            x >= this.offsetWidth - this.edgeSwipeSensitivity :
            x <= this.edgeSwipeSensitivity);
      },

      _trackStart: function(event) {
        if (this._swipeAllowed()) {
          sharedPanel = this;
          this._setDragging(true);

          if (this._isMainSelected()) {
            this._setDragging(this.peeking || this._isEdgeTouch(event));
          }

          if (this.dragging) {
            this.width = this.$.drawer.offsetWidth;
            this.transition = false;
          }
        }
      },

      _translateXForDeltaX: function(deltaX) {
        var isMain = this._isMainSelected();

        if (this.rightDrawer) {
          return Math.max(0, isMain ? this.width + deltaX : deltaX);
        } else {
          return Math.min(0, isMain ? deltaX - this.width : deltaX);
        }
      },

      _trackX: function(event) {
        if (this.dragging) {
          var dx = event.detail.dx;

          if (this.peeking) {
            if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
              // Ignore trackx until we move past the edge peek.
              return;
            }
            this._setPeeking(false);
          }

          this._moveDrawer(this._translateXForDeltaX(dx));
        }
      },

      _trackEnd: function(event) {
        if (this.dragging) {
          var xDirection = event.detail.dx > 0;

          this._setDragging(false);
          this.transition = true;
          sharedPanel = null;
          this._moveDrawer(null);

          if (this.rightDrawer) {
            this[xDirection ? 'closeDrawer' : 'openDrawer']();
          } else {
            this[xDirection ? 'openDrawer' : 'closeDrawer']();
          }
        }
      },

      _transformForTranslateX: function(translateX) {
        if (translateX === null) {
          return '';
        }

        return this.hasWillChange ? 'translateX(' + translateX + 'px)' :
            'translate3d(' + translateX + 'px, 0, 0)';
      },

      _moveDrawer: function(translateX) {
        this.transform(this._transformForTranslateX(translateX), this.$.drawer);
      }

    });

  }());

</script>
<dom-module id="paper-header-panel" assetpath="../bower_components/paper-header-panel/">

  <style>
    :host {
      @apply(--layout);
      @apply(--layout-vertical);

      display: block;
      position: relative;
      height: 100%;

      /* Create a stack context, we will need it for the shadow*/
      z-index: 0;
    }

    :root {
      /**
       * Default paper header panel shadow
       */
      --paper-header-panel-shadow: {
        height: 6px;
        bottom: -6px;
        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
      };
    }

    #mainContainer {
      @apply(--layout-flex);

      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      flex-basis: 0.0001px;
    }

    /*
     * mode: scroll
     */
    :host([mode=scroll]) #mainContainer {
      @apply(--paper-header-panel-scroll-container);
      overflow: visible;
    }

    :host([mode=scroll]) {
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }

    /*
     * mode: cover
     */
    :host([mode=cover]) #mainContainer {
      @apply(--paper-header-panel-cover-container);
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    /*
     * mode: standard
     */
    :host([mode=standard]) #mainContainer {
      @apply(--paper-header-panel-standard-container);
    }

    /*
     * mode: waterfall
     */
    :host([mode=waterfall]) #mainContainer {
      @apply(--paper-header-panel-waterfall-container);
    }

    /*
     * mode: waterfall-tall
     */
    :host([mode=waterfall-tall]) #mainContainer {
      @apply(--paper-header-panel-waterfall-tall-container);
    }

    :host ::content paper-toolbar,
    :host ::content .paper-header {
      position: relative;
      overflow: visible !important;
    }

    :host ::content paper-toolbar:after,
    :host ::content .paper-header:after {
      @apply(--paper-header-panel-shadow);

      -webkit-transition: opacity 0.5s, -webkit-transform 0.5s;
      transition: opacity 0.5s, transform 0.5s;

      opacity: 0;
      content: "";

      width: 100%;
      position: absolute;
      left: 0px;
      right: 0px;
      z-index: 1;

      -webkit-transform: scale3d(1, 0, 1);
      -webkit-transform-origin: 0% 0%;

      transform: scale3d(1, 0, 1);
      transform-origin: 0% 0%;
    }

    :host ::content paper-toolbar.has-shadow:after,
    :host ::content .paper-header.has-shadow:after {
      opacity: 1;
      -webkit-transform: scale3d(1, 1, 1);
      transform: scale3d(1, 1, 1);
    }
  </style>

  <template>
    <content id="headerContent" select="paper-toolbar, .paper-header"></content>
    <div id="mainContainer" class$="[[_computeMainContainerClass(mode)]]">
      <content id="mainContent" select="*"></content>
    </div>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    var SHADOW_WHEN_SCROLLING = 1;
    var SHADOW_ALWAYS = 2;


    var MODE_CONFIGS = {

      outerScroll: {
        scroll: true
      },

      shadowMode: {
        standard: SHADOW_ALWAYS,
        waterfall: SHADOW_WHEN_SCROLLING,
        'waterfall-tall': SHADOW_WHEN_SCROLLING
      },

      tallMode: {
        'waterfall-tall': true
      }
    };

    Polymer({

      is: 'paper-header-panel',

      /**
       * Fired when the content has been scrolled.  `event.detail.target` returns
       * the scrollable element which you can use to access scroll info such as
       * `scrollTop`.
       *
       *     <paper-header-panel on-content-scroll="{{scrollHandler}}">
       *       ...
       *     </paper-header-panel>
       *
       *
       *     scrollHandler: function(event) {
       *       var scroller = event.detail.target;
       *       console.log(scroller.scrollTop);
       *     }
       *
       * @event content-scroll
       */

      properties: {

        /**
         * Controls header and scrolling behavior. Options are
         * `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
         * `cover`. Default is `standard`.
         *
         * `standard`: The header is a step above the panel. The header will consume the
         * panel at the point of entry, preventing it from passing through to the
         * opposite side.
         *
         * `seamed`: The header is presented as seamed with the panel.
         *
         * `waterfall`: Similar to standard mode, but header is initially presented as
         * seamed with panel, but then separates to form the step.
         *
         * `waterfall-tall`: The header is initially taller (`tall` class is added to
         * the header).  As the user scrolls, the header separates (forming an edge)
         * while condensing (`tall` class is removed from the header).
         *
         * `scroll`: The header keeps its seam with the panel, and is pushed off screen.
         *
         * `cover`: The panel covers the whole `paper-header-panel` including the
         * header. This allows user to style the panel in such a way that the panel is
         * partially covering the header.
         *
         *     <paper-header-panel mode="cover">
         *       <paper-toolbar class="tall">
         *         <core-icon-button icon="menu"></core-icon-button>
         *       </paper-toolbar>
         *       <div class="content"></div>
         *     </paper-header-panel>
         */
        mode: {
          type: String,
          value: 'standard',
          observer: '_modeChanged',
          reflectToAttribute: true
        },

        /**
         * If true, the drop-shadow is always shown no matter what mode is set to.
         */
        shadow: {
          type: Boolean,
          value: false
        },

        /**
         * The class used in waterfall-tall mode.  Change this if the header
         * accepts a different class for toggling height, e.g. "medium-tall"
         */
        tallClass: {
          type: String,
          value: 'tall'
        },

        /**
         * If true, the scroller is at the top
         */
        atTop: {
          type: Boolean,
          value: true,
          readOnly: true
        }
      },

      observers: [
        '_computeDropShadowHidden(atTop, mode, shadow)'
      ],

      ready: function() {
        this.scrollHandler = this._scroll.bind(this);
        this._addListener();

        // Run `scroll` logic once to initialze class names, etc.
        this._keepScrollingState();
      },

      detached: function() {
        this._removeListener();
      },

      /**
       * Returns the header element
       *
       * @property header
       * @type Object
       */
      get header() {
        return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
      },

      /**
       * Returns the scrollable element.
       *
       * @property scroller
       * @type Object
       */
      get scroller() {
        return this._getScrollerForMode(this.mode);
      },

      /**
       * Returns true if the scroller has a visible shadow.
       *
       * @property visibleShadow
       * @type Boolean
       */
      get visibleShadow() {
        return this.header.classList.contains('has-shadow');
      },

      _computeDropShadowHidden: function(atTop, mode, shadow) {

        var shadowMode = MODE_CONFIGS.shadowMode[mode];

        if (this.shadow) {
          this.toggleClass('has-shadow', true, this.header);

        } else if (shadowMode === SHADOW_ALWAYS) {
          this.toggleClass('has-shadow', true, this.header);

        } else if (shadowMode === SHADOW_WHEN_SCROLLING && !atTop) {
          this.toggleClass('has-shadow', true, this.header);

        } else {
          this.toggleClass('has-shadow', false, this.header);

        }
      },

      _computeMainContainerClass: function(mode) {
        // TODO:  It will be useful to have a utility for classes
        // e.g. Polymer.Utils.classes({ foo: true });

        var classes = {};

        classes['flex'] = mode !== 'cover';

        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },

      _addListener: function() {
        this.scroller.addEventListener('scroll', this.scrollHandler, false);
      },

      _removeListener: function() {
        this.scroller.removeEventListener('scroll', this.scrollHandler);
      },

      _modeChanged: function(newMode, oldMode) {
        var configs = MODE_CONFIGS;
        var header = this.header;
        var animateDuration = 200;

        if (header) {
          // in tallMode it may add tallClass to the header; so do the cleanup
          // when mode is changed from tallMode to not tallMode
          if (configs.tallMode[oldMode] && !configs.tallMode[newMode]) {
            header.classList.remove(this.tallClass);
            this.async(function() {
              header.classList.remove('animate');
            }, animateDuration);
          } else {
            header.classList.toggle('animate', configs.tallMode[newMode]);
          }
        }
        this._keepScrollingState();
      },

      _keepScrollingState: function () {
        var main = this.scroller;
        var header = this.header;

        this._setAtTop(main.scrollTop === 0);

        if (header && MODE_CONFIGS.tallMode[this.mode]) {
          this.toggleClass(this.tallClass, this.atTop ||
              header.classList.contains(this.tallClass) &&
              main.scrollHeight < this.offsetHeight, header);
        }
      },

      _scroll: function(e) {
        this._keepScrollingState();
        this.fire('content-scroll', {target: this.scroller}, {bubbles: false});
      },

      _getScrollerForMode: function(mode) {
        return MODE_CONFIGS.outerScroll[mode] ?
            this : this.$.mainContainer;
      }

    });

  })();

</script>
<dom-module id="paper-ripple" assetpath="../bower_components/paper-ripple/">

  

  <style>
    :host {
      display: block;
      position: absolute;
      border-radius: inherit;
      overflow: hidden;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    :host([animating]) {
      /* This resolves a rendering issue in Chrome (as of 40) where the
         ripple is not properly clipped by its parent (which may have
         rounded corners). See: http://jsbin.com/temexa/4

         Note: We only apply this style conditionally. Otherwise, the browser
         will create a new compositing layer for every ripple element on the
         page, and that would be bad. */
      -webkit-transform: translate(0, 0);
      transform: translate3d(0, 0, 0);
    }

    :host([noink]) {
      pointer-events: none;
    }

    #background,
    #waves,
    .wave-container,
    .wave {
      pointer-events: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #background,
    .wave {
      opacity: 0;
    }

    #waves,
    .wave {
      overflow: hidden;
    }

    .wave-container,
    .wave {
      border-radius: 50%;
    }

    :host(.circle) #background,
    :host(.circle) #waves {
      border-radius: 50%;
    }

    :host(.circle) .wave-container {
      overflow: hidden;
    }

  </style>
  <template>
    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      cssColorWithAlpha: function(cssColor, alpha) {
        var parts = cssColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

        if (typeof alpha == 'undefined') {
          alpha = 1;
        }

        if (!parts) {
          return 'rgba(255, 255, 255, ' + alpha + ')';
        }

        return 'rgba(' + parts[1] + ', ' + parts[2] + ', ' + parts[3] + ', ' + alpha + ')';
      },

      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: (function() {
        if (window.performance && window.performance.now) {
          return window.performance.now.bind(window.performance);
        }

        return Date.now;
      })()
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      /** @param {Event=} event */
      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        var ownerRoot = Polymer.dom(this).getOwnerRoot();
        var target;

        if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
          target = ownerRoot.host;
        } else {
          target = this.parentNode;
        }

        return target;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        this.listen(this.target, 'up', 'upAction');
        this.listen(this.target, 'down', 'downAction');

        if (!this.target.hasAttribute('noink')) {
          this.keyEventTarget = this.target;
        }
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      /** @param {Event=} event */
      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this.animate();
        }
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      animate: function() {
        var index;
        var ripple;

        this._animating = true;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.downAction();
        this.async(this.upAction, 1);
      },

      _onSpaceKeydown: function() {
        this.downAction();
      },

      _onSpaceKeyup: function() {
        this.upAction();
      },

      _holdDownChanged: function(holdDown) {
        if (holdDown) {
          this.downAction();
        } else {
          this.upAction();
        }
      }
    });
  })();
</script>
<dom-module id="paper-icon-button" assetpath="../bower_components/paper-icon-button/">
  <style>

    :host {
      display: inline-block;
      position: relative;
      padding: 8px;
      outline: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      cursor: pointer;
      z-index: 0;

      @apply(--paper-icon-button);
    }

    :host #ink {
      color: var(--paper-icon-button-ink-color, --primary-text-color);
      opacity: 0.6;
    }

    :host([disabled]) {
      color: var(--paper-icon-button-disabled-text, --disabled-text-color);
      pointer-events: none;
      cursor: auto;
      @apply(--paper-icon-button-disabled);
    }
  </style>
  <template>
    <paper-ripple id="ink" class="circle" center=""></paper-ripple>
    <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-icon-button',

    hostAttributes: {
      role: 'button',
      tabindex: '0'
    },

    behaviors: [
      Polymer.PaperInkyFocusBehavior
    ],

    properties: {
      /**
       * The URL of an image for the icon. If the src property is specified,
       * the icon property should not be.
       */
      src: {
        type: String
      },

      /**
       * Specifies the icon name or index in the set of icons available in
       * the icon's icon set. If the icon property is specified,
       * the src property should not be.
       */
      icon: {
        type: String
      },

      /**
       * Specifies the alternate text for the button, for accessibility.
       */
      alt: {
        type: String,
        observer: "_altChanged"
      }
    },

    _altChanged: function(newValue, oldValue) {
      var label = this.getAttribute('aria-label');

      // Don't stomp over a user-set aria-label.
      if (!label || oldValue == label) {
        this.setAttribute('aria-label', newValue);
      }
    }
  });
</script>
<dom-module id="paper-item" assetpath="../bower_components/paper-item/">

  <style>
/*
    @license
    Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: block;
  min-height: var(--paper-item-min-height, 48px);
  padding: 0px 16px;
}

:host > ::content > *:not(:first-child):not(:last-child) {
  margin-right: 16px;
}

</style>

  <style>

    :host {
      @apply(--layout-horizontal);
      @apply(--layout-center);
      @apply(--paper-font-subhead);

      @apply(--paper-item);
    }

  </style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-item',

    hostAttributes: {
      role: 'listitem'
    }

  });

})();

</script>
<dom-module id="paper-material" assetpath="../bower_components/paper-material/">
  <style>
    :host {
      display: block;
      position: relative;
      @apply(--shadow-transition);
    }

    :host([elevation="1"]) {
      @apply(--shadow-elevation-2dp);
    }

    :host([elevation="2"]) {
      @apply(--shadow-elevation-4dp);
    }

    :host([elevation="3"]) {
      @apply(--shadow-elevation-6dp);
    }

    :host([elevation="4"]) {
      @apply(--shadow-elevation-8dp);
    }

    :host([elevation="5"]) {
      @apply(--shadow-elevation-16dp);
    }
  </style>
  <template>
    <content></content>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-material',

    properties: {

      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        value: 1
      },

      /**
       * Set this to true to animate the shadow when setting a new
       * `elevation` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    }
  });
</script>
<dom-module id="paper-menu" assetpath="../bower_components/paper-menu/">

  <style>

    :host {
      display: block;
      padding: 8px 0;

      background: var(--paper-menu-background-color, --primary-background-color);
      color: var(--paper-menu-color, --primary-text-color);

      @apply(--paper-menu);
    }

    /* need a wrapper element to make this higher specificity than the :host rule in paper-item */
    .content > ::content > .iron-selected {
      font-weight: bold;

      @apply(--paper-menu-selected-item);
    }

    .content > ::content > [disabled] {
      color: var(--paper-menu-disabled-color, --disabled-text-color);
    }

    .content > ::content > *:focus {
      position: relative;
      outline: 0;

      @apply(--paper-menu-focused-item);
    }

    .content > ::content > *:focus:after {
      @apply(--layout-fit);
      background: currentColor;
      /* FIXME move to paper-styles for next widget */
      opacity: 0.12;
      content: '';

      @apply(--paper-menu-focused-item-after);
    }

    .content > ::content > *[colored]:focus:after {
      opacity: 0.26;
    }

  </style>

  <template>

    <div class="content">
      <content></content>
    </div>

  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-menu',

    behaviors: [
      Polymer.IronMenuBehavior
    ]

  });

})();

</script>
<dom-module id="iron-a11y-announcer" assetpath="../bower_components/iron-a11y-announcer/">
  <style>
    :host {
      display: inline-block;
      position: fixed;
      clip: rect(0px,0px,0px,0px);
    }
  </style>

  <template>
    <span aria-live$="[[mode]]">[[_text]]</span>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>
<dom-module id="paper-toast" assetpath="../bower_components/paper-toast/">
  <style>
    :host {
      display: inline-block;
      position: fixed;

      background: #323232;
      color: #f1f1f1;
      min-height: 48px;
      min-width: 288px;
      padding: 16px 24px 12px;
      box-sizing: border-box;
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      border-radius: 2px;
      bottom: 12px;
      left: 12px;
      font-size: 14px;
      cursor: default;

      -webkit-transition: visibility 0.3s, -webkit-transform 0.3s;
      transition: visibility 0.3s, transform 0.3s;

      -webkit-transform: translateY(100px);
      transform: translateY(100px);

      visibility: hidden;
    }

    :host(.capsule) {
      border-radius: 24px;
    }

    :host(.fit-bottom) {
      bottom: 0;
      left: 0;
      width: 100%;
      min-width: 0;
      border-radius: 0;
    }

    :host(.paper-toast-open){
      visibility: visible;

      -webkit-transform: translateY(0px);
      transform: translateY(0px);
    }
  </style>
  <template>
    <span id="label">{{text}}</span>
    <content></content>
  </template>
</dom-module>
<script>
(function() {

  var PaperToast = Polymer({
    is: 'paper-toast',

    properties: {
      /**
       * The duration in milliseconds to show the toast.
       */
      duration: {
        type: Number,
        value: 3000
      },

      /**
       * The text to display in the toast.
       */
      text: {
        type: String,
        value: ""
      },

      /**
       * True if the toast is currently visible.
       */
      visible: {
        type: Boolean,
        readOnly: true,
        value: false,
        observer: '_visibleChanged'
      }
    },

    created: function() {
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    ready: function() {
      this.async(function() {
        this.hide();
      });
    },

    /**
     * Show the toast.
     * @method show
     */
    show: function() {
      if (PaperToast.currentToast) {
        PaperToast.currentToast.hide();
      }
      PaperToast.currentToast = this;
      this.removeAttribute('aria-hidden');
      this._setVisible(true);
      this.fire('iron-announce', {
        text: this.text
      });
      this.debounce('hide', this.hide, this.duration);
    },

    /**
     * Hide the toast
     */
    hide: function() {
      this.setAttribute('aria-hidden', 'true');
      this._setVisible(false);
    },

    /**
     * Toggle the opened state of the toast.
     * @method toggle
     */
    toggle: function() {
      if (!this.visible) {
        this.show();
      } else {
        this.hide();
      }
    },

    _visibleChanged: function(visible) {
      this.toggleClass('paper-toast-open', visible);
    }
  });

  PaperToast.currentToast = null;

})();
</script>
<dom-module id="paper-toolbar" assetpath="../bower_components/paper-toolbar/">

  <style>
    :host {
      /* technical */
      display: block;
      position: relative;
      box-sizing: border-box;
      -moz-box-sizing: border-box;

      /* size */
      height: 64px;

      background: var(--paper-toolbar-background, --default-primary-color);
      color: var(--paper-toolbar-color, --text-primary-color);

      @apply(--paper-toolbar);
    }

    :host(.animate) {
      /* transition */
      transition: height 0.18s ease-in;
    }

    :host(.medium-tall) {
      height: 128px;
    }

    :host(.tall) {
      height: 192px;
    }

    .toolbar-tools {
      position: relative;
      height: 64px;
      padding: 0 16px;
      pointer-events: none;
    }

    /*
     * TODO: Where should media query breakpoints live so they can be shared between elements?
     */

    @media (max-width: 639px) {
      :host {
        height: 56px;
      }

      :host(.medium-tall) {
        height: 112px;
      }

      :host(.tall) {
        height: 168px;
      }

      .toolbar-tools {
        height: 56px;
      }
    }

    #topBar {
      position: relative;
    }

    /* middle bar */
    #middleBar {
      position: absolute;
      top: 0;
      right: 0;
      left: 0;
    }

    :host(.tall) #middleBar,
    :host(.medium-tall) #middleBar {
      -webkit-transform: translateY(100%);
      transform: translateY(100%);
    }

    /* bottom bar */
    #bottomBar {
      position: absolute;
      right: 0;
      bottom: 0;
      left: 0;
    }

    /*
     * make elements (e.g. buttons) respond to mouse/touch events
     *
     * `.toolbar-tools` disables touch events so multiple toolbars can stack and not
     * absorb events. All children must have pointer events re-enabled to work as
     * expected.
     */
    .toolbar-tools > ::content > *:not([disabled]) {
      pointer-events: auto;
    }

    .toolbar-tools > ::content .title {
      @apply(--paper-font-title);
      @apply(--layout-flex);

      pointer-events: none;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;

      /*
       * Polymer/polymer/issues/1525
       * --paper-font-title defines a `font-weight`
       * let's override its value, but we need `important!`
       * because all mixins are resolved in rule's selector that has higher precedence
       * than the current selector.
       */
      font-weight: 400 !important;
    }

    /**
     * TODO: Refactor these selectors
     * Work in progress.
     */
    .toolbar-tools > ::content paper-icon-button[icon=menu] {
      margin-right: 24px;
    }

    .toolbar-tools > ::content > .title,
    .toolbar-tools > ::content[select=".middle"] > .title,
    .toolbar-tools > ::content[select=".bottom"] > .title {
      margin-left: 56px;
    }

    .toolbar-tools > ::content > paper-icon-button + .title,
    .toolbar-tools > ::content[select=".middle"] paper-icon-button + .title,
    .toolbar-tools > ::content[select=".bottom"] paper-icon-button + .title {
      margin-left: 0;
    }

    .toolbar-tools > ::content > .fit {
      position: absolute;
      top: auto;
      right: 0;
      bottom: 0;
      left: 0;
      width: auto;
      margin: 0;
    }

  </style>

  <template>

    <div id="topBar" class$="[[_computeBarClassName(justify)]]">
      <content select=":not(.middle):not(.bottom)"></content>
    </div>

    <div id="middleBar" class$="[[_computeBarClassName(middleJustify)]]">
      <content select=".middle"></content>
    </div>

    <div id="bottomBar" class$="[[_computeBarClassName(bottomJustify)]]">
      <content select=".bottom"></content>
    </div>

  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    function classNames(obj) {
      var classNames = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classNames.push(key);
        }
      }

      return classNames.join(' ');
    }

    Polymer({

      is: 'paper-toolbar',

      hostAttributes: {
        'role': 'toolbar'
      },

      properties: {

        /**
         * Controls how the items are aligned horizontally when they are placed
         * at the bottom.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute bottomJustify
         * @type string
         * @default ''
         */
        bottomJustify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute justify
         * @type string
         * @default ''
         */
        justify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally when they are placed
         * in the middle.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute middleJustify
         * @type string
         * @default ''
         */
        middleJustify: {
          type: String,
          value: ''
        }

      },

      attached: function() {
        this._observer = this._observe(this);
        this._updateAriaLabelledBy();
      },

      detached: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },

      _observe: function(node) {
        var observer = new MutationObserver(function() {
          this._updateAriaLabelledBy();
        }.bind(this));
        observer.observe(node, {
          childList: true,
          subtree: true
        });
        return observer;
      },

      _updateAriaLabelledBy: function() {
        var labelledBy = [];
        var contents = Polymer.dom(this.root).querySelectorAll('content');
        for (var content, index = 0; content = contents[index]; index++) {
          var nodes = Polymer.dom(content).getDistributedNodes();
          for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
            if (node.classList && node.classList.contains('title')) {
              if (node.id) {
                labelledBy.push(node.id);
              } else {
                var id = 'paper-toolbar-label-' + Math.floor(Math.random() * 10000);
                node.id = id;
                labelledBy.push(id);
              }
            }
          }
        }
        if (labelledBy.length > 0) {
          this.setAttribute('aria-labelledby', labelledBy.join(' '));
        }
      },

      _computeBarClassName: function(barJustify) {
        var classObj = {
          'center': true,
          'horizontal': true,
          'layout': true,
          'toolbar-tools': true
        };

        // If a blank string or any falsy value is given, no other class name is
        // added.
        if (barJustify) {
          var justifyClassName = (barJustify === 'justified') ?
              barJustify :
              barJustify + '-justified';

          classObj[justifyClassName] = true;
        }

        return classNames(classObj);
      }

    });

  }());

</script>
<dom-module id="paper-progress" assetpath="../bower_components/paper-progress/">
  <style>
    :host {
      display: inline-block;
      width: 200px;
      height: 4px;
    }

    :host(.transiting) #activeProgress,
    :host(.transiting) #secondaryProgress {
      -webkit-transition-property: -webkit-transform;
      transition-property: transform;

      /* Duration */
      -webkit-transition-duration: var(--paper-progress-transition-duration, 0.08s);
      transition-duration: var(--paper-progress-transition-duration, 0.08s);

      /* Timing function */
      -webkit-transition-timing-function: var(--paper-progress-transition-timing-function, ease);
      transition-timing-function: var(--paper-progress-transition-timing-function, ease);

      /* Delay */
      -webkit-transition-delay: var(--paper-progress-transition-delay, 0s);
      transition-delay: var(--paper-progress-transition-delay, 0s);
    }

    #progressContainer {
      position: relative;
      height: 100%;
      background-color: var(--paper-progress-container-color, --google-grey-300);
      overflow: hidden;
    }

    #activeProgress,
    #secondaryProgress {
      -webkit-transform-origin: left center;
      transform-origin: left center;
      -webkit-transform: scaleX(0);
      transform: scaleX(0);
    }

    #activeProgress {
      background-color: var(--paper-progress-active-color, --google-green-500);
    }

    #secondaryProgress {
      background-color: var(--paper-progress-secondary-color, --google-green-100);
    }

    #activeProgress.indeterminate {
      -webkit-transform-origin: center center;
      transform-origin: center center;
      -webkit-animation: indeterminate-bar 1s linear infinite;
      animation: indeterminate-bar 1s linear infinite;
    }

    @-webkit-keyframes indeterminate-bar {
      0% {
        -webkit-transform: translate(-50%) scaleX(0);
      }
      50% {
        -webkit-transform: translate(0%) scaleX(0.3);
      }
      100% {
        -webkit-transform: translate(50%) scaleX(0);
      }
    }

    @keyframes indeterminate-bar {
      0% {
        transform: translate(-50%) scaleX(0);
      }
      50% {
        transform: translate(0%) scaleX(0.3);
      }
      100% {
        transform: translate(50%) scaleX(0);
      }
    }
  </style>
  <template>
    <div id="progressContainer" role="progressbar" aria-valuenow$="{{value}}" aria-valuemin$="{{min}}" aria-valuemax$="{{max}}">
      <div id="secondaryProgress" class="fit"></div>
      <div id="activeProgress" class="fit"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'paper-progress',

    behaviors: [
      Polymer.IronRangeBehavior
    ],

    properties: {

      /**
       * The number that represents the current secondary progress.
       */
      secondaryProgress: {
        type: Number,
        value: 0,
        notify: true
      },

      /**
       * The secondary ratio
       */
      secondaryRatio: {
        type: Number,
        value: 0,
        readOnly: true,
        observer: '_secondaryRatioChanged'
      },

      /**
       * Use an indeterminate progress indicator.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_toggleIndeterminate'
      }
    },

    observers: [
      '_ratioChanged(ratio)',
      '_secondaryProgressChanged(secondaryProgress, min, max)'
    ],

    _toggleIndeterminate: function() {
      // If we use attribute/class binding, the animation sometimes doesn't translate properly
      // on Safari 7.1. So instead, we toggle the class here in the update method.
      this.toggleClass('indeterminate', this.indeterminate, this.$.activeProgress);
    },

    _transformProgress: function(progress, ratio) {
      var transform = 'scaleX(' + (ratio / 100) + ')';
      progress.style.transform = progress.style.webkitTransform = transform;
    },

    _ratioChanged: function(ratio) {
      this._transformProgress(this.$.activeProgress, ratio);
    },

    _secondaryRatioChanged: function(secondaryRatio) {
      this._transformProgress(this.$.secondaryProgress, secondaryRatio);
    },

    _secondaryProgressChanged: function() {
      this.secondaryProgress = this._clampValue(this.secondaryProgress);
      this._setSecondaryRatio(this._calcRatio(this.secondaryProgress) * 100);
    }

  });

</script>
<dom-module id="mat-ink" assetpath="../bower_components/mat-ink/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }

        /* FOREGROUND */

        :host([foreground="dark"]) { color: hsla(0, 0%, 0%, 0.87); }
        :host([foreground="light"]) { color: hsla(0, 0%, 100%, 1); }

        /* OPACITY */

        :host([opacity="divider"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.12); }
        :host([opacity="divider"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.12); }
        :host([opacity="hint"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.26); }
        :host([opacity="hint"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.30); }
        :host([opacity="icon"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.54); }
        :host([opacity="icon"][foreground="light"]) { color: hsla(0, 0%, 100%, 1); }
        :host([opacity="secondary"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.54); }
        :host([opacity="secondary"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.70); }

        /* DISABLED */
        :host([disabled]) {
            filter: gray;
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
            pointer-events: none !important;
            text-shadow: none !important;
        }

        :host([disabled][foreground="dark"]) {
            color: hsla(0, 0%, 0%, 0.26) !important;
        }

        :host([disabled][foreground="light"]) {
            color: hsla(0, 0%, 100%, 0.30) !important;
        }
    </style>

    <template>
        <template is="xp-slave-state" master="{{layer}}" master-tag="mat-paper"></template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-ink',

            // BEHAVIORS
            behaviors: [
                Polymer.MatPalette,
                Polymer.XPSharedBehavior
            ],

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {
                var self = this;
                XP.setStyle(self, 'color', !self.disabled && self._getColor(self.color));
                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(color, disabled)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's foreground color.
                 *
                 * @attribute foreground
                 * @type "dark" | "light"
                 * @notifies
                 * @readonly
                 */
                foreground: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: String
                },

                /**
                 * The paper layer where ink is placed.
                 *
                 * @attribute layer
                 * @type Element
                 * @notifies
                 */
                layer: {
                    notify: true,
                    observer: '_layerChanged',
                    value: null
                },

                /**
                 * The ink's opacity level.
                 *
                 * @attribute opacity
                 * @type string
                 */
                opacity: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The opacity list.
             *
             * @property opacityList
             * @type Array
             * @default ["divider", "hint", "icon", "secondary"]
             * @readonly
             */
            opacityList: ['divider', 'hint', 'icon', 'secondary'],

            /*********************************************************************/

            // OBSERVER
            _layerChanged: function () {
                if (this.layer) { this._setForeground(this.layer.foreground); }
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setForeground(this._getForeground(this.shared && this.shared.theme));
            }
        });
    </script>

</dom-module><dom-module id="xp-iconset" assetpath="../bower_components/xp-iconset/">

    <style>
        :host {
            display: none !important;
        }
    </style>

    <template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-iconset',

            // BEHAVIORS
            behaviors: [
                Polymer.XPArrayBehavior
            ],

            /*********************************************************************/

            /**
             * Returns a copy of an iconset's icon.
             *
             * @method findIcon
             * @param {string} [name = ""]
             * @returns {Node}
             */
            findIcon: function (name) {

                // Asserting
                XP.assertArgument(XP.isVoid(name) || XP.isString(name), 1, 'string');

                // Vars
                var self    = this,
                    wrapper = name ? XP.getDistributedElement(Polymer.dom((self.instance || self).$.content), 'svg') : null,
                    icon    = wrapper ? XP.getElement(Polymer.dom(wrapper), 'g[id="' + name + '"]') : null,
                    clone   = icon ? icon.cloneNode(true) : null;

                // Cleaning
                if (clone) { clone.removeAttribute('id'); }

                return clone;
            },

            /**
             * Returns an iconset instance.
             *
             * @method findInstance
             * @param {string} [name = ""]
             * @returns {Element}
             */
            findInstance: function (name) {
                XP.assertArgument(XP.isVoid(name) || XP.isString(name), 1, 'string');
                return (name && XP.find(this.instances, function (instance) { return name === instance.name; })) || null;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The iconset's instance.
                 *
                 * @attribute instance
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                instance: {
                    computed: '_computeInstance(name, refers)',
                    notify: true
                },

                /**
                 * The instance's name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    observer: '_nameChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The referred instance's name.
                 *
                 * @attribute refers
                 * @type string
                 */
                refers: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The list of instances.
             *
             * @property instances
             * @type Array
             * @default []
             * @readonly
             */
            instances: [],

            /*********************************************************************/

            // COMPUTER
            _computeInstance: function (name, refers) {
                return (!name && this.findInstance(refers)) || null;
            },

            /*********************************************************************/

            // OBSERVER
            _nameChanged: function (post) {
                this[post ? 'append' : 'pull']('instances', this);
            }
        });
    </script>

</dom-module><dom-module id="xp-icon" assetpath="../bower_components/xp-icon/">

    <style>
        :host {
            display: inline-block;
            height: 24px;
            overflow: visible;
            width: 24px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #xpIconWrapper,
        :host #xpIconWrapper * {
            border-radius: inherit;
            height: 100%;
            width: 100%;
        }

        :host svg {
            display: block;
            fill: currentcolor;
        }
    </style>

    <template>
        <div id="xpIconWrapper"></div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-icon',

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {

                // Vars
                var self        = this,
                    icon        = self.iconSet && self.iconName ? self.iconSet.findIcon(self.iconName) : null,
                    iconElement = icon ? XP.createElementNS('http://www.w3.org/2000/svg', 'svg', {children: [icon]}) : (self.src ? XP.createElement('div') : null),
                    iconTag     = iconElement ? XP.getTag(XP.addAttribute(iconElement, 'icon')) : null;

                // Setting
                self._setIconElement(iconElement);
                self._setEmpty(!iconElement);
                self._setRaster(iconTag !== 'svg');

                // Stylizing
                if (iconTag === 'div') { XP.setStyles(iconElement, {background: 'url(' + self.src + ') 100% no-repeat', 'background-size': '100% 100%'}); }
                if (iconTag === 'svg') { XP.setAttributes(iconElement, {xmlns: "http://www.w3.org/2000/svg", height: 24, width: 24, viewBox: '0 0 ' + 24 + ' ' + 24}); }

                // Replacing
                XP.setChildren(Polymer.dom(self.$.xpIconWrapper), [iconElement]);

                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(iconName, iconSet, src)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The iconset used to find others.
                 *
                 * @attribute finder
                 * @type Element
                 * @readonly
                 */
                finder: {
                    readOnly: true,
                    value: function () { return XP.createElement('xp-iconset'); }
                },

                /**
                 * The icon's rendered element.
                 *
                 * @attribute icon-element
                 * @type Element
                 * @readonly
                 */
                iconElement: {
                    readOnly: true,
                    value: null
                },

                /**
                 * The icon's name.
                 *
                 * @attribute icon-name
                 * @type string
                 * @notifies
                 * @readonly
                 */
                iconName: {
                    notify: true,
                    readOnly: true,
                    type: String,
                    value: null
                },

                /**
                 * The icon's iconset.
                 *
                 * @attribute icon-set
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                iconSet: {
                    notify: true,
                    readOnly: true,
                    value: null
                },

                /**
                 * The icon's iconset:name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    observer: '_nameChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is rendered as `div` background instead of `svg`.
                 *
                 * @attribute raster
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    readOnly: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The icon's src.
                 *
                 * @attribute src
                 * @type string
                 */
                src: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The list iconsets.
             *
             * @property iconSets
             * @type Object
             * @readonly
             */
            iconSets: {},

            /*********************************************************************/

            // OBSERVER
            _nameChanged: function (post) {

                // Vars
                var self  = this,
                    parts = XP.split(post, ':');

                // Finding
                if (parts[0]) { self.iconSets[parts[0]] = self.iconSets[parts[0]] || self.finder.findInstance(parts[0]); }

                // Setting
                self._setIconName(parts[1] || '');
                self._setIconSet(parts[0] ? self.iconSets[parts[0]] : null);
            }
        });
    </script>

</dom-module>
<dom-module id="mat-icon" assetpath="../bower_components/mat-icon/">

    <style>
        :host {
            display: inline-block;
            height: 24px;
            overflow: visible;
            width: 24px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matIconWrapper,
        :host #matIconAdaptee {
            border-radius: inherit;
            display: block;
            height: 100%;
            width: 100%;
        }
    </style>

    <template>
        <mat-ink id="matIconWrapper" color="[[color]]" disabled="[[disabled]]" opacity="[[_computeOpacity(opacity, raster)]]">
            <xp-icon id="matIconAdaptee" empty="{{empty}}" name="[[name]]" raster="{{raster}}" src="[[src]]"></xp-icon>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-icon',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAdapterBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The icon's iconset:name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The ink's opacity level.
                 *
                 * @attribute opacity
                 * @type string
                 */
                opacity: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is rendered as `div` background instead of `svg`.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * The icon's src.
                 *
                 * @attribute src
                 * @type string
                 */
                src: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeOpacity: function (opacity, raster) {
                return opacity || (raster ? '' : 'icon');
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._adapt(this.$.matIconAdaptee);
            }
        });
    </script>

</dom-module>
<xp-iconset name="navigation">
    <svg>
        <defs>
            <g id="apps"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
            <g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
            <g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
            <g id="arrow-drop-down-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path></g>
            <g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
            <g id="arrow-forward"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></g>
            <g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
            <g id="check"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
            <g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
            <g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
            <g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
            <g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
            <g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
            <g id="fullscreen"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></g>
            <g id="fullscreen-exit"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></g>
            <g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
            <g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            <g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            <g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
            <g id="unfold-less"><path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path></g>
            <g id="unfold-more"><path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path></g>
        </defs>
    </svg>
</xp-iconset><dom-module id="mat-ripple" assetpath="../bower_components/mat-ripple/">

    <style>
        :host {
            @apply(--layout-fit);
            border-radius: inherit;
            display: block;
            overflow: hidden;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :host([animated]) {
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }

        :host #matRippleWrapper {
            @apply(--layout-fit);
            border-radius: inherit;
            color: inherit;
            pointer-events: none !important;
        }

        :host #matRippleBackground {
            @apply(--layout-fit);
            background: currentColor;
            border-radius: inherit;
            opacity: 0;
            transition: opacity 0.8s;
            will-change: opacity;
        }

        :host(:not([auto-center])) #matRippleBackground[rippling] {
            opacity: 0.10;
        }

        :host #matRippleWaves {
            @apply(--layout-fit);
            border-radius: 50%;
        }

        :host #matRippleWaves * {
            background: currentColor;
            border-radius: inherit;
            opacity: 0.10;
            position: absolute;
            -webkit-transform: translate(0, 0) scale(0);
            transform: translate(0, 0) scale(0);
            -webkit-transition: opacity 0.54s, -webkit-transform 0.54s;
            transition: opacity 0.54s, transform 0.54s;
            will-change: opacity, transform;
        }

        :host([auto-center]) #matRippleWaves * {
            opacity: 0.20;
        }

        :host #matRippleWaves *[smoothing] {
            opacity: 0;
            -webkit-transform: scale(1);
            transform: scale(1);
            -webkit-transition: opacity 0.54s, -webkit-transform 0.54s;
            transition: opacity 0.54s, transform 0.54s;
        }
    </style>

    <template>
        <mat-ink id="matRippleWrapper" color="[[color]]">
            <div id="matRippleBackground"></div>
            <div id="matRippleWaves"></div>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-ripple',

            /*********************************************************************/

            /**
             * Ripples a wave.
             *
             * @method ripple
             * @param {number} [startX]
             * @param {number} [startY]
             * @returns {Element}
             */
            ripple: function (startX, startY) {

                // Asserting
                XP.assertArgument(XP.isVoid(startX) || XP.isNumber(startX), 1, 'number');
                XP.assertArgument(XP.isVoid(startY) || XP.isNumber(startY), 2, 'number');

                // Vars
                var self       = this,
                    background = self.$.matRippleBackground,
                    waves      = self.$.matRippleWaves,
                    wave       = Polymer.dom(waves).appendChild(XP.createElement('div')),
                    data       = self._waveData(wave, startX, startY);

                // Setting
                self.timeLast = Date.now();

                // Animation
                XP.delay(function () {

                    // Styling
                    XP.setStyle(wave, 'height', data.radius + 'px');
                    XP.setStyle(wave, 'left', data.left + 'px');
                    XP.setStyle(wave, 'top', data.top + 'px');
                    XP.setStyle(wave, 'width', data.radius + 'px');
                    XP.setStyle(wave, '-webkit-transform', 'translate(' + data.dx + 'px, ' + data.dy + 'px) scale(1)');
                    XP.setStyle(wave, 'transform', 'translate(' + data.dx + 'px, ' + data.dy + 'px) scale(1)');

                    // Setting
                    XP.addAttribute(self, 'animated');
                    XP.addAttribute(background, 'rippling');
                    XP.addAttribute(wave, 'rippling');

                    // Smoothing
                    if (!self.pressed) { self.smooth(); }
                });

                return self;
            },

            /**
             * Smooths a wave.
             *
             * @method smooth
             * @param {boolean} [force = false]
             * @returns {Element}
             */
            smooth: function (force) {

                // Vars
                var self = this;

                // Animation
                XP.delay(function () {

                    // Vars
                    var elapsed    = Date.now() - self.timeLast,
                        background = self.$.matRippleBackground,
                        waves      = self.$.matRippleWaves,
                        wave       = XP.getElement(Polymer.dom(waves), '[rippling]');

                    // Checking
                    if (!wave) { return; }

                    // Delaying
                    if (!force && elapsed < 240) { XP.delay(function () { self.smooth(true); }, 240 - elapsed); return; }

                    // Wave
                    XP.removeAttribute(wave, 'rippling');
                    XP.removeAttribute(!XP.getElement(Polymer.dom(waves), '[rippling]') ? background : null, 'rippling');
                    XP.addAttribute(wave, 'smoothing');

                    // Delaying
                    XP.delay(function() {

                        // Removing
                        XP.removeChild(Polymer.dom(waves), wave);
                        XP.removeAttribute(!Polymer.dom(waves).children.length ? self : null, 'animated');

                    }, 600);
                });

                return self;
            },

            /*********************************************************************/

            /**
             * Creates the data to position the wave.
             *
             * @method _waveData
             * @param {Element} wave
             * @param {number} [startX]
             * @param {number} [startY]
             * @returns {Object}
             * @private
             */
            _waveData: function (wave, startX, startY) {

                // Asserting
                XP.assertArgument(XP.isElement(wave), 1, 'Element');
                XP.assertArgument(XP.isVoid(startX) || XP.isNumber(startX), 2, 'number');
                XP.assertArgument(XP.isVoid(startY) || XP.isNumber(startY), 3, 'number');

                // Vars
                var self      = this,
                    boundings = XP.getBoundings(self),
                    centerX   = XP.isVoid(startX) || self.autoCenter,
                    centerY   = XP.isVoid(startY) || self.autoCenter,
                    data      = {};

                // Setting
                data.radius = Math.floor(Math.max(boundings.width, boundings.height)) * 1.5;
                data.left   = (centerX ? (boundings.width / 2) : Math.max(startX, boundings.left) - Math.min(startX, boundings.left)) - (data.radius / 2);
                data.top    = (centerY ? (boundings.height / 2) : Math.max(startY, boundings.top) - Math.min(startY, boundings.top)) - (data.radius / 2);
                data.dx     = (boundings.width / 2) - data.left - (data.radius / 2);
                data.dy     = (boundings.height / 2) - data.top - (data.radius / 2);

                return data;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                down: '_handleTouch',
                up: '_handleTouch'
            },

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the waves will propagate from the center instead of the touch point.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The context element.
                 *
                 * @attribute context
                 * @type Element
                 */
                context: {
                    observer: '_contextChanged',
                    value: null
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /**
             * The timestamp of the last wave.
             *
             * @property timeLast
             * @type number
             * @default 0
             * @readonly
             */
            timeLast: 0,

            /*********************************************************************/

            // OBSERVER
            _contextChanged: function (post, pre) {

                // Vars
                var self = this;

                // Checking
                if (arguments.length < 2) { return; }

                // Listening
                if (pre) { self.unlisten(pre, 'down', '_handleTouch'); self.unlisten(pre, 'up', '_handleTouch'); }
                if (post) { self.listen(post, 'down', '_handleTouch'); self.listen(post, 'up', '_handleTouch'); }

                // Styling
                XP.setStyle(self, 'pointer-events', post ? 'none' : null);
            },

            /*********************************************************************/

            // HANDLER
            _handleTouch: function (event) {

                // Vars
                var self = this;

                // Setting
                self._setPressed(event.type === 'down');

                // Animating
                if (event.type === 'down') { self.ripple(event.detail.x, event.detail.y); } else { self.smooth(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-option" assetpath="../bower_components/mat-option/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: not-allowed !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            @apply(--mat-font-subhead);
            display: block;
            height: 48px;
            text-align: left;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host #matOptionWrapper,
        :host #matOptionMain {
            height: 100%;
        }

        :host #matOptionMain {
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }

        :host #matOptionAnchor {
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host #matOptionAnchor[href]:hover {
            text-decoration: underline;
        }

        :host #matOptionMain {
            padding: 0 16px;
        }

        :host #matOptionIcon {
            margin-right: 24px;
        }

        :host #matOptionIcon[empty] {
            display: block !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }

        :host #matOptionLabel {
            overflow: hidden;
        }

        :host #matOptionSpacer {
            @apply(--layout-flex);
        }
    </style>

    <template>
        <mat-ink id="matOptionWrapper" disabled="[[disabled]]">
            <a id="matOptionAnchor">
                <div id="matOptionMain">
                    <template is="dom-if" if="[[_hasIcon(toggleable, icon, iconSrc)]]" restamp=""><mat-icon id="matOptionIcon" disabled="[[disabled]]" name="[[_computeIcon(toggleable, icon, active)]]" src="[[_computeIconSrc(toggleable, iconSrc)]]"></mat-icon></template>
                    <div id="matOptionLabel">{{_computeLabel(label, value)}}</div>
                    <div id="matOptionSpacer"></div>
                    <template is="dom-if" if="[[_hasSecondaryText(secondaryText, secondaryIcon, secondaryIconSrc)]]" restamp=""><div id="matOptionSecondaryText">{{secondaryText}}</div></template>
                    <template is="dom-if" if="[[_hasSecondaryIcon(secondaryIcon, secondaryIconSrc)]]" restamp=""><mat-icon id="matOptionSecondaryIcon" disabled="[[disabled]]" name="[[secondaryIcon]]" opacity="hint" src="[[secondaryIconSrc]]"></mat-icon></template>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matOptionRipple"></mat-ripple>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-option',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    computed: '_computeEmpty(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The option's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                inset: {
                    computed: '_computeInset(toggleable, icon, iconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The option's label.
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary icon.
                 *
                 * @attribute secondary-icon
                 * @type string
                 */
                secondaryIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary icon's src.
                 *
                 * @attribute secondary-icon-src
                 * @type string
                 */
                secondaryIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary text.
                 *
                 * @attribute secondary-text
                 * @type string
                 */
                secondaryText: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's value.
                 *
                 * @attribute value
                 * @type string
                 * @default ""
                 */
                value: {
                    reflectToAttribute: true,
                    type: String,
                    value: ''
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeEmpty: function (label) {
                return !label;
            },

            // COMPUTER
            _computeIcon: function (toggleable, icon, active) {
                return !toggleable ? icon : (active ? 'navigation:check' : '');
            },

            // COMPUTER
            _computeIconSrc: function (toggleable, iconSrc) {
                return !toggleable ? iconSrc : '';
            },

            // COMPUTER
            _computeInset: function (toggleable, icon, iconSrc) {
                return toggleable || !!icon || !!iconSrc;
            },

            // COMPUTER
            _computeLabel: function (label, value) {
                return label || value;
            },

            // COMPUTER
            _hasIcon: function (toggleable, icon, iconSrc) {
                return toggleable || !!icon || !!iconSrc;
            },

            // COMPUTER
            _hasSecondaryIcon: function (secondaryIcon, secondaryIconSrc) {
                return !!secondaryIcon || !!secondaryIconSrc;
            },

            // COMPUTER
            _hasSecondaryText: function (secondaryText, secondaryIcon, secondaryIconSrc) {
                return !!secondaryText && !secondaryIcon && !secondaryIconSrc;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matOptionAnchor);
            }
        });
    </script>

</dom-module><dom-module id="mat-paper" assetpath="../bower_components/mat-paper/">

    <style>
        :host {
            border: 0 solid transparent;
            display: block;
            overflow: hidden;
            position: relative;
            -webkit-transition: border 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                box-shadow 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                border-radius 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                height 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                -webkit-transform 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                width 0.8s cubic-bezier(0.55, 0, 0.01, 1);
            transition: border 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        box-shadow 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        border-radius 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        height 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        transform 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        width 0.8s cubic-bezier(0.55, 0, 0.01, 1);
        }

        /* FOREGROUND */

        :host([foreground="dark"]) {
            background: hsla(0, 0%, 98%, 1);
            border-color: hsla(0, 0%, 0%, 0.12);
            color: hsla(0, 0%, 0%, 0.87);
        }

        :host([foreground="light"]) {
            background: hsla(0, 0%, 26%, 1);
            border-color: hsla(0, 0%, 100%, 0.12);
            color: hsla(0, 0%, 100%, 1);
        }

        /* BRIGHTNESS */

        :host([brightness="header"][foreground="dark"]) { background: hsla(0, 0%, 88%, 1); }
        :host([brightness="header"][foreground="light"]) { background: hsla(0, 0%, 13%, 1); }
        :host([brightness="placeholder"][foreground="dark"]) { background: hsla(0, 0%, 88%, 1); }
        :host([brightness="placeholder"][foreground="light"]) { background: hsla(0, 0%, 46%, 1); }
        :host([brightness="shell"][foreground="dark"]) { background: hsla(0, 0%, 93%, 1); }
        :host([brightness="shell"][foreground="light"]) { background: hsla(0, 0%, 19%, 1); }
        :host([brightness="toolbar"][foreground="dark"]) { background: hsla(0, 0%, 96%, 1); }
        :host([brightness="toolbar"][foreground="light"]) { background: hsla(0, 0%, 38%, 1); }

        /* SHADOW */

        :host([z="1"]) { @apply(--mat-shadow-z1); }
        :host([z="2"]) { @apply(--mat-shadow-z2); }
        :host([z="3"]) { @apply(--mat-shadow-z3); }
        :host([z="4"]) { @apply(--mat-shadow-z4); }
        :host([z="5"]) { @apply(--mat-shadow-z5); }
        :host([z="6"]) { @apply(--mat-shadow-z6); }
        :host([z="7"]) { @apply(--mat-shadow-z7); }
        :host([z="8"]) { @apply(--mat-shadow-z8); }
        :host([z="9"]) { @apply(--mat-shadow-z9); }
        :host([z="10"]) { @apply(--mat-shadow-z10); }
        :host([z="11"]) { @apply(--mat-shadow-z11); }
        :host([z="12"]) { @apply(--mat-shadow-z12); }
        :host([z="13"]) { @apply(--mat-shadow-z13); }
        :host([z="14"]) { @apply(--mat-shadow-z14); }
        :host([z="15"]) { @apply(--mat-shadow-z15); }
        :host([z="16"]) { @apply(--mat-shadow-z16); }
        :host([z="17"]) { @apply(--mat-shadow-z17); }
        :host([z="18"]) { @apply(--mat-shadow-z18); }
        :host([z="19"]) { @apply(--mat-shadow-z19); }
        :host([z="20"]) { @apply(--mat-shadow-z20); }
        :host([z="21"]) { @apply(--mat-shadow-z21); }
        :host([z="22"]) { @apply(--mat-shadow-z22); }
        :host([z="23"]) { @apply(--mat-shadow-z23); }
        :host([z="24"]) { @apply(--mat-shadow-z24); }

        /* DISABLED */
        :host([disabled]) {
            box-shadow: none !important;
            filter: gray;
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
            pointer-events: none !important;
        }

        :host([disabled][foreground="dark"]) {
            background: hsla(0, 0%, 0%, 0.12) !important;
            color: hsla(0, 0%, 0%, 0.26);
        }

        :host([disabled][foreground="light"]) {
            background: hsla(0, 0%, 100%, 0.12) !important;
            color: hsla(0, 0%, 100%, 0.30);
        }
    </style>

    <template>
        <template is="xp-master-state" slaves="{{inks}}" slave-tag="mat-ink"></template>
        <template is="xp-master-state" slaves="{{papers}}" slave-tag="mat-paper"></template>
        <template is="xp-slave-state" master="{{layer}}" master-tag="mat-paper"></template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-paper',

            // BEHAVIORS
            behaviors: [
                Polymer.MatPalette,
                Polymer.XPSharedBehavior
            ],

            /*********************************************************************/

            /**
             * Falls the paper.
             *
             * @method fall
             * @returns {Element}
             */
            fall: function () {

                // Vars
                var self = this;

                // Checking
                if (self.raising || !self.z) { return self; }

                // Setting
                self._setRaising(false);
                self.z         = self.pressed ? self.z : self.zPrevious;
                self.zPrevious = self.pressed ? self.zPrevious : 0;

                return self;
            },

            /**
             * Raises the paper.
             *
             * @method raise
             * @returns {Element}
             */
            raise: function () {

                // Vars
                var self = this;

                // Checking
                if (self.raising || !self.z) { return self; }

                // Setting
                self._setRaising(true);
                self.zPrevious = self.z;
                self.z         = Math.min(self.z + self.zElevation, self.zMax);

                // Delaying
                XP.delay(function () { self._setRaising(false); self.fall(); }, 300);

                return self;
            },

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {
                var self = this;
                XP.setStyle(self, 'background', !self.disabled && self._getColor(self.background));
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'down': '_handleTouch',
                'up': '_handleTouch'
            },

            // OBSERVERS
            observers: [
                '_refresh(background, disabled)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The paper's brightness.
                 *
                 * @attribute brightness
                 * @type string
                 */
                brightness: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's foreground color.
                 *
                 * @attribute foreground
                 * @type "dark" | "light"
                 * @notifies
                 * @readonly
                 */
                foreground: {
                    computed: '_computeForeground(background, brightness, theme, disabled)',
                    notify: true,
                    observer: '_foregroundChanged',
                    reflectToAttribute: true,
                    type: String
                },

                /**
                 * The slave inks.
                 *
                 * @attribute inks
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                inks: {
                    notify: true,
                    type: Array
                },

                /**
                 * The master paper.
                 *
                 * @attribute layer
                 * @type Element
                 * @notifies
                 */
                layer: {
                    notify: true,
                    observer: '_layerChanged',
                    value: null
                },

                /**
                 * The slave papers.
                 *
                 * @attribute papers
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                papers: {
                    notify: true,
                    type: Array
                },

                /**
                 * If set to true, the element is pressable.
                 *
                 * @attribute pressable
                 * @type boolean
                 * @default false
                 */
                pressable: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the paper is raising from the rest position.
                 *
                 * @attribute raising
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                raising: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's theme, used to apply the default foreground color.
                 *
                 * @attribute theme
                 * @type "dark" | "light"
                 * @notifies
                 */
                theme: {
                    notify: true,
                    observer: '_themeChanged',
                    type: String
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 0
                 * @notifies
                 */
                z: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Number,
                    value: 0
                }
            },

            /**
             * The brightness list.
             *
             * @property brightnessList
             * @type Array
             * @default ["header", "overlay", "placeholder", "shell", "toolbar"]
             * @readonly
             */
            brightnessList: ['header', 'overlay', 'placeholder', 'shell', 'toolbar'],

            /**
             * The list of instances.
             *
             * @property instances
             * @type Array
             * @default []
             * @readonly
             */
            instances: [],

            /**
             * The elevation value of z.
             *
             * @property zElevation
             * @type number
             * @default 6
             * @readonly
             */
            zElevation: 6,

            /**
             * The maximum value of z.
             *
             * @property zMax
             * @type number
             * @default 24
             * @readonly
             */
            zMax: 24,

            /**
             * The previous value of z.
             *
             * @property zPrevious
             * @type number
             * @default 0
             * @readonly
             */
            zPrevious: 0,

            /*********************************************************************/

            // COMPUTER
            _computeForeground: function (background, brightness, theme, disabled) {
                var palette = (!disabled && background) || (brightness !== "overlay" && theme) || "light";
                return this._getForeground(palette, brightness === "placeholder" && !background && !disabled);
            },

            /*********************************************************************/

            // OBSERVER
            _foregroundChanged: function (post) {
                if (this.inks) { this.inks.forEach(function (ink) { ink._setForeground(post); }); }
            },

            // OBSERVER
            _layerChanged: function () {
                if (this.layer) { this.theme = this.layer.theme; }
            },

            // OBSERVER
            _themeChanged: function (post) {
                if (this.papers) { this.papers.forEach(function (paper) { paper.theme = post; }); }
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {

                // Vars
                var self = this;

                // Pushing
                self.push('instances', self);

                // Setting
                self.theme = self.theme || self.shared.theme || 'light';
            },

            /*********************************************************************/

            // HANDLER
            _handleTouch: function (event) {

                // Vars
                var self = this;

                // Checking
                if (!self.pressable) { return; }

                // Setting
                self._setPressed(event.type === 'down');

                // Animating
                self[event.type === 'down' ? 'raise' : 'fall']();
            }
        });
    </script>

</dom-module><dom-module id="xp-overlay" assetpath="../bower_components/xp-overlay/">

    <style>
:host {
    display: block;
    opacity: 0;
    overflow: visible;
    position: fixed;
    text-align: left;
    transition: opacity 0.2s, visibility 0.2s;
    visibility: hidden;
    z-index: 9999;
}

:host([showed]) {
    opacity: 1;
    visibility: visible;
}

:host(:not([showed])) {
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            margin: 16px;
        }

        :host #xpOverlayWrapper {
            background: inherit;
            height: 100%;
            overflow: auto;
        }
    </style>

    <template>
        <div id="xpOverlayWrapper">
            <content id="content"></content>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-overlay',

            // BEHAVIORS
            behaviors: [
                Polymer.XPOverlayBehavior
            ],

            /*********************************************************************/

            /**
             * Aligns the overlay.
             *
             * @method _align
             * @returns {Element}
             * @private
             */
            _align: function () {
                var self = this, target = self.showed && self.findTarget();
                if (target) { XP.alignElement(self, target, self.position, self.autoCenter); } else { self.hide(); }
                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_align(autoCenter, position, showed, target)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the overlay is center aligned.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The overlay position relative to the target.
                 *
                 * 'over' is over the target.
                 *
                 * 'aside' is to the side of the target.
                 *
                 * 'baseline' is underneath the target.
                 *
                 * @attribute position
                 * @type "aside" | "baseline" | "over"
                 * @default "over"
                 */
                position: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'over'
                }
            },

            /**
             * The list of positions.
             *
             * @property positions
             * @type Array
             * @default ["aside", "baseline", "over"]
             * @readonly
             */
            positions: ['aside', 'baseline', 'over'],

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this.listen(window, 'resize', '_handleResize');
            },

            /*********************************************************************/

            // HANDLER
            _handleResize: function () {
                this._align();
            }
        });
    </script>

</dom-module><dom-module id="mat-overlay" assetpath="../bower_components/mat-overlay/">

    <style>
        :host {
            display: block;
            overflow: visible;
            position: absolute;
        }

        :host #matOverlayAdaptee {
            margin: 16px;
        }

        :host #matOverlayAdaptee::shadow > #xpOverlayWrapper {
            overflow: visible;
        }

        :host #matOverlayWrapper {
            border-radius: inherit;
            height: 100%;
            overflow: auto;
            padding: 8px 0;
        }
    </style>

    <template>
        <xp-overlay id="matOverlayAdaptee" auto-center="[[autoCenter]]" auto-hide-disabled="[[autoHideDisabled]]" context="[[_computeContext(context)]]" data="{{data}}" position="[[position]]" showed="{{showed}}" target="{{target}}">
            <mat-paper id="matOverlayWrapper" background="[[background]]" brightness="overlay" z="[[z]]">
                <content id="content"></content>
            </mat-paper>
        </xp-overlay>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-overlay',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAdapterBehavior,
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the overlay.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this;
                self.$.matOverlayAdaptee.hide();
                return self;
            },

            /**
             * Shows the overlay.
             *
             * @method show
             * @param {Element | string} [target]
             * @param {*} [data]
             * @returns {Element}
             */
            show: function (target, data) {
                var self = this;
                self.$.matOverlayAdaptee.show(target, data);
                return self;
            },

            /**
             * Toggles the overlay.
             *
             * @method toggle
             * @param {Element | string} [target]
             * @param {*} [data]
             * @returns {Element}
             */
            toggle: function (target, data) {
                var self = this;
                self.$.matOverlayAdaptee.toggle(target, data);
                return self;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the overlay is center aligned.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the overlay will not close by clicking outside.
                 *
                 * @attribute auto-hide-disabled
                 * @type boolean
                 * @default false
                 */
                autoHideDisabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The context element.
                 *
                 * @attribute context
                 * @type Element
                 */
                context: {
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * The overlay position relative to the target.
                 *
                 * 'over' is over the target.
                 *
                 * 'aside' is to the side of the target.
                 *
                 * 'baseline' is underneath the target.
                 *
                 * @attribute position
                 * @type "aside" | "baseline" | "over"
                 * @default "over"
                 */
                position: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'over'
                },

                /**
                 * If set to true, the overlay is showed.
                 *
                 * @attribute showed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                showed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 8
                 */
                z: {
                    reflectToAttribute: true,
                    type: Number,
                    value: 8
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeContext: function (context) {
                return context || this;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._adapt(this.$.matOverlayAdaptee);
            }
        });
    </script>

</dom-module><dom-module id="mat-menu" assetpath="../bower_components/mat-menu/">

    <style>
        :host {
            display: block;
            overflow: visible;
            position: absolute;
        }

        :host([cascade]) #matMenuAdaptee::shadow #matOverlayBody {
            padding: 16px 0;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{submenus}}" slave-tag="mat-submenu" on-slaves-changed="_handleSlaves"></template>
        <mat-overlay id="matMenuAdaptee" background="[[background]]" context="[[self]]" data="{{data}}" position="[[_computePosition(cascade)]]" showed="{{showed}}" target="{{target}}" z="[[z]]">
            <content id="content"></content>
        </mat-overlay>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-menu',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAdapterBehavior,
                Polymer.XPReferralBehavior,
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the menu.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this;
                if (self.adaptee) { self.adaptee.hide(); }
                return self;
            },

            /**
             * Shows the menu.
             *
             * @method show
             * @param {Element | string} [target]
             * @param {*} [data]
             * @returns {Element}
             */
            show: function (target, data) {
                var self = this;
                if (self.adaptee) { self.adaptee.show(target, data); }
                return self;
            },

            /**
             * Toggles the menu.
             *
             * @method toggle
             * @param {Element | string} [target]
             * @param {*} [data]
             * @returns {Element}
             */
            toggle: function (target, data) {
                var self = this;
                if (self.adaptee) { self.adaptee.toggle(target, data); }
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'xp-activate': '_handleActivate'
            },

            // PROPERTIES
            properties: {

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    observer: '_backgroundChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the menu is a cascade one.
                 *
                 * @attribute cascade
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                cascade: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the overlay is showed.
                 *
                 * @attribute showed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                showed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The slave submenus.
                 *
                 * @attribute submenus
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                submenus: {
                    notify: true,
                    type: Array
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 8
                 * @readonly
                 */
                z: {
                    readOnly: true,
                    type: Number,
                    value: 8
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computePosition: function (cascade) {
                return cascade ? 'baseline' : 'over';
            },

            /*********************************************************************/

            // OBSERVER
            _backgroundChanged: function (post) {
                XP.forEach(this.submenus || [], function (submenu) { submenu.background = post; });
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._adapt(this.$.matMenuAdaptee);
            },

            /*********************************************************************/

            // HANDLER
            _handleActivate: function (event) {
                var self = this;
                if (!XP.matches(event.detail.firer, 'mat-option') || event.detail.firer.toggleable) { return; }
                XP.delay(function () { if (!event.defaultPrevented) { self.hide(); } });
            },

            // HANDLE
            _handleSlaves: function () {
                var self = this;
                XP.delay(function () { self.cascade = self.cascade || self.submenus.length > 0; });
            }
        });
    </script>

</dom-module><dom-module id="mat-divider" assetpath="../bower_components/mat-divider/">

    <style>
        :host {
            display: block;
            margin: 7px 0 8px 0;
            overflow: hidden;
            transition: margin 0.33s cubic-bezier(0.55, 0, 0.01, 1);
            will-change: margin;
        }

        :host([baseline]),
        :host([cap]) {
            left: 0;
            margin: 0;
            position: absolute;
            right: 0;
        }

        :host([baseline]) {
            bottom: 0;
        }

        :host([cap]) {
            top: 0;
        }

        :host #matDividerWrapper {
            border-top: 1px solid currentColor;
        }

        :host([inset]) #matDividerWrapper {
            margin-left: 72px;
        }
    </style>

    <template>
        <mat-ink id="matDividerWrapper" opacity="divider"></mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-divider',

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the divider is aligned baseline.
                 *
                 * @attribute baseline
                 * @type boolean
                 * @default false
                 */
                baseline: {
                    observer: '_baselineChanged',
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the divider is aligned cap.
                 *
                 * @attribute cap
                 * @type boolean
                 * @default false
                 */
                cap: {
                    observer: '_capChanged',
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @default false
                 */
                inset: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /*********************************************************************/

            // OBSERVER
            _baselineChanged: function (post) {
                this.cap = this.cap && !post;
            },

            // OBSERVER
            _capChanged: function (post) {
                this.baseline = this.baseline && !post;
            }
        });
    </script>

</dom-module><dom-module id="mat-input-decorator" assetpath="../bower_components/mat-input-decorator/">

    <style>
        :host {
            cursor: default;
            display: block;
            overflow: hidden;
            position: relative;
            text-align: left;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :host([disabled]) {
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        :host,
        :host ::content input,
        :host ::content textarea {
            @apply(--mat-font-subhead);
        }

        :host ::content input,
        :host ::content textarea {
            background: transparent;
            border: none;
            box-shadow: none;
            color: inherit;
            font-family: inherit;
            height: 100%;
            margin: 0;
            outline: 0;
            padding: 0;
            resize: none;
            width: 100%;
        }

        :host ::content input,
        :host #matInputPrefix,
        :host #matInputSuffix,
        :host #matInputPlaceholder {
            overflow: hidden;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host ::content input:not([type="search"])::-ms-clear {
            display: none !important;
        }

        :host #matInputWrapper {
            display: block;
            padding: 8px 0 4px 0;
        }

        :host([full-width]) #matInputWrapper {
            padding: 16px 0;
        }

        :host([full-width]:not([mirrored])) #matInputWrapper {
            @apply(--layout-horizontal);
        }

        :host #matInputDivider {
            display: none;
        }

        :host #matInputLabel {
            height: 16px;
        }

        :host([empty-label]) #matInputLabel,
        :host([full-width]) #matInputLabel,
        :host(:not([floating-label])) #matInputLabel {
            display: none !important;
        }

        :host #matInputMain {
            margin: 6px 0;
            position: relative;
        }

        :host(:not([disabled])) #matInputMain {
            cursor: text;
        }

        :host([full-width]) #matInputMain {
            @apply(--layout-flex);
            margin: 0;
        }

        :host #matInputPlaceholder {
            @apply(--layout-fit);
            pointer-events: none !important;
            -webkit-transition: font-size 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                font-weight 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                letter-spacing 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                line-height 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                -webkit-transform 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            transition: font-size 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        font-weight 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        letter-spacing 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        line-height 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        transform 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            will-change: font-size, font-weight, letter-spacing, line-height, opacity, transform;
        }

        :host([floated]) #matInputPlaceholder {
            @apply(--mat-font-caption);
            -webkit-transform: translate3d(0, -22px, 0);
            transform: translate3d(0, -22px, 0);
            -webkit-transform-origin: 0 0 0;
            transform-origin: 0 0 0;
        }

        :host([empty-label]) #matInputPlaceholder,
        :host(:not([empty]):not([floating-label])) #matInputPlaceholder {
            display: none !important;
        }

        :host #matInputPrefix {
            float: left;
        }

        :host #matInputSuffix {
            float: right;
        }

        :host #matInputMirror {
            min-height: 20px;
            opacity: 0 !important;
            visibility: hidden !important;
            word-wrap: break-word !important;
        }

        :host(:not([mirrored])) #matInputMirror {
            display: none !important;
        }

        :host #matInputHolder {
            overflow: hidden;
        }

        :host([mirrored]) #matInputHolder {
            @apply(--layout-fit);
        }

        :host #matInputUnderline {
            margin: -2px 0 4px 0;
        }

        :host([full-width]) #matInputUnderline {
            display: none !important;
        }

        :host #matInputUnderlineDefault {
            border-top: 1px solid currentColor;
            transition: border 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            will-change: border;
        }

        :host([disabled]) #matInputUnderlineDefault {
            border-top-style: dashed;
        }

        :host #matInputUnderlineFocused {
            border-top: 2px solid currentColor;
            margin-top: -1px;
            -webkit-transform: scale(0, 1);
            transform: scale(0, 1);
            -webkit-transition: -webkit-transform 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            transition: transform 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            will-change: transform;
        }

        :host([focused]) #matInputUnderlineFocused,
        :host([invalid]) #matInputUnderlineFocused {
            -webkit-transform: scale(1, 1);
            transform: scale(1, 1);
        }

        :host #matInputHelper {
            @apply(--mat-font-caption);
            min-height: 16px;
            white-space: normal !important; /* override */
        }

        :host([full-width]) #matInputHelper {
            line-height: 24px !important; /* override */
        }

        :host([full-width][mirrored]) #matInputHelper {
            margin-bottom: -4px;
        }

        :host #matInputCounter {
            float: right;
            margin-left: 16px;
        }
    </style>

    <template>
        <div id="matInputWrapper">
            <mat-divider id="matInputDivider" cap=""></mat-divider>
            <div id="matInputLabel"></div>
            <mat-ink id="matInputMain" disabled="[[disabled]]">
                <mat-ink id="matInputPlaceholder" color="[[_computePlaceholderColor(floated, focused)]]" disabled="[[disabled]]" opacity="[[_computePlaceholderOpacity(floated)]]">{{_computePlaceholder(floated, inputPrefix, label)}}</mat-ink>
                <template is="dom-if" if="[[inputPrefix]]"><div id="matInputPrefix">{{inputPrefix}}</div></template>
                <template is="dom-if" if="[[inputSuffix]]"><mat-ink id="matInputSuffix" disabled="[[disabled]]" opacity="secondary">{{inputSuffix}}</mat-ink></template>
                <div id="matInputMirror"></div>
                <div id="matInputHolder"><content id="input"></content></div>
            </mat-ink>
            <div id="matInputUnderline">
                <mat-ink id="matInputUnderlineDefault" opacity="divider"></mat-ink>
                <mat-ink id="matInputUnderlineFocused" color="[[_computeUnderlineColor(invalid)]]" opacity="divider"></mat-ink>
            </div>
            <mat-ink id="matInputHelper" color="[[_computeHelperColor(invalid)]]" disabled="[[disabled]]" opacity="hint">
                <template is="dom-if" if="[[maxLength]]"><div id="matInputCounter">{{_computeCounter(maxLength, chars)}}</div></template>
                <template is="dom-if" if="[[!fullWidth]]"><div id="matInputDescription">{{_computeDescription(invalid, error, invalidMessage, description)}}</div></template>
                <div style="clear: both"></div>
            </mat-ink>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-input-decorator',

            /*********************************************************************/

            /**
             * Updates the mirror's content. Useful for auto growing inputs, like `textarea`.
             *
             * @method _mirror
             * @param {string} value
             * @returns {Element}
             * @private
             */
            _mirror: function (value) {
                var self = this;
                if (self.mirrored) { self.$.matInputMirror.innerHTML = XP.escape(value).replace(/\n/g, '<br/>') + '&nbsp;'; }
                return self;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The input's character counter.
                 *
                 * @attribute chars
                 * @type number
                 * @default 0
                 */
                chars: {
                    type: Number,
                    value: 0
                },

                /**
                 * The input's description.
                 *
                 * @attribute description
                 * @type string
                 */
                description: {
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the input is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the input is empty.
                 *
                 * @attribute empty
                 * @type boolean
                 * @default false
                 */
                empty: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the label is hidden.
                 *
                 * @attribute empty-label
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptyLabel: {
                    computed: '_computeEmptyLabel(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The input's custom error message, used instead of `invalidMessage`.
                 *
                 * @attribute error
                 * @type string
                 */
                error: {
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the input's label is floated.
                 *
                 * @attribute floated
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                floated: {
                    computed: '_computeFloated(label, floatingLabel, fullWidth, focused, empty)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the input's label will float above the input.
                 *
                 * @attribute floating-label
                 * @type boolean
                 * @default false
                 */
                floatingLabel: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the input is focused.
                 *
                 * @attribute focused
                 * @type boolean
                 * @default false
                 */
                focused: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the input is full width.
                 *
                 * @attribute full-width
                 * @type boolean
                 * @default false
                 */
                fullWidth: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The appended input's element.
                 *
                 * @attribute input
                 * @type Element
                 */
                input: {
                    observer: '_inputChanged',
                    value: null
                },

                /**
                 * The input's prefix.
                 *
                 * @attribute input-prefix
                 * @type string
                 */
                inputPrefix: {
                    type: String,
                    value: null
                },

                /**
                 * The input's suffix.
                 *
                 * @attribute input-suffix
                 * @type string
                 */
                inputSuffix: {
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the input's value is not valid.
                 *
                 * @attribute invalid
                 * @type boolean
                 * @default false
                 */
                invalid: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The input's system error message.
                 *
                 * @attribute invalid-message
                 * @type string
                 */
                invalidMessage: {
                    type: String,
                    value: null
                },

                /**
                 * The input's label.
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    type: String,
                    value: null
                },

                /**
                 * The input's max characters number.
                 *
                 * @attribute max-length
                 * @type number
                 */
                maxLength: {
                    reflectToAttribute: true,
                    type: Number,
                    value: null
                },

                /**
                 * The input's max rows number.
                 *
                 * @attribute max-rows
                 * @type number
                 */
                maxRows: {
                    observer: '_maxRowsChanged',
                    reflectToAttribute: true,
                    type: Number,
                    value: null
                },

                /**
                 * The input's min rows number.
                 *
                 * @attribute min-rows
                 * @type number
                 */
                minRows: {
                    observer: '_minRowsChanged',
                    reflectToAttribute: true,
                    type: Number,
                    value: null
                },

                /**
                 * If set to true, the input is mirrored.
                 *
                 * @attribute mirrored
                 * @type boolean
                 * @default false
                 */
                mirrored: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The input's plain value.
                 *
                 * @attribute value
                 * @type string
                 */
                value: {
                    observer: '_valueChanged',
                    type: String
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeCounter: function (maxLength, chars) {
                return maxLength ? (chars || 0) + ' / ' + maxLength : '';
            },

            // COMPUTER
            _computeDescription: function (invalid, error, invalidMessage, description) {
                return (invalid && (error || invalidMessage)) || description || '';
            },

            // COMPUTER
            _computeEmptyLabel: function (label) {
                return !label;
            },

            // COMPTUER
            _computeFloated: function (label, floatingLabel, fullWidth, focused, empty) {
                return !!label && floatingLabel && !fullWidth && (focused || !empty);
            },

            // COMPUTER
            _computeHelperColor: function (invalid) {
                return invalid ? 'red-400' : null;
            },

            // COMPUTER
            _computePlaceholder: function (floated, inputPrefix, label) {
                return ((!floated && inputPrefix) || '') + (label || '');
            },

            // COMPUTER
            _computePlaceholderColor: function (floated, focused) {
                return floated && focused ? 'light-blue-a700' : null;
            },

            // COMPUTER
            _computePlaceholderOpacity: function (floated) {
                return floated ? 'secondary' : 'hint';
            },

            // COMPUTER
            _computeUnderlineColor: function (invalid) {
                return invalid ? 'red-400' : 'light-blue-a700';
            },

            /*********************************************************************/

            // OBSERVER
            _inputChanged: function (post, pre) {

                // Vars
                var self = this;

                // Checking
                if (arguments.length < 2) { return; }

                // Listening
                if (XP.isElement(pre)) { self.unlisten(pre, 'input', '_handleInput'); }
                if (XP.isElement(post)) { self.listen(post, 'input', '_handleInput'); }
            },

            // OBSERVER
            _maxRowsChanged: function (post) {
                var self = this, rows = XP.toInt(post, true);
                if (self.mirrored) { XP.setStyle(self.$.matInputMirror, 'max-height', rows ? (rows * 20) + 'px' : null); }
            },

            // OBSERVER
            _minRowsChanged: function (post) {
                var self = this, rows = XP.toInt(post, true) || 1;
                if (self.mirrored) { XP.setStyle(self.$.matInputMirror, 'min-height', (rows * 20) + 'px'); }
            },

            // OBSERVER
            _valueChanged: function (post) {
                this._mirror(post);
            },

            /*********************************************************************/

            // HANDLER
            _handleInput: function () {
                this._mirror(this.input.value);
            }
        });
    </script>

</dom-module><dom-module id="mat-dropdown" assetpath="../bower_components/mat-dropdown/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }

        :host([empty-items]) {
            display: none !important;
        }

        :host([inline]) {
            display: inline-block;
        }

        :host([full-width]) {
            display: block;
            margin: 0;
            width: auto !important;
        }

        :host ::content input {
            display: none !important;
        }

        :host #matDropdownDecorator::shadow #matInputPrefix,
        :host #matDropdownDecorator::shadow #matInputSuffix,
        :host #matDropdownOptions ::content mat-option #matOptionIcon,
        :host #matDropdownOptions ::content mat-option #matOptionSecondaryText,
        :host([full-width]) #matDropdownDecorator::shadow #matInputUnderline,
        :host([full-width]) #matDropdownDecorator::shadow #matInputHelper,
        :host([pulldown]) #matDropdownDecorator::shadow #matInputUnderline,
        :host([pulldown]) #matDropdownDecorator::shadow #matInputHelper,
        :host([pulldown]) #matDropdownOptions ::content mat-option[active] {
            display: none !important;
        }

        :host([full-width]) #matDropdownDecorator::shadow #matInputWrapper,
        :host([pulldown]) #matDropdownDecorator::shadow #matInputWrapper,
        :host #matDropdownDecorator::shadow #matInputMain {
            margin: 0;
            padding: 0;
        }

        :host([floated]) #matDropdownDecorator::shadow #matInputPlaceholder {
            -webkit-transform: translate3d(0, -16px, 0);
            transform: translate3d(0, -16px, 0);
        }

        :host(:not([floated])) #matDropdownDecorator::shadow #matInputPlaceholder,
        :host([floated]:not([picked]):not([showed])) #matDropdownDecorator::shadow #matInputPlaceholder {
        @apply(--mat-font-subhead);
            line-height: 36px !important; /* override */
            -webkit-transform: translate3d(0, 0px, 0);
            transform: translate3d(0, 0px, 0);
        }

        :host([full-width]) #matDropdownDecorator::shadow #matInputPlaceholder,
        :host([pulldown]) #matDropdownDecorator::shadow #matInputPlaceholder {
            line-height: 56px !important; /* override */
        }

        :host #matDropdownDecorator::shadow #matInputPlaceholder,
        :host #matDropdownPicked::shadow #matOptionMain {
            padding: 0;
        }

        :host([full-width]) #matDropdownDecorator::shadow #matInputPlaceholder,
        :host([full-width]) #matDropdownPicked::shadow #matOptionMain {
            padding: 0 16px;
        }

        :host([pulldown]) #matDropdownDecorator::shadow #matInputPlaceholder,
        :host([pulldown]) #matDropdownPicked::shadow #matOptionMain {
            padding: 0 16px 0 24px;
        }

        :host #matDropdownDecorator .dummyOption {
            @apply(--mat-font-subhead);
            height: 0 !important;
            overflow: hidden;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host #matDropdownDecorator .dummyOption,
        :host #matDropdownOptions ::content mat-option #matOptionMain {
            padding: 0 24px 0 16px;
        }

        :host([pulldown]) #matDropdownDecorator .dummyOption,
        :host([pulldown]) #matDropdownOptions ::content mat-option #matOptionMain,
        :host([pulldown]) #matDropdownFirst::shadow #matOptionMain {
            padding: 0 48px 0 24px;
        }

        :host #matDropdownPicked {
            height: 36px;
        }

        :host([full-width]) #matDropdownPicked,
        :host([pulldown]) #matDropdownPicked {
            height: 56px;
        }

        :host(:not([picked])) #matDropdownPicked::shadow #matOptionWrapper[foreground="dark"] #matOptionLabel {
            opacity: 0.44;
        }

        :host(:not([picked])) #matDropdownPicked::shadow #matOptionWrapper[foreground="light"] #matOptionLabel {
            opacity: 0.30;
        }

        :host #matDropdownUp {
            position: absolute;
            right: 16px;
            top: 16px;
        }

        :host(:not([pulldown])) #matDropdownUp {
            display: none !important;
        }

        :host(:not([pulldown])) #matDropdownFirst,
        :host(:not([picked])) #matDropdownFirst {
            display: none !important;
        }

        :host #matDropdownDivider {
            top: 56px;
        }

        :host(:not([pulldown])) #matDropdownDivider {
            display: none !important;
        }

        :host([pulldown]) #matDropdownOptions ::content mat-option,
        :host([pulldown]) #matDropdownFirst {
            height: 56px;
            margin: -8px 0 8px 0;
        }

        :host([pulldown]) #matDropdownOptions ::content mat-option + mat-option,
        :host([pulldown][picked]) #matDropdownOptions ::content mat-option {
            height: 32px;
            margin: 0;
        }

        /* TABLET */

        @media (min-width: 960px) {

            :host([full-width]) {
                margin: 0;
            }

            :host([full-width]) #matDropdownDecorator::shadow #matInputPlaceholder,
            :host([full-width]) #matDropdownPicked::shadow #matOptionMain {
                padding: 0 24px;
            }
        }
    </style>

    <template>
        <mat-input-decorator id="matDropdownDecorator" description="[[description]]" disabled="[[disabled]]" empty="[[!picked]]" error="[[error]]" floated="{{floated}}" focused="[[focused]]" floating-label="[[_hasFloatingLabel(floatingLabel, fullWidth, pulldown)]]" full-width="[[fullWidth]]" input="[[input]]" invalid="[[invalid]]" invalid-message="[[invalidMessage]]" label="[[label]]" value="[[value]]">
            <div id="matDropdownSpacer">
                <div class="dummyOption">{{label}}</div>
                <template is="dom-repeat" items="[[items]]" observe="label value">
                    <div class="dummyOption">{{_computeLabel(item.label, item.value)}}</div>
                </template>
            </div>
            <mat-option id="matDropdownPicked" disabled="[[disabled]]" label="[[pickedLabel]]" secondary-icon="[[_computeArrowIcon(singleItem, picked)]]" value="[[pickedValue]]" on-blur="_blurHandler" on-focus="_focusHandler" on-xp-activate="_handleShow"></mat-option>
            <mat-menu id="matDropdownMenu" background="[[background]]" showed="{{showed}}" target="[[self.$.matDropdownPicked]]">
                <mat-icon id="matDropdownUp" name="navigation:arrow-drop-up" opacity="hint"></mat-icon>
                <mat-option id="matDropdownFirst" label="[[selection.label]]" value="[[selection.value]]"></mat-option>
                <mat-divider id="matDropdownDivider" cap=""></mat-divider>
                <div id="matDropdownOptions" on-xp-activate="_handleActivate">
                    <content id="content"></content>
                </div>
            </mat-menu>
        </mat-input-decorator>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-dropdown',

            // BEHAVIORS
            behaviors: [
                Polymer.XPInputBehavior,
                Polymer.XPReferralBehavior,
                Polymer.XPSelectedBehavior
            ],

            /*********************************************************************/

            /**
             * Blurs the input.
             *
             * @method blur
             * @returns {Element}
             */
            blur: function () {
                var self = this;
                self.$.matDropdownPicked.blur();
                return self;
            },

            /**
             * Focuses the input.
             *
             * @method focus
             * @returns {Element}
             */
            focus: function () {
                var self = this;
                self.$.matDropdownPicked.focus();
                return self;
            },

            /**
             * Hides the dropdown.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this;
                self.$.matDropdownMenu.hide();
                return self._resize();
            },

            /**
             * Picks an option.
             *
             * @method pick
             * @param {string} [value = ""]
             * @returns {Element}
             */
            pick: function (value) {

                // Vars
                var self   = this,
                    casted = value === 0 ? '0' : value || '',
                    picked = self.selection && self.selection.value === casted,
                    item   = picked ? self.selection : self.findItem(function (item) { return item.getAttribute('value') === casted; });

                // Checking
                if (picked) { return item; }

                // Picking
                if (self.selection) { self.unselect(self.selection, true, true); }
                if (item) { self.select(item, true); }

                return item;
            },

            /**
             * Shows the dropdown.
             *
             * @method show
             * @returns {Element}
             */
            show: function () {
                var self = this;
                self.$.matDropdownMenu.show();
                return self._resize();
            },

            /**
             * Toggles the dropdown.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this;
                self.$.matDropdownMenu.toggle();
                return self._resize();
            },

            /*********************************************************************/

            /**
             * Commits from input's value.
             *
             * @method _commitFrom
             * @returns {Element}
             * @private
             */
            _commitFrom: function () {
                var self = this;
                self.value = self.input.value;
                return self;
            },

            /**
             * Commits to input's value.
             *
             * @method _commitTo
             * @returns {Element}
             * @private
             */
            _commitTo: function () {
                var self = this;
                if (self.value !== self.input.value) { self.input.value = self.value; }
                return self;
            },

            /**
             * Indexes the input.
             *
             * @method _index
             * @param {number} value
             * @returns {Element}
             * @private
             */
            _index: function (value) {
                var self = this;
                self.$.matDropdownPicked.tabIndex = value;
                self.$.matDropdownFirst.tabIndex  = value;
                return self;
            },

            /**
             * Injects the input element.
             *
             * @method _inject
             * @returns {Element}
             * @private
             */
            _inject: function () {
                var self = this;
                self._setInput(XP.appendChild(Polymer.dom(self), XP.createElement('input', {attributes: {type: 'text', value: self.value}})));
                return self;
            },

            /**
             * Resizes the dropdown's menu.
             *
             * @method _resize
             * @returns {Element}
             * @private
             */
            _resize: function () {
                var self = this;
                XP.setStyle(self.$.matDropdownMenu.$.matMenuAdaptee.$.matOverlayAdaptee, 'width', self.clientWidth + 'px');
                return self;
            },

            /**
             * Updates the input.
             *
             * @method _update
             * @returns {Element}
             * @private
             */
            _update: function () {
                var self = this;
                XP.setAttribute(self.input, 'disabled', self.disabled);
                XP.setAttribute(self.input, 'name', self.name);
                XP.setAttribute(self.input, 'required', self.required);
                return self;
            },

            /**
             * Validates the input.
             *
             * @method _validate
             * @returns {Element}
             * @private
             */
            _validate: function () {
                var self = this;
                self._setInvalid(self.input.validity.valid !== true);
                self._setInvalidMessage(self.input.validationMessage || null);
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'items-changed': '_handleItems',
                'selection-changed': '_handleSelection',
                'value-changed': '_handleValue'
            },

            // PROPERTIES
            properties: {

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The description to be shown underneath the input
                 *
                 * @attribute description
                 * @type string
                 */
                description: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the input's label is floated.
                 *
                 * @attribute floated
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                floated: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the input's label will float above the input.
                 *
                 * @attribute floating-label
                 * @type boolean
                 * @default false
                 */
                floatingLabel: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the input is full width.
                 *
                 * @attribute full-width
                 * @type boolean
                 * @default false
                 */
                fullWidth: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The attribute used as index.
                 *
                 * TODO Temporary webcomponents polyfill's fix for `hostAttributes`.
                 *
                 * @attribute index-attribute
                 * @type string
                 * @default "value"
                 */
                indexAttribute: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'value'
                },

                /**
                 * If set to true, the input is inline.
                 *
                 * @attribute inline
                 * @type boolean
                 * @default false
                 */
                inline: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The selector used to recognize selectable items.
                 *
                 * TODO Temporary webcomponents polyfill's fix for `hostAttributes`.
                 *
                 * @attribute item-selector
                 * @type string
                 * @default "mat-option"
                 */
                itemSelector: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'mat-option'
                },

                /**
                 * If set to true, an option is picked.
                 *
                 * @attribute picked
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                picked: {
                    computed: '_computePicked(selection)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The picked option's label.
                 *
                 * @attribute picked-label
                 * @type string
                 * @notifies
                 * @readonly
                 */
                pickedLabel: {
                    notify: true,
                    readOnly: true,
                    type: String,
                    value: null
                },

                /**
                 * The picked option's value.
                 *
                 * @attribute picked-value
                 * @type string
                 * @default ""
                 * @notifies
                 * @readonly
                 */
                pickedValue: {
                    notify: true,
                    readOnly: true,
                    type: String,
                    value: ''
                },

                /**
                 * If set to true, the selected option is always on top.
                 *
                 * @attribute pulldown
                 * @type boolean
                 * @default false
                 */
                pulldown: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the input is required.
                 *
                 * @attribute required
                 * @type boolean
                 * @default false
                 */
                required: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the overlay is showed.
                 *
                 * @attribute showed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                showed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeArrowIcon: function (singleItem, selected) {
                return !singleItem || !selected ? 'navigation:arrow-drop-down' : null;
            },

            // COMPUTER
            _computeLabel: function (label, value) {
                return label || value;
            },

            // COMPUTER
            _computePicked: function (selection) {
                return !!selection;
            },

            // COMPUTER
            _hasFloatingLabel: function (floatingLabel, fullWidth, pulldown) {
                return floatingLabel && !fullWidth && !pulldown;
            },

            /*********************************************************************/

            // LISTENER
            attached: function () {
                this.mutated();
            },

            // LISTENER
            mutated: function () {

                // Vars
                var self = this;

                // Setting
                self._setPickedLabel((self.selection && (self.selection.label || self.selection.value)) || '');
                self._setPickedValue((self.selection && (self.selection.value)) || '');

                // Observing
                XP.onMutation(self, self.mutated.bind(self), {attributes: true, attributeFilter: ['active', 'label', 'value'], subtree: true});
            },

            /*********************************************************************/

            // HANDLER
            _handleActivate: function (event) {
                this.select(event.detail.firer);
            },

            // HANDLER
            _handleItems: function () {
                this.pick(this.value);
            },

            // HANDLER
            _handleSelection: function () {
                if (this.selection) { this.value = this.selection.value || ''; }
            },

            // HANDLER
            _handleShow: function (event) {
                event.stopPropagation();
                this.show();
            },

            // HANDLER
            _handleValue: function () {
                this.pick(this.value);
            }
        });
    </script>

</dom-module><dom-module id="mat-avatar" assetpath="../bower_components/mat-avatar/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: not-allowed !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            border-radius: 50%;
            height: 40px;
            margin: 4px;
            width: 40px;
        }

        :host([big]) {
            height: 64px;
            margin: 0;
            width: 64px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matAvatarWrapper,
        :host #matAvatarMain {
            border-radius: inherit;
            height: 100%;
            overflow: visible;
        }

        :host #matAvatarMain {
            @apply(--layout-horizontal);
            @apply(--layout-center-center);
        }

        :host([raster]) #matAvatarWrapper {
            background: transparent !important;
        }

        :host #matAvatarAnchor {
            border-radius: inherit;
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host(:not([big])) #matAvatarAnchor:after {
            bottom: -4px;
            content: "";
            left: -4px;
            position: absolute;
            right: -4px;
            top: -4px;
        }

        :host #matAvatarIcon {
            display: block;
            position: relative;
        }

        :host([raster]) #matAvatarIcon {
            border-radius: inherit;
            height: 100%;
            width: 100%;
        }

        :host([raster]) #matAvatarIcon::shadow #matIconAdaptee [icon] {
            box-shadow: 0 0 0 1px hsla(0, 0%, 0%, 0.12) inset;
        }
    </style>

    <template>
        <mat-paper id="matAvatarWrapper" background="[[_computeCurrentBackground(active, activeBackground, background)]]" brightness="placeholder" disabled="[[disabled]]" pressable="">
            <a id="matAvatarAnchor">
                <div id="matAvatarMain">
                    <mat-icon id="matAvatarIcon" color="[[_computeCurrentColor(active, activeColor, color)]]" disabled="[[disabled]]" empty="{{empty}}" name="[[icon]]" raster="{{raster}}" src="[[iconSrc]]"></mat-icon>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matAvatarRipple" color="[[_computeCurrentColor(active, activeColor, color)]]" auto-center=""></mat-ripple>
        </mat-paper>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-avatar',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The paper's active background color.
                 *
                 * @attribute active-background
                 * @type string
                 */
                activeBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The ink's active color.
                 *
                 * @attribute active-color
                 * @type string
                 */
                activeColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element has 64px diameter instead of 40px.
                 *
                 * @attribute big
                 * @type boolean
                 * @default false
                 */
                big: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeCurrentBackground: function (active, activeBackground, background) {
                return (active && activeBackground) || background;
            },

            // COMPUTER
            _computeCurrentColor: function (active, activeColor, color) {
                return (active && activeColor) || color;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matAvatarAnchor);
            }
        });
    </script>

</dom-module><dom-module id="mat-icon-button" assetpath="../bower_components/mat-icon-button/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: not-allowed !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            border-radius: 50%;
            height: 40px;
            margin: 4px;
            width: 40px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matIconButtonWrapper,
        :host #matIconButtonMain {
            border-radius: inherit;
            height: 100%;
        }

        :host #matIconButtonMain {
            @apply(--layout-horizontal);
            @apply(--layout-center-center);
        }

        :host #matIconButtonAnchor {
            border-radius: inherit;
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host #matIconButtonAnchor:after {
            bottom: -4px;
            content: "";
            left: -4px;
            position: absolute;
            right: -4px;
            top: -4px;
        }

        :host #matIconButtonIcons,
        :host #matIconButtonIcon,
        :host #matIconButtonActiveIcon {
            display: block;
            position: relative;
        }

        :host #matIconButtonRipple {
            margin: -4px;
            padding: 4px;
        }

        /* ANIMATION */

        :host #matIconButtonIcon,
        :host #matIconButtonActiveIcon {
            -webkit-transition: opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                -webkit-transform 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            transition: opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        transform 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1);
        }

        :host([animated]) #matIconButtonIcon {
            position: absolute;
        }

        :host #matIconButtonIcon,
        :host([active]) #matIconButtonActiveIcon {
            -webkit-transform: scale(1);
            transform: scale(1);
            visibility: visible;
        }

        :host([active][animated]) #matIconButtonIcon,
        :host(:not([active])) #matIconButtonActiveIcon {
            opacity: 0;
            -webkit-transform: scale(0);
            transform: scale(0);
            visibility: hidden;
        }
    </style>

    <template>
        <div id="matIconButtonWrapper">
            <a id="matIconButtonAnchor">
                <div id="matIconButtonMain">
                    <div id="matIconButtonIcons">
                        <mat-icon id="matIconButtonIcon" color="[[_computeColor(active, activeColor, color)]]" disabled="[[disabled]]" name="[[icon]]" opacity="[[_computeOpacity(active, inactiveDim)]]" raster="{{raster}}" src="[[iconSrc]]"></mat-icon>
                        <mat-icon id="matIconButtonActiveIcon" color="[[_computeColor(active, activeColor, color)]]" disabled="[[disabled]]" name="[[activeIcon]]" raster="{{activeRaster}}" src="[[activeIconSrc]]"></mat-icon>
                    </div>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matIconButtonRipple" color="[[_computeColor(active, activeColor, color)]]" auto-center=""></mat-ripple>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-icon-button',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The ink's active color.
                 *
                 * @attribute active-color
                 * @type string
                 */
                activeColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's active icon.
                 *
                 * @attribute active-icon
                 * @type string
                 */
                activeIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's active icon's src.
                 *
                 * @attribute active-icon-src
                 * @type string
                 */
                activeIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the active icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                activeRaster: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * If set to true, both icon and active icon are set.
                 *
                 * @attribute active-icon
                 * @type string
                 * @notifies
                 * @readonly
                 */
                animated: {
                    computed: '_computeAnimated(activeIcon, activeIconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    computed: '_computeEmpty(animated, active, icon, iconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is dimmed on inactive state.
                 *
                 * @attribute inactive-dim
                 * @type boolean
                 * @default false
                 */
                inactiveDim: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeAnimated: function (activeIcon, activeIconSrc) {
                return !!activeIcon || !!activeIconSrc;
            },

            // COMPUTER
            _computeColor: function (active, activeColor, color) {
                return (active && activeColor) || color;
            },

            // COMPUTER
            _computeEmpty: function (animated, active, icon, iconSrc) {
                return (!animated || !active) && !icon && !iconSrc;
            },

            // COMPUTER
            _computeOpacity: function (active, inactiveDim) {
                return (!active && inactiveDim && 'hint') || null;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matIconButtonAnchor);
            }
        });
    </script>

</dom-module><dom-module id="mat-menu-button" assetpath="../bower_components/mat-menu-button/">

    <style>
        :host {
            display: inline-block;
            margin: 4px;
            overflow: visible;
        }

        :host #matMenuButtonAdaptee {
            display: block;
            margin: 0 -4px;
        }
    </style>

    <template>
        <mat-icon-button id="matMenuButtonAdaptee" color="[[color]]" data="[[data]]" disabled="[[disabled]]" empty="{{empty}}" focused="{{focused}}" icon="[[icon]]" icon-src="[[iconSrc]]" pressed="{{pressed}}" raster="{{raster}}" target="{{target}}" on-xp-active="_handleEvent" on-xp-activate="_handleActivate"></mat-icon-button>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-menu-button',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAdapterBehavior,
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the menu.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this, target = self.findTarget();
                if (target && target.hide) { target.hide(); }
                return self;
            },

            /**
             * Shows the menu.
             *
             * @method show
             * @returns {Element}
             */
            show: function () {
                var self = this, target = self.findTarget();
                if (target && target.show) { target.show(self, self.data); }
                return self;
            },

            /**
             * Toggles the menu.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this, target = self.findTarget();
                if (target && target.toggle) { target.toggle(self, self.data); }
                return self;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is focused.
                 *
                 * @attribute focused
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                focused: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 * @default "navigation:more-vert"
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'navigation:more-vert'
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._adapt(this.$.matMenuButtonAdaptee);
            },

            /*********************************************************************/

            // HANDLER
            _handleEvent: function (event) {

                // Stopping
                event.stopPropagation();

                // Overriding
                if (this.fire(event.type, XP.assign(event.detail, {firer: this}), {cancelable: true}).defaultPrevented) { event.preventDefault(); }
            },

            // HANDLER
            _handleActivate: function (event) {

                // Vars
                var self = this;

                // Handling
                self._handleEvent(event);

                // Showing
                if (!event.defaultPrevented) { self.show(); }
            }
        });
    </script>

</dom-module><dom-module id="google-chart" assetpath="../bower_components/google-chart/">
  <style>
:host {
  display: -webkit-flex;
  display: -ms-flex;
  display: flex;
  margin: 0;
  padding: 0;
  width: 400px;
  height: 300px;
}

#chartdiv {
  width: 100%;
}

</style>
  <template>
    <iron-ajax id="ajax" handle-as="json" url="{{data}}" on-response="_externalDataLoaded"></iron-ajax>
    <div id="chartdiv"></div>
    <google-legacy-loader on-api-load="_readyForAction"></google-legacy-loader>
  </template>
</dom-module>

<script>
(function() {
  "use strict";

  Polymer({

    is: 'google-chart',

    /**
     * Fired when the graph is displayed.
     *
     * @event google-chart-render
     */

    /**
     * Fired when the user makes a selection in the chart.
     *
     * @event google-chart-select
     * @param {object} detail
     *   @param {array} detail.selection The user-defined selection.
     */

    properties: {
      /**
       * Sets the type of the chart.
       *
       * Should be one of:
       * - `area`, `bar`, `bubble`, `candlestick`, `column`, `combo`, `geo`,
       *   `histogram`, `line`, `pie`, `scatter`, `stepped-area`
       *
       * See <a href="https://google-developers.appspot.com/chart/interactive/docs/gallery">Google Visualization API reference (Chart Gallery)</a> for details.
       *
       */
      type: {
        type: String,
        value: 'column',
        observer: '_typeChanged'
      },

      /**
       * Sets the options for the chart.
       *
       * Example:
       * <pre>{
       *   title: "Chart title goes here",
       *   hAxis: {title: "Categories"},
       *   vAxis: {title: "Values", minValue: 0, maxValue: 2},
       *   legend: "none"
       * };</pre>
       * See <a href="https://google-developers.appspot.com/chart/interactive/docs/gallery">Google Visualization API reference (Chart Gallery)</a>
       * for the options available to each chart type.
       *
       */
      options: {
        type: Object,
        value: function() { return {}; }
      },

      /**
       * Sets the data columns for this object.
       *
       * When specifying data with `cols` you must also specify `rows`, and
       * not specify `data`.
       *
       * Example:
       * <pre>[{label: "Categories", type: "string"},
       *  {label: "Value", type: "number"}]</pre>
       * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable_addColumn">Google Visualization API reference (addColumn)</a>
       * for column definition format.
       *
       * @attribute cols
       * @type array
       */
      cols: {
        type: Array,
        value: function() { return []; }
      },
      /**
       * Sets the data rows for this object.
       *
       * When specifying data with `rows` you must also specify `cols`, and
       * not specify `data`.
       *
       * Example:
       * <pre>[["Category 1", 1.0],
       *  ["Category 2", 1.1]]</pre>
       * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#addrow">Google Visualization API reference (addRow)</a>
       * for row format.
       *
       * @attribute rows
       * @type array
       */
      rows: {
        type: Array,
        value: function() { return []; }
      },

      /**
       * Sets the entire dataset for this object.
       * Can be used to provide the data directly, or to provide a URL from
       * which to request the data.
       *
       * The data format can be a two-dimensional array or the DataTable format
       * expected by Google Charts.
       * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable">Google Visualization API reference (DataTable constructor)</a>
       * for data table format details.
       *
       * When specifying data with `data` you must not specify `cols` or `rows`.
       *
       * Example:
       * <pre>[["Categories", "Value"],
       *  ["Category 1", 1.0],
       *  ["Category 2", 1.1]]</pre>
       *
       * @attribute data
       * @type array, object, or string
       */
      data: {
        type: Object, // or array, or object
        value: function() { return []; }
      },

      /**
       * Selected datapoint(s) in the map.
       *
       * An array of objects, each with a numeric row and/or column property.
       * `row` and `column` are the zero-based row or column number of an item
       * in the data table to select.
       *
       * To select a whole column, set row to null;
       * to select a whole row, set column to null.
       *
       * Example:
       * <pre>
       *   [{row:0,column:1}, {row:1, column:null}]
       * </pre>
       *
       * @attribute selection
       * @type array
       */
      selection: {
        type: Array,
        value: function() { return []; },
        observer: '_selectionChanged'
      },
    },

    observers: [
      '_loadData(rows, cols, data)'
    ],

    _packages: null,

    _chartObject: null,

    _isReady: false,

    _canDraw: false,

    _dataTable: null,

    _chartTypes: null,

    _readyForAction: function(e, detail, sender) {
      this._loadPackageByChartType();

      google.load("visualization", "1", {
        packages: this._packages[this.type],
        callback: function() {
          this._isReady = true;
          this._loadChartTypes();
          this._loadData();
        }.bind(this)
      });
    },

    _typeChanged: function() {
      // Invalidate current chart object.
      this._chartObject = null;
      this._loadData();
    },

    _selectionChanged: function() {
      if (this._chartObject && this.setSelection) {
        this._chartObject.setSelection(this.selection);
      }
    },

    /**
     * Draws the chart.
     *
     * Called automatically on first load and whenever one of the attributes
     * changes. Can be called manually to handle e.g. page resizes.
     *
     * @method drawChart
     * @return {Object} Returns null.
     */
    drawChart: function() {
      if (this._canDraw) {
        if (!this.options) {
          this.options = {};
        }
        if (!this._chartObject) {
          var chartClass = this._chartTypes[this.type];
          if (chartClass) {
            this._chartObject = new chartClass(this.$.chartdiv);
          }
        }
        if (this._chartObject) {
          google.visualization.events.addOneTimeListener(this._chartObject,
              'ready', function() {
                  this.fire('google-chart-render');
              }.bind(this));

          google.visualization.events.addListener(this._chartObject,
              'select', function() {
                  this.selection = this._chartObject.getSelection();
                  this.fire('google-chart-select',
                      { selection: this._chartObject.getSelection() });
              }.bind(this));


          this._chartObject.draw(this._dataTable, this.options);

          if (this._chartObject.setSelection){
            this._chartObject.setSelection(this.selection);
          }
        } else {
          this.$.chartdiv.innerHTML = 'Undefined chart type';
        }
      }
      return null;
    },

    _loadChartTypes: function() {
      this._chartTypes = {
        'area': google.visualization.AreaChart,
        'bar': google.visualization.BarChart,
        'bubble': google.visualization.BubbleChart,
        'candlestick': google.visualization.CandlestickChart,
        'column': google.visualization.ColumnChart,
        'combo': google.visualization.ComboChart,
        'geo': google.visualization.GeoChart,
        'histogram': google.visualization.Histogram,
        'line': google.visualization.LineChart,
        'pie': google.visualization.PieChart,
        'scatter': google.visualization.ScatterChart,
        'stepped-area': google.visualization.SteppedAreaChart,
        'table': google.visualization.Table,
        'gauge': google.visualization.Gauge
      };
    },

    _loadPackageByChartType: function() {
      this._packages = {
        'area': 'corechart',
        'bar': 'corechart',
        'bubble': 'corechart',
        'candlestick': 'corechart',
        'column': 'corechart',
        'combo': 'corechart',
        'geo': 'corechart',
        'histogram': 'corechart',
        'line': 'corechart',
        'pie': 'corechart',
        'scatter': 'corechart',
        'stepped-area': 'corechart',
        'table': 'table',
        'gauge': 'gauge'
      };
    },

    _loadData: function() {
      this._canDraw = false;
      if (this._isReady) {
        if (typeof this.data == 'string' || this.data instanceof String) {
          // Load data asynchronously, from external URL.
          this.$.ajax.generateRequest();
        } else {
          var dataTable = this._createDataTable();
          this._canDraw = true;
          if (dataTable) {
            this._dataTable = dataTable;
            this.drawChart();
          }
        }
      }
    },

    _externalDataLoaded: function(e) {
      var dataTable = this._createDataTable(e.detail.response);
      this._canDraw = true;
      this._dataTable = dataTable;
      this.drawChart();
    },

    _createDataTable: function(data) {
      var dataTable = null;

      // If a data object was not passed to this function, default to the
      // chart's data attribute. Passing a data object is necessary for
      // cases when the data attribute is a URL pointing to an external
      // data source.
      if (!data) {
        data = this.data;
      }
      if (!data)
        data = [];

      if (this.rows && this.rows.length > 0 && this.cols &&
          this.cols.length > 0) {
        // Create the data table from cols and rows.
        dataTable = new google.visualization.DataTable();
        dataTable.cols = this.cols;

        for (var i = 0; i < this.cols.length; i++) {
          dataTable.addColumn(this.cols[i]);
        }

        dataTable.addRows(this.rows);
      } else {
        // Create dataTable from the passed data or the data attribute.
        // Data can be in the form of raw DataTable data or a two
        // dimensional array.
        if (data.rows && data.cols) {
          dataTable = new google.visualization.DataTable(data);
        } else if (data.length > 0) {
          dataTable = google.visualization.arrayToDataTable(data);
        }
      }

      return dataTable;
    }
  });
})();
</script>
<dom-module id="v-chart" assetpath="../bower_components/charts-component/">
    <template>
        <div id="chartContainer"></div>
    </template>
    <script>
        Polymer({
            is: 'v-chart',

            behaviors: [ValoThemeBehavior],

            properties: {

                /**
                 * The type of the chart. Defaults to 'line'
                 **/
                type: {
                    type: String,
                    value: 'line'
                },

                /**
                 * Highcharts JS object. Use this to configure the chart after creation.
                 **/
                chart: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                /* ----------- internal ----------- */

                /**
                 * Initial chart configuration before initial rendering.
                 **/
                _chartConf: {
                    type: Object,
                    value: function () {
                        return {chart: {}};
                    }
                }
            },

            _ignoredNodes: ["#text", "vSeries"],

            _multivaluedAttributes: ["xAxis", "yAxis", "plotBands"],

            /**
             * Dynamically add a new Series to this chart
             **/
            _addSeries: function (newSeries) {
                if (this._chartConf.series == undefined) {
                    this._chartConf.series = [];
                }
                this._chartConf.series.push(newSeries);
            },

            /**
             * Dynamically add a new Series to this chart's Drilldown configuration
             **/
            _addDrilldownSeries: function (newSeries) {
                if (!this._chartConf.drilldown) {
                    this._chartConf.drilldown = {};
                }
                if (!this._chartConf.drilldown.series) {
                    this._chartConf.drilldown.series = [];
                }
                this._chartConf.drilldown.series.push(newSeries);
            },

            /**
             * Transform the given string to camel-case
             *
             * @param {string} str
             **/
            _toCamelCase: function (str) {
                var out = "";
                str.split("-").forEach(function (word, idx) {
                    var add = word.toLowerCase();
                    out += (idx === 0 ? add : add[0].toUpperCase() + add.slice(1));
                });
                return out;
            },

            /**
             * Read configuration from one element and its attributes
             *
             * @param {object} dest the chart configuration object
             * @param {node} parent the node that is parsed for configuration
             **/
            _loadFromNode: function (dest, node) {
                for (var i in node.attributes) {
                    var attr = node.attributes[i].name;
                    if (attr != undefined) {
                        var val = node.getAttribute(attr);
                        var res;
                        try {
                            res = JSON.parse(node.getAttribute(attr));
                        } catch (e) {
                            var arr = val.split(/\s*,\s*/);
                            res = arr.length > 1 ? arr : arr[0];
                        }
                        dest[this._toCamelCase(attr)] = res;
                    }
                }
                if (this._hasOnlyTextContent(node)) {
                    dest.text = node.textContent;
                }
            },

            /**
             * Return true if node has a single child with nodeType TEXT_NODE (3) and non-empty value.
             *
             * @param {node} the node to check
             **/
            _hasOnlyTextContent: function (node) {
                return node.hasChildNodes() && node.childNodes.length == 1 && node.childNodes[0].nodeType == 3 && node.textContent.trim() != "";
            },

            /**
             * Recursively load the configuration from the light-DOM elements.
             *
             * @param {object} dest the chart configuration object
             * @param {node} parent the node that contains the configuration elements
             **/
            _loadConfiguration: function (dest, parent) {
                for (var n = 0; n < parent.childNodes.length; n++) {
                    var node = parent.childNodes[n];
                    var name = node.nodeName.toLowerCase();
                    var camelName = this._toCamelCase(name);
                    if (this._ignoredNodes.indexOf(camelName) === -1) {
                        if (dest[camelName] == undefined) {
                            dest[camelName] = {};
                            this._loadFromNode(dest[camelName], node);
                            this._loadConfiguration(dest[camelName], node);
                        } else if (this._multivaluedAttributes.indexOf(camelName) !== -1) {
                            if (dest[camelName].constructor === Array) {
                                dest[camelName].push({});
                            } else {
                                var currentVal = dest[camelName];
                                dest[camelName] = [currentVal, {}];
                            }
                            this._loadFromNode(dest[camelName][dest[camelName].length - 1], node);
                            this._loadConfiguration(dest[camelName][dest[camelName].length - 1], node);
                        }
                    }
                }
            },

            /* ----------- lifecycle ----------- */
            created: function () {
                //Workaround to prevent _chartConf from being undefined when calling _addSeries from child component in FF
                this._chartConf = {
                    chart: {}
                };
            },

            ready: function () {
                this.async(function () {

                    this._loadConfiguration(this._chartConf, Polymer.dom(this));
                    this._chartConf.chart.type = this.type;
                    this._chartConf.chart.renderTo = this.$.chartContainer;

                    if (this._loadTheme) {
                        this._loadTheme();
                    }

                    this.chart = new Highcharts.Chart(this._chartConf);
                }, 1);
            }
        });
    </script>
</dom-module>
<dom-module id="page-chart" assetpath="page-chart/">
  <style>
    code {
      color: #007000;
    }

    .chartBlock{
      display: inline;
      float: left;
      margin-bottom: 24px;
      margin-right: 6px;
      padding: 20px 20px;
      background: #FFF;
      border-radius: 3px;
      position: relative;
      -webkit-border-radius: 3px;
      border-left: 1px solid #efefef;
      border-right: 1px solid #efefef;
      border-bottom: 1px solid #e2e2e2;
      box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.04);
      transition: padding 500ms;
      -moz-transition: padding 500ms;
      -webkit-transition: padding 500ms;
    }

    title{
      color: #333;
    }

  </style>
  <template>
    <h3>Charts</h3>

    <div class="chartBlock" style="width:580px;height:400px;">
      <p>Here's a geo chart:</p>
      <google-chart id="chart3" type="geo"></google-chart>
    </div>

    <div class="chartBlock">
      <p>Here's a pie chart:</p>
      <google-chart id="chart2" type="pie"></google-chart>
    </div>
    
    <div class="chartBlock">
      <p>Here's a histogram:</p>
      <google-chart id="chart4" type="histogram" options="{" title':="" 'days="" in="" a="" month',="" 'legend':="" 'none',="" 'histogram':="" {="" 'bucketsize':="" 1="" }}'="">
      </google-chart>
    </div>

    <div class="chartBlock">
      <v-chart id="demo-piechart" type="pie">
          <title style="color: #333;">Browser market shares</title>
          <tooltip point-format="{series.name}: <b>{point.percentage:.1f}%</b>">
          </tooltip>
          <plot-options>
              <pie allow-point-select="true" cursor="pointer">
                  <data-labels enabled="true" format="<b>{point.name}</b>:    {point.percentage:.1f} %">
                  </data-labels>
              </pie>
          </plot-options>

          <v-series name="Browser share">
              <data>
                  ['Firefox',   45.0],
                  ['IE',       26.8],
                  ['Chrome', 12.8],
                  ['Safari',    8.5],
                  ['Opera',     6.2],
                  ['Others',   0.7]
              </data>
          </v-series>
      </v-chart>
    </div>
    
    <div class="chartBlock">
      <p>A simple <code>google-chart</code> looks like this:</p>
      <google-chart id="chart"></google-chart>
    </div>

    <div class="chartBlock">
      <v-chart id="demo-treemap-coloraxis" type="treemap">
          <title style="color: #333;">Here's a Treemap</title>
          <color-axis min-color="#FFFFFF" max-color="#7BB5EF"></color-axis>
          <v-series>
              <layout-algorithm>squarified</layout-algorithm>
              <data>
                  <point>
                      <name>A</name>
                      <value>6</value>
                      <color-value>1</color-value>
                  </point>
                  <point>
                      <name>B</name>
                      <value>6</value>
                      <color-value>2</color-value>
                  </point>
                  <point>
                      <name>C</name>
                      <value>4</value>
                      <color-value>3</color-value>
                  </point>
                  <point>
                      <name>D</name>
                      <value>3</value>
                      <color-value>4</color-value>
                  </point>
                  <point>
                      <name>E</name>
                      <value>2</value>
                      <color-value>5</color-value>
                  </point>
                  <point>
                      <name>F</name>
                      <value>2</value>
                      <color-value>6</color-value>
                  </point>
                  <point>
                      <name>G</name>
                      <value>1</value>
                      <color-value>7</color-value>
                  </point>
              </data>
          </v-series>
      </v-chart>
    </div>

    <div class="chartBlock">
      <p>Here's a line chart:</p>
      <google-chart id="chart5" type="line" options="{" title':="" 'days="" in="" a="" month'}'="">   
      </google-chart>
    </div>

    <div class="chartBlock">
      <p>Here's a pie chart:</p>
      <google-chart id="chart6" type="pie" options="{" title':="" 'distribution="" of="" days="" in="" 2001h1'}'="">
      </google-chart>
    </div>

    <div class="chartBlock">
      <p>Here's a scatter chart:</p>
      <google-chart id="chart7" type="scatter" options="{" legend':="" 'none'}'="">
      </google-chart>
    </div>

    <div class="chartBlock">
      <p>Here's a stepped area chart:</p>
      <google-chart id="chart8" type="stepped-area" options="{" title':="" 'days="" in="" a="" month'}'="">
      </google-chart>
    </div>

    <div class="chartBlock">
      <v-chart id="demo-column-drilldown" type="column">
          <title style="color:#333;">Browser market shares at a specific website, March 2015</title>
          <subtitle>Source: statcounter.com</subtitle>
          <x-axis type="category"></x-axis>
          <y-axis><title>Total percent market share</title></y-axis>
          <legend enabled="false"></legend>
          <plot-options>
              <series>
                  <data-labels enabled="true" format="{point.y:.1f}%">
                  </data-labels>
              </series>
          </plot-options>
          <v-series>
              <name>Brands</name>
              <color-by-point>true</color-by-point>
              <data>
                  <point>
                      <name>Microsoft Internet Explorer</name>
                      <y>56.33</y>
                      <drilldown>Microsoft Internet Explorer</drilldown>
                  </point>
                  <point>
                      <name>Chrome</name>
                      <y>24.03</y>
                      <drilldown>Chrome</drilldown>
                  </point>
                  <point>
                      <name>Firefox</name>
                      <y>10.38</y>
                      <drilldown>Firefox</drilldown>
                  </point>
                  <point>
                      <name>Safari</name>
                      <y>4.77</y>
                      <drilldown>Safari</drilldown>
                  </point>
                  <point>
                      <name>Opera</name>
                      <y>0.91</y>
                      <drilldown>Opera</drilldown>
                  </point>
                  <point>
                      <name>Proprietary or Undetectable</name>
                      <y>0.2</y>
                  </point>
              </data>
          </v-series>
          <v-series id="Microsoft Internet Explorer" drilldown="true">
              <name>Microsoft Internet Explorer</name>
              <data>
                  [ 'v11.0', 24.13 ],
                  [ 'v8.0', 17.2 ],
                  [ 'v9.0', 8.11 ],
                  [ 'v10.0', 5.33 ],
                  [ 'v6.0', 1.06 ],
                  [ 'v7.0', 0.5 ]
              </data>
          </v-series>
          <v-series id="Chrome" drilldown="true">
              <name>Chrome</name>
              <data>
                  [ 'v40.0', 5 ],
                  [ 'v41.0', 4.32 ],
                  [ 'v42.0', 3.68 ],
                  [ 'v39.0', 2.96 ],
                  [ 'v36.0', 2.53 ],
                  [ 'v43.0', 1.45 ],
                  [ 'v31.0', 1.24 ],
                  [ 'v35.0', 0.85 ],
                  [ 'v38.0', 0.6 ],
                  [ 'v32.0', 0.55 ],
                  [ 'v37.0', 0.38 ],
                  [ 'v33.0', 0.19 ],
                  [ 'v34.0', 0.14 ],
                  [ 'v30.0', 0.14 ]
              </data>
          </v-series>
          <v-series id="Firefox" drilldown="true">
              <name>Firefox</name>
              <data>
                  [ 'v35', 2.76 ],
                  [ 'v36', 2.32 ],
                  [ 'v37', 2.31 ],
                  [ 'v34', 1.27 ],
                  [ 'v38', 1.02 ],
                  [ 'v31', 0.33 ],
                  [ 'v33', 0.22 ],
                  [ 'v32', 0.15 ]
              </data>
          </v-series>
          <v-series id="Safari" drilldown="true">
              <name>Safari</name>
              <data>
                  [ 'v8.0', 2.56 ],
                  [ 'v7.1', 0.77 ],
                  [ 'v5.1', 0.42 ],
                  [ 'v5.0', 0.3 ],
                  [ 'v6.1', 0.29 ],
                  [ 'v7.0', 0.26 ],
                  [ 'v6.2', 0.17 ]
              </data>
          </v-series>
          <v-series id="Opera" drilldown="true">
              <name>Opera</name>
              <data>
                  [ 'v12.x', 0.34 ],
                  [ 'v28', 0.24 ],
                  [ 'v27', 0.17 ],
                  [ 'v29', 0.16 ]
              </data>
          </v-series>
      </v-chart>
    </div>



  </template>
</dom-module>
  <script>

    Polymer({

      is: 'page-chart',

      attached: function() {

        this.$.chart.data= [['Categories', 'Value'],['Category 1', 1.0],['Category 2', 1.1]];

        this.$.chart2.options={'title': 'Distribution of days in 2001Q1'};
        this.$.chart2.cols=[{'label':'Month', 'type':'string'}, {'label':'Days', 'type':'number'}];
        this.$.chart2.rows=[['Jan', 31],['Feb', 28],['Mar', 31]];

        this.$.chart3.data=[['Country', 'Popularity'],
           ['Germany', 200],
           ['United States', 300],
           ['Brazil', 400],
           ['Canada', 500],
           ['France', 600],
           ['RU', 700]];

        this.$.chart4.cols=[{'label': 'Month', 'type': 'string'},{'label': 'Days', 'type': 'number'}];
        this.$.chart4.rows=[['Jan', 31],['Feb', 28],['Mar', 31],['Apr', 30],['May', 31],['Jun', 30]];

        this.$.chart5.cols=[{'label': 'Month', 'type': 'string'},{'label': 'Days', 'type': 'number'}];
        this.$.chart5.rows=[['Jan', 31],['Feb', 28],['Mar', 31],['Apr', 30],['May', 31],['Jun', 30]];

        this.$.chart6.cols=[{'label': 'Month', 'type': 'string'},{'label': 'Days', 'type': 'number'}];
        this.$.chart6.rows=[['Jan', 31],['Feb', 28],['Mar', 31],['Apr', 30],['May', 31],['Jun', 30]];

        this.$.chart7.data=[['A', 'B'],
           [20, 45],
           [31, 66],
           [50, 80],
           [77, 50],
           [68, 15]];

        this.$.chart8.cols=[{'label': 'Month', 'type': 'string'},{'label': 'Days', 'type': 'number'}];
        this.$.chart8.rows=[['Jan', 31],['Feb', 28],['Mar', 31],['Apr', 30],['May', 31],['Jun', 30]];


      }

    });

  </script>

<dom-module id="google-map-marker" assetpath="../bower_components/google-map/">
  <style>
    :host {
      display: none;
    }
  </style>
  <template><content></content></template>
</dom-module>

<script>

(function() {
  Polymer({

    is: 'google-map-marker',

    /**
     * Fired when the marker icon was clicked. Requires the clickEvents attribute to be true.
     * @param {google.maps.MouseEvent} event The mouse event.
     * @event google-map-marker-click
     */
    /**
     * Fired when the marker icon was double clicked. Requires the clickEvents attribute to be true.
     * @param {google.maps.MouseEvent} event The mouse event.
     * @event google-map-marker-dblclick
     */
    /**
     * Fired for a mousedown on the marker. Requires the mouseEvents attribute to be true.
     * @event google-map-marker-mousedown
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the DOM `mousemove` event is fired on the marker. Requires the mouseEvents
     * attribute to be true.
     * @event google-map-marker-mousemove
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the mouse leaves the area of the marker icon. Requires the mouseEvents attribute to be
     * true.
     * @event google-map-marker-mouseout
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the mouse enters the area of the marker icon. Requires the mouseEvents attribute to be
     * true.
     * @event google-map-marker-mouseover
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired for a mouseup on the marker. Requires the mouseEvents attribute to be true.
     *
     * @event google-map-marker-mouseup
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired for a rightclick on the marker. Requires the clickEvents attribute to be true.
     * @event google-map-marker-rightclick
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    properties: {
      /**
       * A Google Maps marker object.
       * @type google.maps.Marker
       */
      marker: Object,

      /**
       * The Google map object.
       * @type google.maps.Map
       */
      map: {
        type: Object,
        observer: '_mapChanged'
      },

      /**
       * A Google Map Infowindow object.
       */
      info: {
        type: Object,
        value: null
      },

      /**
       * When true, marker *click events are automatically registered.
       */
      clickEvents: {
        type: Boolean,
        value: false,
        observer: '_clickEventsChanged'
      },

      /**
       * Image URL for the marker icon.
       * @type string|google.maps.Icon|google.maps.Symbol
       */
      icon: {
        type: Object,
        value: null,
        observer: '_iconChanged'
      },

      /**
       * When true, marker mouse* events are automatically registered.
       */
      mouseEvents: {
        type: Boolean,
        value: false,
        observer: '_mouseEventsChanged'
      },

      /**
       * Z-index for the marker icon.
       */
      zIndex: {
        type: Number,
        value: 0,
        observer: '_zIndexChanged'
      },

      /**
       * The marker's longitude coordinate.
       */
      longitude: {
        type: Number,
        value: null,
        reflectToAttribute: true
      },
      /**
       * The marker's latitude coordinate.
       */
      latitude: {
        type: Number,
        value: null,
        reflectToAttribute: true
      }
    },

    observers: [
      '_updatePosition(latitude, longitude)'
    ],

    detached: function() {
      if (this.marker) {
        this.marker.setMap(null);
      }
      if (this._contentObserver)
        this._contentObserver.disconnect();
    },

    attached: function() {
      // If element is added back to DOM, put it back on the map.
      if (this.marker) {
        this.marker.setMap(this.map);
      }
    },

    _updatePosition: function() {
      if (this.marker && this.latitude != null && this.longitude != null) {
        this.marker.setPosition({
          lat: parseFloat(this.latitude),
          lng: parseFloat(this.longitude)
        });
      }
    },

    _clickEventsChanged: function() {
      if (this.map) {
        if (this.clickEvents) {
          this._forwardEvent('click');
          this._forwardEvent('dblclick');
          this._forwardEvent('rightclick');
        } else {
          this._clearListener('click');
          this._clearListener('dblclick');
          this._clearListener('rightclick');
        }
      }
    },

    _mouseEventsChanged: function() {
      if (this.map) {
        if (this.mouseEvents) {
          this._forwardEvent('mousedown');
          this._forwardEvent('mousemove');
          this._forwardEvent('mouseout');
          this._forwardEvent('mouseover');
          this._forwardEvent('mouseup');
        } else {
          this._clearListener('mousedown');
          this._clearListener('mousemove');
          this._clearListener('mouseout');
          this._clearListener('mouseover');
          this._clearListener('mouseup');
        }
      }
    },

    _iconChanged: function() {
      if (this.marker) {
        this.marker.setIcon(this.icon);
      }
    },

    _zIndexChanged: function() {
      if (this.marker) {
        this.marker.setZIndex(this.zIndex);
      }
    },

    _mapChanged: function() {
      // Marker will be rebuilt, so disconnect existing one from old map and listeners.
      if (this.marker) {
        this.marker.setMap(null);
        google.maps.event.clearInstanceListeners(this.marker);
      }

      if (this.map && this.map instanceof google.maps.Map) {
        this._mapReady();
      }
    },

    _contentChanged: function() {
      if (this._contentObserver)
        this._contentObserver.disconnect();
      // Watch for future updates.
      this._contentObserver = new MutationObserver( this._contentChanged.bind(this));
      this._contentObserver.observe( this, {
        childList: true,
        subtree: true
      });

      var content = this.innerHTML.trim();
      if (content) {
        if (!this.info) {
          // Create a new infowindow
          this.info = new google.maps.InfoWindow();
          this.infoHandler_ = google.maps.event.addListener(this.marker, 'click', function() {
            this.info.open(this.map, this.marker);
          }.bind(this));
        }
        this.info.setContent(content);
      } else {
        if (this.info) {
          // Destroy the existing infowindow.  It doesn't make sense to have an empty one.
          google.maps.event.removeListener(this.infoHandler_);
          this.info = null;
        }
      }
    },

    _mapReady: function() {
      this._listeners = {};
      this.marker = new google.maps.Marker({
        map: this.map,
        position: new google.maps.LatLng(this.latitude, this.longitude),
        title: this.title,
        draggable: this.draggable,
        visible: !this.hidden,
        icon: this.icon,
        zIndex: this.zIndex
      });
      this._contentChanged();
      this._clickEventsChanged();
      this._contentChanged();
      this._mouseEventsChanged();
      setupDragHandler_.bind(this)();
    },

    _clearListener: function(name) {
      if (this._listeners[name]) {
        google.maps.event.removeListener(this._listeners[name]);
        this._listeners[name] = null;
      }
    },

    _forwardEvent: function(name) {
      this._listeners[name] = google.maps.event.addListener(this.marker, name, function(event) {
        this.fire('google-map-marker-' + name, event);
      }.bind(this));
    },

    attributeChanged: function(attrName, oldVal, newVal) {
      if (!this.marker) {
        return;
      }

      // Cannot use *Changed watchers for native properties.
      switch (attrName) {
        case 'hidden':
          this.marker.setVisible(!this.hidden);
          break;
        case 'draggable':
          this.marker.setDraggable(this.draggable);
          setupDragHandler_.bind(this)();
          break;
        case 'title':
          this.marker.setTitle(this.title);
          break;
      }
    }
  });

  function setupDragHandler_() {
    if (this.draggable) {
      this.dragHandler_ = google.maps.event.addListener(
          this.marker, 'dragend', onDragEnd_.bind(this));
    } else {
      google.maps.event.removeListener(this.dragHandler_);
      this.dragHandler_ = null;
    }
  }

  function onDragEnd_(e, details, sender) {
    this.latitude = e.latLng.lat();
    this.longitude = e.latLng.lng();
  }
})();
</script>
<dom-module id="google-map" assetpath="../bower_components/google-map/">

  <style>
    :host {
      position: relative;
      display: block;
      height: 100%;
    }

    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

  </style>
  <template>
    <google-maps-api api-key="[[apiKey]]" client-id="[[clientId]]" version="[[version]]" libraries="[[libraries]]" signed-in="[[signedIn]]" language="[[language]]" on-api-load="_mapApiLoaded"></google-maps-api>

    <div id="map"></div>

    <content id="markers" select="google-map-marker"></content>

  </template>
</dom-module>

<script>

  Polymer({

    is: 'google-map',


    /**
     * Fired when the Maps API has fully loaded.
     * @event google-map-ready
     */
    /**
     * Fired when the when the user clicks on the map (but not when they click on a marker, infowindow, or
     * other object). Requires the clickEvents attribute to be true.
     * @event google-map-click
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the user double-clicks on the map. Note that the google-map-click event will also fire,
     * right before this one. Requires the clickEvents attribute to be true.
     * @event google-map-dblclick
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired repeatedly while the user drags the map. Requires the dragEvents attribute to be true.
     * @event google-map-drag
     */
    /**
     * Fired when the user stops dragging the map. Requires the dragEvents attribute to be true.
     * @event google-map-dragend
     */
    /**
     * Fired when the user starts dragging the map. Requires the dragEvents attribute to be true.
     * @event google-map-dragstart
     */
    /**
     * Fired whenever the user's mouse moves over the map container. Requires the mouseEvents attribute to
     * be true.
     * @event google-map-mousemove
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the user's mouse exits the map container. Requires the mouseEvents attribute to be true.
     * @event google-map-mouseout
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the user's mouse enters the map container. Requires the mouseEvents attribute to be true.
     * @event google-map-mouseover
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    /**
     * Fired when the DOM `contextmenu` event is fired on the map container. Requires the clickEvents
     * attribute to be true.
     * @event google-map-rightclick
     * @param {google.maps.MouseEvent} event The mouse event.
     */
    properties: {
      /**
       * A Maps API key. To obtain an API key, see developers.google.com/maps/documentation/javascript/tutorial#api_key.
       */
      apiKey: String,

      /**
       * A Maps API for Business Client ID. To obtain a Maps API for Business Client ID, see developers.google.com/maps/documentation/business/.
       * If set, a Client ID will take precedence over an API Key.
       */
      clientId: String,

      /**
       * A latitude to center the map on.
       */
      latitude: {
        type: Number,
        value: 37.77493,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * A Maps API object.
       */
      map: {
        type: Object,
        notify: true,
        value: null
      },

      /**
       * A comma separated list (e.g. "places,geometry") of libraries to load
       * with this map. Defaults to "places". For more information see
       * https://developers.google.com/maps/documentation/javascript/libraries.
       */
      libraries: {
        type: String,
        value: 'places'
      },

      /**
       * A longitude to center the map on.
       */
      longitude: {
        type: Number,
        value: -122.41942,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * A zoom level to set the map to.
       */
      zoom: {
        type: Number,
        value: 10,
        observer: '_zoomChanged'
      },

      /**
       * When set, prevents the map from tilting (when the zoom level and viewport supports it).
       */
      noAutoTilt: {
        type: Boolean,
        value: false
      },

      /**
       * Map type to display. One of 'roadmap', 'satellite', 'hybrid', 'terrain'.
       */
      mapType: {
        type: String,
        value: 'roadmap', // roadmap, satellite, hybrid, terrain,
        observer: '_mapTypeChanged'
      },

      /**
       * Version of the Google Maps API to use.
       */
      version: {
        type: String,
        value: '3.exp'
      },

      /**
       * If set, removes the map's default UI controls.
       */
      disableDefaultUi: {
        type: Boolean,
        value: false,
        observer: '_disableDefaultUiChanged'
      },

      /**
       * If set, the zoom level is set such that all markers (google-map-marker children) are brought into view.
       */
      fitToMarkers: {
        type: Boolean,
        value: false,
        observer: '_fitToMarkersChanged'
      },

      /**
       * If true, prevent the user from zooming the map interactively.
       */
      disableZoom: {
        type: Boolean,
        value: false,
        observer: '_disableZoomChanged'
      },

      /**
       * If set, custom styles can be applied to the map.
       * For style documentation see developers.google.com/maps/documentation/javascript/reference#MapTypeStyle
       */
      styles: {
        type: Object,
        value: function() { return {}; }
      },

      /**
       * A maximum zoom level which will be displayed on the map.
       */
      maxZoom: {
        type: Number,
        observer: '_maxZoomChanged'
      },

      /**
       * A minimum zoom level which will be displayed on the map.
       */
      minZoom: {
        type: Number,
        observer: '_minZoomChanged'
      },

      /**
       * If true, sign-in is enabled.
       * See https://developers.google.com/maps/documentation/javascript/signedin#enable_sign_in
       */
      signedIn: {
        type: Boolean,
        value: false
      },

      /**
       * The localized language to load the Maps API with. For more information
       * see https://developers.google.com/maps/documentation/javascript/basics#Language
       *
       * Note: the Maps API defaults to the preffered language setting of the browser.
       * Use this parameter to override that behavior.
       */
      language: {
        type: String
      },

      /**
       * When true, map *click events are automatically registered.
       */
      clickEvents: {
        type: Boolean,
        value: false,
        observer: '_clickEventsChanged'
      },

      /**
       * When true, map drag* events are automatically registered.
       */
      dragEvents: {
        type: Boolean,
        value: false,
        observer: '_dragEventsChanged'
      },

      /**
       * When true, map mouse* events are automatically registered.
       */
      mouseEvents: {
        type: Boolean,
        value: false,
        observer: '_mouseEventsChanged'
      },

      /**
       * Additional map options for google.maps.Map constructor.
       * Use to specify additional options we do not expose as
       * properties.
       * Ex: `<google-map additional-map-options='{"mapTypeId":"satellite"}'>`
       */
      additionalMapOptions: {
        type: Object,
        value: function() { return {}; }
      }

    },

    behaviors: [
      Polymer.IronResizableBehavior
    ],

    listeners: {
      'iron-resize': 'resize'
    },

    observers: [
      '_debounceUpdateCenter(latitude, longitude)'
    ],

    created: function() {
      this.markers = [];
    },

    attached: function() {
      this._initGMap();
    },

    detached: function() {
      if (this._mutationObserver) {
        this._mutationObserver.disconnect();
        this._mutationObserver = null;
      }
    },

    _initGMap: function() {
      if (this.map) {
        return; // already initialized
      }
      if (!(window.google && window.google.maps)) {
        return; // api not loaded
      }
      if (!this.isAttached) {
        return; // not attached
      }

      this.map = new google.maps.Map(this.$.map, this._getMapOptions());
      this._listeners = {};
      this._updateCenter();
      this._updateMarkers();
      this._addMapListeners();
      this.fire('google-map-ready');
    },

    _mapApiLoaded: function() {
      this._initGMap();
    },

    _getMapOptions: function() {
      var mapOptions = {
        zoom: this.zoom,
        tilt: this.noAutoTilt ? 0 : 45,
        mapTypeId: this.mapType,
        disableDefaultUI: this.disableDefaultUi,
        disableDoubleClickZoom: this.disableZoom,
        scrollwheel: !this.disableZoom,
        styles: this.styles,
        maxZoom: Number(this.maxZoom),
        minZoom: Number(this.minZoom)
      };

      // Only override the default if set.
      // We use getAttribute here because the default value of this.draggable = false even when not set.
      if (this.getAttribute('draggable') != null) {
        mapOptions.draggable = this.draggable
      }
      for (var p in this.additionalMapOptions)
        mapOptions[p] = this.additionalMapOptions[p];

      return mapOptions;
    },

    // watch for future updates
    _observeMarkers: function() {
      // Watch for future updates.
      if (this._mutationObserver) {
        return;
      }
      this._mutationObserver = new MutationObserver( this._updateMarkers.bind(this));
      this._mutationObserver.observe(this, {
        childList: true
      });
    },

    _updateMarkers: function() {
      var newMarkers = Array.prototype.slice.call(
          Polymer.dom(this.$.markers).getDistributedNodes());

      // do not recompute if markers have not been added or removed
      if (newMarkers.length === this.markers.length) {
        var added = newMarkers.filter(function(m) {
          return this.markers && this.markers.indexOf(m) === -1;
        }.bind(this));
        if (added.length === 0) {
          // set up observer first time around
          if (!this._mutationObserver) {
            this._observeMarkers();
          }
          return;
        }
      }

      this._observeMarkers();

      this.markers = newMarkers;

      // Set the map on each marker and zoom viewport to ensure they're in view.
      if (this.markers.length && this.map) {
        for (var i = 0, m; m = this.markers[i]; ++i) {
          m.map = this.map;
        }
      }
      if (this.fitToMarkers) {
        this._fitToMarkersChanged();
      }
    },

    /**
     * Clears all markers from the map.
     *
     * @method clear
     */
    clear: function() {
      for (var i = 0, m; m = this.markers[i]; ++i) {
        m.marker.setMap(null);
      }
    },

    /**
     * Explicitly resizes the map, updating its center. This is useful if the
     * map does not show after you have unhidden it.
     *
     * @method resize
     */
    resize: function() {
      if (this.map) {

        // saves and restores latitude/longitude because resize can move the center
        var oldLatitude = this.latitude;
        var oldLongitude = this.longitude;
        google.maps.event.trigger(this.map, 'resize');
        this.latitude = oldLatitude;  // restore because resize can move our center
        this.longitude = oldLongitude;

        if (this.fitToMarkers) { // we might not have a center if we are doing fit-to-markers
          this._fitToMarkersChanged();
        }
      }
    },

    _debounceUpdateCenter: function() {
      this.debounce('updateCenter', this._updateCenter);
    },

    _updateCenter: function() {
      this.cancelDebouncer('updateCenter');

      if (this.map && this.latitude !== undefined && this.longitude !== undefined) {
        // allow for latitude and longitude to be String-typed, but still Number valued
        var lati = Number(this.latitude);
        if (isNaN(lati)) {
          throw new TypeError('latitude must be a number');
        }
        var longi = Number(this.longitude);
        if (isNaN(longi)) {
          throw new TypeError('longitude must be a number');
        }

        var newCenter = new google.maps.LatLng(lati, longi);
        var oldCenter = this.map.getCenter();

        if (!oldCenter) {
          // If the map does not have a center, set it right away.
          this.map.setCenter(newCenter);
        } else {
          // Using google.maps.LatLng returns corrected lat/lngs.
          oldCenter = new google.maps.LatLng(oldCenter.lat(), oldCenter.lng());

          // If the map currently has a center, slowly pan to the new one.
          if (!oldCenter.equals(newCenter)) {
            this.map.panTo(newCenter);
          }
        }
      }
    },

    _zoomChanged: function() {
      if (this.map) {
        this.map.setZoom(Number(this.zoom));
      }
    },

    _clickEventsChanged: function() {
      if (this.map) {
        if (this.clickEvents) {
          this._forwardEvent('click');
          this._forwardEvent('dblclick');
          this._forwardEvent('rightclick');
        } else {
          this._clearListener('click');
          this._clearListener('dblclick');
          this._clearListener('rightclick');
        }
      }
    },

    _dragEventsChanged: function() {
      if (this.map) {
        if (this.dragEvents) {
          this._forwardEvent('drag');
          this._forwardEvent('dragend');
          this._forwardEvent('dragstart');
        } else {
          this._clearListener('drag');
          this._clearListener('dragend');
          this._clearListener('dragstart');
        }
      }
    },

    _mouseEventsChanged: function() {
      if (this.map) {
        if (this.mouseEvents) {
          this._forwardEvent('mousemove');
          this._forwardEvent('mouseout');
          this._forwardEvent('mouseover');
        } else {
          this._clearListener('mousemove');
          this._clearListener('mouseout');
          this._clearListener('mouseover');
        }
      }
    },

    _maxZoomChanged: function() {
      if (this.map) {
        this.map.setOptions({maxZoom: Number(this.maxZoom)});
      }
    },

    _minZoomChanged: function() {
      if (this.map) {
        this.map.setOptions({minZoom: Number(this.minZoom)});
      }
    },

    _mapTypeChanged: function() {
      if (this.map) {
        this.map.setMapTypeId(this.mapType);
      }
    },

    _disableDefaultUiChanged: function() {
      if (!this.map) {
        return;
      }
      this.map.setOptions({disableDefaultUI: this.disableDefaultUi});
    },

    _disableZoomChanged: function() {
      if (!this.map) {
        return;
      }
      this.map.setOptions({
        disableDoubleClickZoom: this.disableZoom,
        scrollwheel: !this.disableZoom
      });
    },

    attributeChanged: function(attrName, oldVal, newVal) {
      if (!this.map) {
        return;
      }
      // Cannot use *Changed watchers for native properties.
      switch (attrName) {
        case 'draggable':
          this.map.setOptions({draggable: this.draggable});
          break;
      }
    },

    _fitToMarkersChanged: function() {
      // TODO(ericbidelman): respect user's zoom level.

      if (this.map && this.fitToMarkers) {
        var latLngBounds = new google.maps.LatLngBounds();
        for (var i = 0, m; m = this.markers[i]; ++i) {
          latLngBounds.extend(
              new google.maps.LatLng(m.latitude, m.longitude));
        }

        // For one marker, don't alter zoom, just center it.
        if (this.markers.length > 1) {
          this.map.fitBounds(latLngBounds);
        }

        this.map.setCenter(latLngBounds.getCenter());
      }
    },

    _addMapListeners: function() {
      google.maps.event.addListener(this.map, 'center_changed', function() {
        var center = this.map.getCenter();
        this.latitude = center.lat();
        this.longitude = center.lng();
      }.bind(this));

      google.maps.event.addListener(this.map, 'zoom_changed', function() {
        this.zoom = this.map.getZoom();
      }.bind(this));

      this._clickEventsChanged();
      this._dragEventsChanged();
      this._mouseEventsChanged();
    },

    _clearListener: function(name) {
      if (this._listeners[name]) {
        google.maps.event.removeListener(this._listeners[name]);
        this._listeners[name] = null;
      }
    },

    _forwardEvent: function(name) {
      this._listeners[name] = google.maps.event.addListener(this.map, name, function(event) {
        this.fire('google-map-' + name, event);
      }.bind(this));
    }

  });

</script>
<dom-module id="google-map-directions" assetpath="../bower_components/google-map/">
  <style>
    :host {
      display: none;
    }
  </style>
  <template>
    <google-maps-api api-key="[[apiKey]]" libraries="[[libraries]]" language="[[language]]" on-api-load="_mapApiLoaded"></google-maps-api>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'google-map-directions',

/**
Fired whenever the directions service returns a result.

@event google-map-response
@param {Object} detail
@param {object} detail.response The directions service response.
*/
    properties: {
      /**
       * A Maps API key. To obtain an API key, see developers.google.com/maps/documentation/javascript/tutorial#api_key.
       */
      apiKey: String,

      /**
       * The Google map object.
       *
       * @type google.maps.Map
       */
      map: {
        type: Object,
        observer: '_mapChanged'
      },
      /**
       * Start address or latlng to get directions from.
       *
       * @type string|google.maps.LatLng
       */
      startAddress: {
        type: String,
        value: null
      },

      /**
       * End address or latlng for directions to end.
       *
       * @type string|google.maps.LatLng
       */
      endAddress: {
        type: String,
        value: null
      },

      /**
       * Travel mode to use.  One of 'DRIVING', 'WALKING', 'BICYCLING', 'TRANSIT'.
       */
      travelMode: {
        type: String,
        value: 'DRIVING'
      },

      /**
       * A comma separated list (e.g. "places,geometry") of libraries to load
       * with this map. Defaults to "places". For more information see
       * https://developers.google.com/maps/documentation/javascript/libraries.
       *
       * Note, this needs to be set to the same value as the one used on <google-map>.
       * If you're overriding that element's `libraries` property, this one also
       * needs to be set to the Maps API loads the library code.
       */
      libraries: {
        type: String,
        value: 'places'
      },

      /**
       * The localized language to load the Maps API with. For more information
       * see https://developers.google.com/maps/documentation/javascript/basics#Language
       *
       * Note: the Maps API defaults to the preffered language setting of the browser.
       * Use this parameter to override that behavior.
       */
      language: {
        type: String,
        value: null
      },

      /**
       * The response from the directions service.
       *
       */
      response: {
        type: Object,
        observer: '_responseChanged',
        notify: true
      }
    },

    observers: [
      '_route(startAddress, endAddress, travelMode)'
    ],

    _mapApiLoaded: function() {
      this._route();
    },

    _responseChanged: function() {
      if (this.directionsRenderer && this.response) {
        this.directionsRenderer.setDirections(this.response);
      }
    },

    _mapChanged: function() {
      if (this.map && this.map instanceof google.maps.Map) {
        if (!this.directionsRenderer) {
          this.directionsRenderer = new google.maps.DirectionsRenderer();
        }
        this.directionsRenderer.setMap(this.map);
        this._responseChanged();
      } else {
        // If there is no more map, remove the directionsRenderer from the map and delete it.
        this.directionsRenderer.setMap(null);
        this.directionsRenderer = null;
      }
    },

    _route: function() {
      // Abort attempts to _route if the API is not available yet or the
      // required attributes are blank.
      if (typeof google == 'undefined' || typeof google.maps == 'undefined' ||
          !this.startAddress || !this.endAddress) {
        return;
      }

      // Construct a directionsService if necessary.
      // Wait until here where the maps api has loaded and directions are actually needed.
      if (!this.directionsService) {
        this.directionsService = new google.maps.DirectionsService();
      }

      var request = {
        origin: this.startAddress,
        destination: this.endAddress,
        travelMode: this.travelMode
      };
      this.directionsService.route(request, function(response, status) {
        if (status == google.maps.DirectionsStatus.OK) {
          this.response = response;
          this.fire('google-map-response', {response: response});
        }
      }.bind(this));
    }
  });
</script>
<dom-module id="page-map" assetpath="page-map/">
  <style>
    :host {
      display: block;
      
    }

    google-map {
      height: 360px;
      width: 360px;
      margin: 12px;

    }

    .mapBlock{
      float: left;
      display: inline;
      margin-bottom: 24px;
      margin-right: 6px;
      padding: 20px 20px;
      background: #FFF;
      border-radius: 3px;
      position: relative;
      -webkit-border-radius: 3px;
      border-left: 1px solid #efefef;
      border-right: 1px solid #efefef;
      border-bottom: 1px solid #e2e2e2;
      box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.04);
      transition: padding 500ms;
      -moz-transition: padding 500ms;
      -webkit-transition: padding 500ms;
    }

    .blockTitle{
      font-size:1.2em;
      margin: 12px;
    }

  </style>
  <template>
    <div class="mapBlock">
      <span class="blockTitle">Basic Map
      <google-map latitude="37.77493" longitude="-122.41942"></google-map>
    </span></div>
    
    <div class="mapBlock">
      <span class="blockTitle">Map with Marker
      <google-map latitude="37.77493" longitude="-122.41942" fit-to-markers="">
        <google-map-marker latitude="37.779" longitude="-122.3892" draggable="true" title="Go Giants!"></google-map-marker>
        <google-map-marker latitude="37.777" longitude="-122.38911"></google-map-marker>
      </google-map>
    </span></div>

    <div class="mapBlock">
      <span class="blockTitle">Terrain Map
      <google-map latitude="37.77493" longitude="-122.41942" map-type="terrain"></google-map>
    </span></div>

    <div class="mapBlock">
      <span class="blockTitle">Hybrid Map
      <google-map latitude="37.77493" longitude="-122.41942" map-type="hybrid"></google-map>
    </span></div>

  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-map',

    properties: {
      map:Object
    }
  });
})();
</script>
<dom-module id="page-dashboard" assetpath="page-dashboard/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello!<br>Already filled: 
    <ul>
      <li>Maps</li>
      <li>Charts</li>
    </ul>
    </div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-dashboard',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-layouts" assetpath="page-layouts/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-layouts',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-uielements" assetpath="page-uielements/">
  <style>
    :host {
      display: block;
    }

  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>



  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-uielements',


    properties: {
      foo: {
        type: String,
        value: 'ui',
        notify: true
      }
    }
  });
})();
</script>


<dom-module id="page-forms" assetpath="page-forms/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-forms',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-tables" assetpath="page-tables/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-tables',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-email" assetpath="page-email/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-email',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-typography" assetpath="page-typography/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-typography',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-pages" assetpath="page-pages/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-pages',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
<dom-module id="page-menulevel" assetpath="page-menulevel/">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <div>Hello from <span>{{foo}}</span></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'page-menulevel',

    properties: {
      foo: {
        type: String,
        value: 'bar',
        notify: true
      }
    }
  });
})();
</script>
</div></body></html>